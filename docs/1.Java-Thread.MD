# 자바 스레드 구조
자바 스레드는 JVM 에서 사용자 수준 스레드를 생성할 때 시스템 콜을 통해서 커널에서 생성된 커널 스레드와 1:1 매핑이 되어 최종적으로 커널에서 관리 됩니다. JVM 에서 스레드를 생성할때 마다 커널에서 자바 스레드와 대응하는 커널 스레드를 생성한다. 자바에서는 Platform Thread 으로 정의되어있다. 즉 OS 플랫폼에 따라 JVM 이 사용자 스레드를 매핑하게된다

> **Platform threads**
"플랫폼 스레드(Platform Thread)"라는 용어는 일반적으로 **특정 운영 체제에서 네이티브로 제공하는 스레드**를 가리킵니다. 자바에서 스레드를 생성할 때, JVM(Java Virtual Machine)은 내부적으로 운영 체제의 스레드 시스템을 사용하여 이러한 스레드를 구현합니다. 즉, 자바 스레드는 운영 체제의 플랫폼 스레드에 매핑됩니다.

**네이티브 스레드**
"네이티브 스레드"는 **특정 운영 체제에서 지원하는 스레드**를 의미합니다. 이는 운영 체제의 API를 통해 생성되고 관리됩니다.
****주로 프로그래밍 언어나 애플리케이션 수준에서 운영 체제의 스레드를 사용할 때 쓰입니다. 자바 애플리케이션에서 생성된 스레드가 운영 체제의 API를 통해 생성되고 관리되는 스레드를 가리키는데 사용됩니다. 네이티브 스레드는 JVM과 같은 런타임 환경에 의해 추상화되어 관리되며, 이는 운영 체제의 커널 스레드에 매핑됩니다.

### **JVM에서의 스레드 처리**

JVM은 자바 애플리케이션을 실행하는 환경입니다. JVM 내부에서 스레드는 다음과 같이 처리됩니다:

- JVM은 각 스레드에 대한 메모리 할당(스택 등)을 관리합니다.
- 자바 스레드는 내부적으로 OS의 네이티브 스레드에 매핑됩니다. 이 매핑은 JVM의 스레드 모델과 OS에 따라 다를 수 있습니다.
- JVM은 스레드의 생명주기(생성, 시작, 실행, 종료)를 관리합니다.

### **OS 스레드 스케줄링과의 차이**

- **운영 체제 수준의 스레드**: 운영 체제는 자체 스레드 스케줄러를 가지고 있으며, 모든 스레드(시스템 스레드 및 사용자 애플리케이션 스레드)를 관리합니다. 이 스케줄러는 CPU 시간을 스레드에 할당하고, 스레드의 실행 순서를 결정합니다.
- **자바 스레드**: 자바에서 생성된 스레드는 결국 OS의 네이티브 스레드로 매핑됩니다. 즉, 실제 스레드의 스케줄링은 OS에 의해 이루어집니다. JVM은 스레드 생성, 관리, 종료 등의 과정을 추상화하고, 자바 프로그래머가 OS에 직접적으로 의존하지 않고 스레드를 사용할 수 있게 합니다.

## 스레드 생성

자바에서 스레드는 주로 두 가지 방법으로 생성됩니다:

1. **`Thread`** 클래스를 상속받아서 구현.
2. **`Runnable`** 인터페이스를 구현.

1. **`Thread` 클래스 상속**:

    ```java
    class MyThread extends Thread {
        public void run() {
            // 스레드가 수행할 작업
        }
    }
    
    Thread thread = new MyThread();
    thread.start(); // 스레드 시작
    
    ```

    - 작업 내용을 스레드 내부에 직접 재정의해서 실행
2. **`Runnable` 인터페이스 구현**:

    ```java
    class MyRunnable implements Runnable {
        public void run() {
            // 스레드가 수행할 작업
        }
    }
    
    Thread thread = new Thread(new MyRunnable());
    thread.start(); // 스레드 시작
    
    ```

    - 작업 내용을 Runnable 에 정의해서 스레드에 전달
3. **람다 표현식 사용 (Java 8 이상)**:

    ```java
    Runnable task = () -> {
        // 스레드가 수행할 작업
    };
    
    Thread thread = new Thread(task);
    thread.start(); // 스레드 시작
    
    ```


1. **Thread 익명 클래스**

    ```java
    Thread thread = new Thread() {
        public void run() {
            // 스레드가 실행할 코드
            System.out.println("Thread 익명 클래스 사용");
        }
    };
    
    thread.start(); // 스레드 시작
    ```

    - 일회용으로만 사용할때
2. **Runnable 익명 클래스**

    ```java
    Runnable runnable = new Runnable() {
        public void run() {
            // 스레드가 실행할 코드
            System.out.println("Runnable 익명 클래스 사용");
        }
    };
    
    Thread thread = new Thread(runnable);
    thread.start(); // 스레드 시작
    ```


### **스레드 상태 변경 메서드**

1. **`start()`**: 새로운 스레드를 시작하고, 스레드의 **`run()`** 메서드를 호출합니다.
2. **`run()`**: 스레드가 수행할 작업을 정의합니다.
3. **`sleep(long millis)`**: 현재 스레드를 지정된 시간(밀리초) 동안 일시 중지합니다.
4. **`join()`**: 스레드가 종료될 때까지 현재 스레드의 실행을 중지합니다.
5. **`interrupt()`**: 스레드에 인터럽트를 보냅니다. 인터럽트에 응답하는 방식은 스레드의 **`run()`** 메서드 구현에 달렸습니다.
6. **`yield()`**: 현재 스레드가 실행 중지를 하고 다른 스레드에 실행 기회를 제공합니다.

### **기타 메서드**

- **`setPriority(int newPriority)`**: 스레드의 우선순위를 설정합니다.
- **`getPriority()`**: 스레드의 현재 우선순위를 반환합니다.
- **`setName(String name)`**: 스레드의 이름을 설정합니다.
- **`getName()`**: 스레드의 이름을 반환합니다.
- **`isAlive()`**: 스레드가 살아 있는지(시작되었고 아직 종료되지 않았는지) 확인합니다.
- **`isInterrupted()`**: 스레드가 인터럽트 되었는지 확인합니다.
- **`static interrupted()`**: 현재 스레드의 인터럽트 상태를 확인하고, 인터럽트 상태를 초기화합다.

# 스레드 실행

자바 스레드는 OS 스케줄러에 의해 실행 순서가 결정되며 스레드 실행 시점을 JVM 에서 제어할 수 없고 새로운 스레드는 현재 스레드 와 독립적으로 실행되고 최대 한번 시작할 수 있고 스레드가 종료된 후에는 다시 시작 할 수 없다.

자바에서 스레드 실행 과정을 설명하기 위해, 가장 기본적인 예로 **`main`** 스레드가 다른 스레드를 생성하고 시작하는 과정을 살펴보면 자바에서 스레드 실행 과정은 다음과 같은 단계를 거친다.

1. **스레드 클래스 정의**: 자바에서 스레드를 생성하기 위해서는 **`Thread`** 클래스를 확장하거나 **`Runnable`** 인터페이스를 구현하는 클래스를 정의해야 합니다.
2. **스레드 객체 생성**: 정의된 스레드 클래스 또는 **`Runnable`** 객체를 기반으로 **`Thread`** 객체를 생성합니다.
3. **스레드 시작 (`start()` 메서드 호출)**: 생성된 스레드 객체에 대해 **`start()`** 메서드를 호출합니다. 이 메서드는 스레드를 실행 가능한 상태로 만들고, 자바 가상 머신(JVM)에 이 스레드를 시작하도록 요청합니다.
4. **`private native void start0()` 메서드 호출**: 내부적으로 **`start()`** 메서드는 네이티브 메서드인 `private native void start0()`을 호출합니다. 이 메서드는 운영 체제 수준에서 새로운 스레드를 생성하고(커널 스레드가 생성되고 자바 스레드와 커널 스레드가 1대1 매핑이 이루어짐), 스레드에 할당된 **`run()`** 메서드를 실행합니다.
5. **실행 대기** : OS 스케줄러로 부터 CPU 할당을 받기까지 실행 대기 상태에 있는다.
6. **스레드 실행 (`run()` 메서드 실행)**: **`run()`** 메서드는 스레드가 수행해야 할 작업을 정의합니다. **`start0()`**에 의해 호출되면, 이 스레드는 **`run()`** 메서드에 정의된 작업을 수행하기 시작합니다.(커널 스레드가 스케줄러에 의해 실행상태가 되면 JVM 에서 매핑된 자바 스레드의 run() 메서드를 호출한다.)
7. **스레드 종료**: **`run()`** 메서드의 실행이 완료되면, 스레드는 자동적으로 종료됩니다.

> **네이티브 메서드(native method)**
> 네이티브 메서드(native method)는 자바에서 사용되는 **특별한 유형의 메서드**로, **자바 코드가 아닌 네이티브 프로그래밍 언어(보통 C나 C++)로 작성된 코드를 실행**합니다. 이러한 메서드들은 자바 네이티브 인터페이스(Java Native Interface, JNI)를 사용하여 구현됩니다.
>

예를 들어, **`main`** 스레드에서 새로운 스레드를 생성하고 시작하는 간단한 예제

```java
public class MyThread extends Thread {
    public void run() {
        System.out.println("새로운 스레드 실행 중");
    }

    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start(); // 여기에서 start0()가 내부적으로 호출되고, 스레드 실행이 시작됩니다.
    }
}

```

이 과정을 통해, 자바 프로그램에서는 멀티스레딩을 효과적으로 관리하고, 여러 작업을 동시에 수행할 수 있다.

즉, `start()` 는 스레드를 실행 시키는 메서드로 **시스템 콜을 통해서 커널에 스레드 생성을 요청 `run()`** 는 **스레드가 실행이 되면 해당 스레드에 의해 자동을 호출**되며 Thread 의 run() 이 자동으로 호출되고 여기서 Runnable 구현체가 존재할 경우 Runnable 의 run()을 실행한다. public static void main 가 메인 스레드에 의해 자동으로 호출되는 것과 비슷한 원리이다.

이때 start() 메서드가 아니라 바로 run() 메서드를 직접 호출하면 새로운 스레드가 생성되지 않고 직접 호출한 스레드의 실행 스택에서 run()이 실행된다.

1. **`start()` 메서드 호출**:
    - 새로운 스레드를 생성합니다. **`start()`** 메서드가 호출되면, 자바 가상 머신(JVM)은 새로운 스레드를 배치하고, 이 스레드에서 **`run()`** 메서드를 실행합니다.
    - **`start()`** 메서드는 내부적으로 네이티브 메서드를 호출하여 실제 운영 체제 스레드를 생성하고, 해당 스레드에서 **`run()`** 메서드를 별도의 실행 경로(execution path)에서 실행합니다.
    - 이렇게 하면 **`run()`** 메서드는 병렬로 실행되며, 다른 스레드와 동시에 실행될 수 있습니다.
2. **`run()` 메서드 직접 호출**:
    - **`run()`** 메서드를 직접 호출하는 것은 일반 메서드 호출과 같으며, 새로운 스레드를 생성하지 않습니다.
    - 이 경우, **`run()`** 메서드는 현재 스레드(예: **`main`** 스레드)에서 실행되며, 병렬 실행이 아니라 순차적으로 실행됩니다.
    - **`run()`**을 직접 호출하면 멀티스레딩의 이점을 활용할 수 없으며, 단순히 **`run()`** 메서드에 정의된 코드를 현재 스레드에서 실행하는 것과 같습니다.

결론적으로, 멀티스레딩을 활용하려면 반드시 **`start()`** 메서드를 호출해야 하며, **`run()`** 메서드를 직접 호출하는 것은 단순한 메서드 호출로서, 새로운 스레드를 생성하거나 병렬 실행을 하지 않는다.

### 스레드 스택

스레드가 생성되면 해당 스레드를 위한 스택이 같이 생성되면 이 스택은 각 스레드마다 독립적으로 할당되어 동작하기 때문에 서로간 접근이나 공유할 수 없다. 이 스택은 OS에 따라 크기가 주어지고 주어진 크기를 넘기게 되면 그 유명한 `StackOverFlowError` 가 발생하게 된다.

이 스택은 **스레드가 함수 호출을 수행할 때 필요한 데이터를 저장하는 데 사용**한다.

> **스택 프레임(Stack Frame)**
> 스택 프레임(Stack Frame)은 프로그램의 함수 호출과 실행에 필요한 정보를 저장하는 스택(Stack) 내의 데이터 구조입니다. 각 함수 호출 시에 하나의 스택 프레임이 생성되며, 이 프레임은 해당 함수가 실행되는 동안 필요한 다양한 정보를 포함합니다.
>

### 구성 정보

스레드 스택은 주로 로컬 변수(지역변수, 파라미터), 함수 호출 정보, 반환 주소 등을 저장하는 데 사용됩니다. 함수 호출이 발생할 때마다, 호출된 함수의 로컬 변수와 매개변수가 스택에 푸시(push)됩고 함수가 반환될 때, 해당 데이터는 스택에서 팝(pop)되어 제거된다.

**1. 스택 프레임(Stack Frame)**

- 스레드 스택은 여러 개의 스택 프레임으로 구성됩니다. 각 스택 프레임은 개별 함수 호출에 대한 정보를 담고 있습니다.
- 함수가 호출될 때마다 새로운 스택 프레임이 스택에 푸시되고, 함수가 반환될 때 해당 프레임은 스택에서 팝됩니다.

**2. 로컬 변수(Local Variables)**

- 각 스택 프레임은 해당 함수의 로컬 변수를 저장합니다. 이러한 변수는 함수 호출이 끝날 때까지 유효합니다.

**3. 매개변수(Parameters)**

- 함수로 전달되는 매개변수는 대부분 스택 프레임 내에 저장됩니다. 이를 통해 함수 내에서 매개변수에 접근할 수 있습니다.

**4. 반환 주소(Return Address)**

- 함수가 호출될 때, 함수가 반환될 때 다시 돌아갈 위치의 주소(반환 주소)가 스택에 저장됩니다. 함수 실행이 끝나면, 이 주소를 사용하여 호출자 함수로 돌아갑니다.

**5. 스택 포인터(Stack Pointer)**

- 스택 포인터는 스택의 현재 위치를 가리킵니다. 새로운 스택 프레임이 푸시되거나 팝될 때마다 스택 포인터가 업데이트됩니다.

**6. 프레임 포인터(Frame Pointer)**

- 프레임 포인터는 현재 활성화된 스택 프레임의 시작 부분을 가리키는데 사용됩니다. 이를 통해 현재 함수의 로컬 변수와 매개변수에 접근할 수 있습니다.

**7. 임시 저장 공간(Temporary Space)**

- 함수의 계산 중간 결과를 임시로 저장하는 공간입니다. 이 공간은 스택 프레임 내에서 필요에 따라 사용됩니다.

**8. 예외 처리 정보(Exception Handling Information)**

- 일부 프로그래밍 언어에서는 함수 내에서 발생할 수 있는 예외 처리를 위한 정보를 스택 프레임에 저장합니다.

### 스텍 메모리 상태 관리

스택은 제한된 크기를 갖으며, 일반적으로 운영 체제나 JVM 설정에 따라 결정된다. 스택 오버플로(stack overflow)는 스택이 할당된 메모리 크기를 초과할 때 발생하고 이는 무한 재귀 호출로 인해 발생할 수 있습니다. 스택 내부의 변수는 변수를 생성한 메서드가 실행되는 동안에만 존재하고 스택 메모리에 대한 접근은 Heap 메모리와 비교할때 상당히 빠르다.

### 스레드 종료

스레드는 run() 메서드가 모두 실행되면 자동으로 종료한다. 이때 예외가 발생할 경우 또한 종료되며 다른 스레드에 영향을 미치지 않는다.어플리케이션은 싱글스레드인 경우와 멀티스레드인 경우 종료 기준이 다르다.

스레드들은 비동기적으로 실행한다. 즉 각 스레드들은 독립적으로 실행해서 본인의 스택에 있는 작업을 실행하고 종료한다.

### **싱글 스레드 어플리케이션**

- 싱글 스레드 어플리케이션에서는 주로 하나의 실행 흐름만 존재합니다.
- **종료 기준**: 주 스레드(main thread)의 실행이 종료되면, 어플리케이션의 실행도 종료됩니다. 이는 보통 주 스레드의 **`main`** 함수나 유사한 진입점(entry point)의 코드가 모두 실행 완료되었을 때 발생합니다.
- 특별한 예외 처리나 중단 요청이 없는 한, **`main`** 함수 내의 코드가 순차적으로 모두 실행된 후 어플리케이션이 종료됩니다.

### **멀티스레드 어플리케이션**

- 멀티스레드 어플리케이션에서는 여러 개의 동시 실행 흐름(스레드)이 존재합니다.
- **종료 기준**: 멀티스레드 환경에서 어플리케이션의 종료 기준은 프로그래밍 언어와 환경에 따라 다를 수 있습니다. 일반적으로는 다음 두 가지 방법 중 하나를 따릅니다:
    - **모든 스레드의 종료**: 주 스레드와 모든 백그라운드 스레드가 종료될 때까지 어플리케이션이 실행 상태를 유지합니다.
    - **주 스레드의 종료만으로 충분**: 일부 환경(예: 일부 자바 어플리케이션)에서는 주 스레드가 종료되면 어플리케이션이 종료되며, 이 때 모든 백그라운드 스레드도 강제 종료됩니다. 다만, 이 경우에도 대기 중인 '데몬 스레드(daemon threads)'가 있다면 이들은 주 스레드 종료와 함께 즉시 중단됩니다.

단 스레드 유형이 데몬 스레드 일 경우 위 내용과 일부 다른점이 있다.

## 스레드의 상태

자바 스레드는 생성과 실행 그리고 종료에 따른 상태를 가지고 있으며 JVM 에서는 6가지의 스레드 상태가 존재한다. 이때 OS 스레드의 상태를 의미하지 않는다. 이 상태는 Thread의 `getState()` 메서드를 통해서 가져올 수 있으며 ENUM 상수를 정의하는 Tread.State 클래스를 제공한다. 이때 스레드의 상태는 6가지중 **단 하나의 상태만**을 가질 수 있다.

| 상태 | 설명 |
| --- | --- |
| 신규 (New) | 스레드 객체가 생성되었지만 start() 메서드가 아직 호출되지 않은 상태. |
| 실행 가능 (Runnable) | start() 메서드가 호출된 후, 실행을 위해 CPU 시간을 기다리는 상태. 실행 중과 실행 대기 상태를 포함. |
| 블록 (Blocked) | 다른 스레드가 사용 중인 객체의 잠금(락)을 얻지 못하고 대기하는 상태. |
| 대기 (Waiting) | 다른 스레드의 작업이 완료될 때까지 기다리는 상태. Object.wait(), Thread.join(), LockSupport.park()에 의해 발생. |
| 시간 대기 (Timed Waiting) | 지정된 시간 동안 대기하는 상태. Thread.sleep(), Object.wait(long timeout), Thread.join(long millis) 등에 의해 발생. |
| 종료 (Terminated) | 스레드의 실행이 완료된 상태. run() 메서드가 완료되거나 예외로 인해 종료됨. |

## 스레드 생명주기
스레드는 프로세스 내에서 실행되는 실행 단위이다. 스레드의 생명주기는 다음과 같다

1. 객체 생성 상태(New): 스레드가 생성되고 초기화됩니다. 객체는 생성 되었지만 아직 start() 메서드가 호출 되지 않은 상태로 JVM 에는 개체가 존재 하지만 아직 커널로의 실해은 안된 상태
2. 준비 (Ready or Runnable): 스레드가 실행을 위해 준비되며 CPU 할당을 기다립니다. start() 메서드를 실행 하면 내부적으로 커널로의 실행이 일어나 커널 스레드와 1:1 매핑이 된다. 바로 실행 상태가 아닌 실행 준비가 되어 있는 실행 가능한 상태로 스레드가 실행 상태로 전환하기 위해서는 현재 스레드가 어떤 상태로 존재하든지 반드시 실행 대기 상태를 거쳐야 한다.
3. 스케줄링 : 실행 가능한 스레드에게 실행할 시간을 제공(OS 스케줄러의 책임)한다. 스케줄러는 멀티 스레드 환경에서 각 스레드에게 고정된 시간을 할당해서 실행 상태와 실행 가능 상태를 오가도록 스케줄링 한다.
4. 실행 (Running:실제 생명 주기에는 Runnable 에 포함된 개념) : 스레드가 CPU를 할당받아 실행됩니다(run() 메서드를 호출). 스레드는 아주 짧은 시간동안 실행된 다음 다른 스레드가 실행될 수 있도록 CPU를 일시 중지하고 다른 스레드에게 양도한다(컨텍스트 스위칭).
    - 실행 상태 -> 실행 대기 상태 : 실행 상태에서 스레드의 yield() 메서드를 호출하거나 운영체제 스케줄러에 의해 CPU 실행을 일시 중지하는 경우 실행 가능한 상태로 전환한다.
5. 대기 상태
    - 일시 정지 상태(Timed Waiting 지정된 시간이 있는 경우) : 스레드 sleep 및 time-out 매개 변수가 있는 메서드를 호출할때 시간이 지정된 대기 상태가 된다. 스레드의 대기 시간이 길어지고 CPU의 할당을 계속 받지 못하는 상황이 발생하면 기아 상태가 발생하게 되는데 이 상황을 피할 수 있다.
    - 블록 (Blocked): 스레드가 동기화 된 임계 영역에 접근을 시도하다가 Lock을 획득하지 못해서 대기하는 상태이다. 스레드는 Lock을 획득할때 까지 대기한다. 이때 스레드가 Lock을 획득하면 실행 대기 상태가 된다.
    - 대기 (Waiting) : 스레드가 실행 상태에서 다른 스레드가 특정 작업을 수행하기를 기다리는 상태, wait()은 다른 스레드에 의해 notify()받을때까지, join()은 스레드의 실행이 종료되거나 인터럽트가 발생할 때까지 대기한다.
        - 스레드 A,B가 실행 중일때 A 스레드에서 B.join()을 호출하면 A스레드는 B스레드가 종료될때까지(run() 메서드가 완료 될때 까지) 대기하게 된다. B 스레드의 작업이 끝난 후에 다시 A 스레드의 작업을 시작한다.
    - 대기 상태에서 깨어난다 : 지정한 시간이 지나거나 다른 스레드에 의해서 인터럽트(interrupt())가 발생하거나 대기가 해제되도록 통지(notify() or notifyAll())를 받게 되면 실행대기 상태가 된다.
6. 종료 (Terminated): 스레드가 작업을 완료하거나 오류 또는 처리되지 않은 예외와 같이 비정상적으로 종료된 상태

스레드의 실행 관점에서 보면 출발지가 스레드의 **start()** 메서드 실행 이라면 목적지는 **run()** 메서드 실행이 된다는 점이다.

> **스케줄러가 고정된 시간을 할당 하는 이유**  
> 이 과정은 "시간 할당(time slicing)" 또는 "시간 분할(time sharing)"이라고 합니다.
> 1. **자원 공정 분배:** 각 스레드에 고정된 시간을 할당함으로써, 모든 스레드가 CPU 시간을 공정하게 사용할 수 있습니다. 이는 한 스레드가 CPU를 독점하는 것을 방지하여 시스템의 반응성과 성능을 향상시킵니다.
> 2. **반응성 향상:** 시간 할당을 통해 여러 스레드가 거의 동시에 실행되는 것처럼 보이게 할 수 있습니다. 이는 특히 사용자 인터페이스와 같이 빠른 반응이 필요한 애플리케이션에서 중요합니다.
> 3. **교착 상태 방지:** 스레드들이 자원을 기다리면서 무한히 대기하는 교착 상태(deadlock)를 방지할 수 있습니다. 시간 할당을 통해 모든 스레드가 일정 시간 이후에는 자원을 사용할 기회를 가지게 됩니다.
> 4. **멀티태스킹:** 시간 할당은 멀티태스킹을 가능하게 하는 핵심 메커니즘입니다. 각 스레드가 동시에 실행되는 것처럼 보이게 하여, 여러 작업을 효율적으로 처리할 수 있습니다.
> 5. **자원 관리 최적화:** OS 스케줄러는 시스템의 전반적인 자원을 관리하고 최적화합니다. 시간 할당을 통해 CPU 사용, 메모리 접근 등을 효과적으로 조절할 수 있습니다.
