
# 자바 동시성 프로그래밍

## 스레드 풀
스레드풀(thread pool)은 `여러 스레드를 미리 생성하여 풀에 보관하는 프로그래밍 패턴`입니다. 작업이 발생할 때마다 새로운 스레드를 생성하는 것이 아니라, 미리 생성해 둔 스레드를 재사용하여 리소스 사용을 최적화하고 시스템의 응답 시간을 개선하는 데 도움이 됩니다.

스레드풀은 특히 고성능 서버나 응용 프로그램에서 자주 사용됩니다. 이제 왜 필요한지, 어떤 것들을 고려해야 하는지, 핵심 구성 요소는 무엇인지, 그리고 예를 들어 설명해보겠습니다.

### **스레드풀이 필요한 이유**

1. **성능 최적화**: 매번 스레드를 생성하고 소멸시키는 것은 CPU와 메모리 자원을 상당량 소모합니다. 스레드풀을 사용하면 이러한 오버헤드를 줄일 수 있습니다.
2. **자원의 효율적 사용**: 한정된 자원을 효율적으로 사용하여, 더 많은 작업을 동시에 처리할 수 있습니다.
3. **응답 시간 감소**: 작업을 바로 처리할 수 있는 스레드가 이미 준비되어 있기 때문에, 작업 요청과 처리 사이의 지연 시간이 줄어듭니다.
4. **시스템 보호:** 한번에 대량의 트래픽이 발생했을때 리소스에 접근할 수 있는 요청을 제하나고 대기하도록 함으로써 시스템이 다운되거나 중단되지 않도록한다.

### **스레드풀 구현 시 고려사항**

1. **스레드 수**: 시스템의 자원, 요구 성능, 작업의 종류에 따라 적절한 스레드 수를 결정해야 합니다.
2. **작업 큐**: 대기 중인 작업을 저장하는 큐를 관리해야 하며, 이 큐는 스레드들이 접근할 때 동기화 처리가 필요합니다.
3. **스레드 생성 및 관리**: 스레드의 생성과 종료를 관리하며, 스레드가 오류로 중단되었을 때 이를 복구하고 다시 시작할 수 있는 메커니즘을 갖추어야 합니다.
4. **자원 할당**: 스레드에 고르게 작업이 할당되도록 관리하는 것이 중요합니다.
5. **오류 처리**: 스레드가 실행 중에 발생할 수 있는 예외 상황을 처리할 수 있어야 합니다.

### **스레드풀의 핵심 구성 요소**

1. **스레드풀 매니저**: 스레드풀을 생성, 관리하고 작업 요청에 따라 스레드에 작업을 할당합니다.
2. **작업 큐(Work Queue)**: 작업을 임시 저장하고 스레드풀 스레드에 할당될 준비를 하는 큐입니다.
3. **Worker 스레드**: 실제로 작업을 수행하는 스레드들입니다. 이들은 작업 큐에서 작업을 가져와 처리합니다.

### **스레드풀 동작 방식**

스레드풀의 기본 동작 방식은 다음과 같습니다:

1. **스레드풀 초기화**: 애플리케이션이 시작할 때, 지정된 수의 스레드가 스레드풀에 의해 생성됩니다. 이 스레드들은 시작되고 난 후 작업을 기다리는 상태로 전환됩니다.
2. **작업 요청 처리**:
    - 애플리케이션이나 사용자로부터 작업 요청이 들어오면, 해당 요청은 작업 큐에 추가됩니다.
    - 작업 큐는 FIFO(First In First Out) 방식으로 작업을 관리합니다. 즉, 먼저 들어온 작업이 먼저 처리됩니다.
3. **작업 실행**:
    - 스레드풀의 각 스레드는 작업 큐에서 대기 중인 작업을 가져와 실행합니다.
    - 스레드가 작업을 처리하는 동안, 다른 스레드들은 계속해서 큐에서 작업을 가져와 처리할 수 있습니다.
    - 스레드가 작업을 완료하면 결과를 반환하고, 다시 작업 큐에서 새로운 작업을 가져와 처리를 계속합니다.
4. **스레드풀 종료**:
    - 애플리케이션이 종료되거나 명시적으로 스레드풀을 종료할 필요가 있을 때, 스레드풀 매니저는 모든 스레드에게 종료 신호를 보냅니다.
    - 각 스레드는 현재 진행 중인 작업을 완료한 후 종료됩니다.
    - 모든 스레드가 종료되면, 스레드풀 자체도 완전히 종료됩니다.


이때 스레드가 할당 받을 작업이 없으면 요청이 들어올 때 가지 계속 대기한다. 반대로 모든 스레드가 작업중이고 큐에 작업이 존재할 경우 스레드를 추가 생성한다. 일반적으로 스레드생성 개수는 기본 개수의 최대 개수로 제한을 한다.
### **스레드풀 예제 (Java)**

Java에서는 **`ExecutorService`** 인터페이스를 통해 스레드풀을 쉽게 구현할 수 있습니다. 다음은 `ExecutorService`를 사용하여 스레드풀을 생성하고 간단한 작업을 여러 스레드에 할당하는 예제입니다.

```java
public class SimpleThreadPool {
    private int numThreads;
    private Queue<Runnable> taskQueue;
    private Thread[] threads;
    private volatile boolean isShutdown;

    public SimpleThreadPool(int numThreads) {
        this.numThreads = numThreads;
        this.taskQueue = new LinkedList<>();
        this.threads = new Thread[numThreads];
        isShutdown = false;

        for (int i = 0; i < numThreads; i++) {
            threads[i] = new WorkerThread();
            threads[i].start();
        }
    }

    public void submit(Runnable task) {
        if (!isShutdown) {
            synchronized (taskQueue) {
                taskQueue.offer(task);
                taskQueue.notifyAll();
            }
        }
    }

    public void shutDown() {
        isShutdown = true;
        synchronized (taskQueue) {
            taskQueue.notifyAll();
        }
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    private class WorkerThread extends Thread {
        @Override
        public void run() {
            while (!isShutdown) {
                Runnable task;
                synchronized (taskQueue) {
                    while (taskQueue.isEmpty() && !isShutdown) {
                        try {
                            taskQueue.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
                if (taskQueue.isEmpty()) {
                    continue;
                }
                task  = taskQueue.poll();
                task.run();
            }

        }
    }
}


```

이 예제에서 `Executors.newFixedThreadPool(4)`는 4개의 스레드를 가진 풀을 생성합니다. **`executor.submit()`** 메소드는 작업을 스레드풀의 작업 큐에 추가합니다. 모든 작업이 추가된 후, **`executor.shutdown()`** 메소드를 호출하여 스레드풀을 안전하게 종료합니다.

스레드풀을 사용하면 많은 멀티스레딩 문제를 보다 쉽게 관리할 수 있으며, 시스템 리소스를 효과적으로 활용할 수 있습니다.

## Executor
java의 Executor Framework는 스레드 관리와 작업 실행을 위한 강력한 툴셋을 제공합니다.

이 프레임워크는 개발자가 멀티스레딩 관련 복잡성을 쉽게 처리할 수 있도록 설계되었으며, 스레드 생성과 생명 주기 관리, 작업 큐잉 및 실행 등을 추상화하여 다룹니다.

### **Executor Framework의 주요 인터페이스**

1. **Executor**: 가장 기본적인 인터페이스로, **`execute(Runnable command)`** 메소드를 통해 새로운 태스크를 실행합니다.
2. **ExecutorService**: **`Executor`**를 확장한 인터페이스로, 라이프사이클 메소드(**`shutdown()`**, **`shutdownNow()`**)를 포함하여 태스크를 보다 세밀하게 관리할 수 있습니다. 비동기 태스크 실행 결과를 나타내는 **`Future`** 객체를 반환하는 **`submit()`** 메소드도 제공합니다.
3. **ScheduledExecutorService**: `ExecutorService`를 확장하여 지정된 지연 시간이나 주기적으로 태스크를 실행할 수 있습니다. **`schedule()`**, **`scheduleAtFixedRate()`**, **`scheduleWithFixedDelay()`** 등의 메소드를 제공합니다.
4. **ThreadPoolExecutor**: `ExecutorService`를 구현하며, 스레드 풀의 생성과 관리를 담당합니다. 워커 스레드 수, 최대 스레드 수, 유휴 스레드의 생존 시간, 작업 큐 등을 설정할 수 있습니다.
5. **ForkJoinPool**: 대규모 태스크를 작은 부분으로 나누고, 이 결과를 재귀적으로 결합하는 특별한 목적의 `ExecutorService`입니다. 병렬 프로그래밍을 효율적으로 수행할 수 있도록 설계되었습니다.

### **Executor**

**`Executor`** 인터페이스는 단 하나의 메소드를 정의합니다:

```java

void execute(Runnable command);

```

여기서 `Runnable`은 실행할 작업을 정의하는 인터페이스입니다. **`Runnable`** 객체는 **`run()`** 메소드를 통해 실행할 수 있는 작업을 포함합니다. 이때  Runnable 명령은 Executor 구현 방식에 따라 새 스레드, 풀 스레드 또는 호출 스레드에서 실행 될 수 있다.

즉, 전달된(Submit) Runnable 작업을 실행(Execute)하는 객체이다.

### **사용 방법**

**`Executor`** 인터페이스를 사용하는 기본적인 방법은 **`execute`** 메소드에 **`Runnable`** 객체를 전달하여 비동기적으로 실행하는 것입니다. `Executor`는 이 `Runnable`을 받아 스레드 풀에 있는 스레드나 새로운 스레드에서 실행합니다.

### **예제**

```java
public static void main(String[] args) {
    Executor executor = Executors.newSingleThreadExecutor();
    executor.execute(() -> {
        System.out.println("Running in " + Thread.currentThread().getName());
    });
}

```

직접 스레드를 생성하고 실행하는 것이 아니라 특정 Runnable을 전달하면 스레드 생성과 실행을 해당 Executor에서 처리하여 좀 더 유연하게 로직을 처리할 수 있다.

### **Executor의 한계**

- **결과 반환 불가**: `Runnable`은 반환 값이 없으므로, 작업의 결과를 직접 처리하거나 다른 방법으로 전달해야 합니다.
- **작업 제어 부족**: 작업을 시작한 후에는 그 작업을 중지하거나 그 상태를 확인하는 방법이 없습니다.
- **작업 완료 처리**: 작업이 완료된 후에 특정 행동을 실행하도록 설정하는 것이 어렵습니다.
- **예외 처리**: 작업 실행 중 발생한 예외를 적절히 관리하거나 추적하기 어렵습니다.

Java의 **`Executor`** 인터페이스는 작업을 비동기적으로 실행하는 매우 간단한 방법을 제공하지만, 작업 관리와 관련된 기능은 제한적입니다. **`Executor`** 인터페이스는 단순히 **`Runnable`** 작업을 실행할 수 있게 해주며, 작업 실행 완료 상태, 결과 반환, 실행 취소, 실행 완료 후 처리 등에 대한 어떠한 메커니즘도 제공하지 않습니다. 이러한 기능들은 복잡한 멀티스레드 애플리케이션에서 중요할 수 있습니다.

### **ExecutorService 인터페이스**

`ExecutorService`는 `Executor`의 한계를 극복하기 위해 설계된 더 강력한 인터페이스입니다. `ExecutorService`는 `Executor`를 상속받아, 스레드 **풀 관리와 작업 실행의 라이프사이클을 포괄적으로 제어**할 수 있는 메소드를 추가합니다. 주요 기능은 다음과 같습니다.

1. **작업 실행 결과 반환**: **`submit()`** 메소드를 사용하면, **`Callable`** 또는 **`Runnable`** 작업을 제출하고, **`Future`** 객체를 반환받을 수 있습니다. `Future`를 통해 작업의 결과를 얻거나, 작업이 완료되었는지 확인하고, 작업을 취소할 수 있습니다.
2. **라이프사이클 관리**: `shutdown()`과 **`shutdownNow()`** 메소드를 통해 스레드 풀을 단계적으로 종료하거나 즉시 종료할 수 있습니다. `shutdown()`은 모든 작업이 완료되면 스레드 풀을 종료하고, `shutdownNow()`는 현재 대기 중인 작업을 취소하고 스레드 풀을 즉시 종료합니다.
3. **작업 완료 대기**: **`awaitTermination()`** 메소드를 사용하여 스레드 풀이 완전히 종료될 때까지 기다릴 수 있습니다.
4. **작업 일괄 처리**: `invokeAll()`과 **`invokeAny()`** 메소드를 사용하여 작업 목록을 일괄적으로 실행하고, 모든 작업이 완료되기를 기다리거나, 첫 번째로 완료된 작업의 결과를 받을 수 있습니다.

### **예제: ExecutorService 사용**

```java
import java.util.concurrent.*;

public class ExecutorServiceExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        Callable<String> task = () -> {
            TimeUnit.SECONDS.sleep(2);
            return "Result of Task";
        };

        Future<String> future = executor.submit(task);

        try {
            // 작업의 결과를 기다린다, 최대 1분
            String result = future.get(1, TimeUnit.MINUTES);
            System.out.println(result);
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            e.printStackTrace();
        }

        executor.shutdown();
    }
}

```

이 예제에서는 `ExecutorService`를 사용하여 작업을 제출하고, `Future`를 통해 작업 결과를 받습니다. `submit()`은 작업 실행을 위임하고, `get()`은 실행 결과를 대기합니다.

`ExecutorService`는 고급 스레드 관리와 작업 실행 기능을 제공하여, Java에서 복잡한 멀티스레드 프로그램을 효율적으로 구현할 수 있도록 지원합니다.

### **주의사항 및 이점**

Executor Framework 사용시 주의해야 할 점은 다음과 같습니다:

- 스레드 풀을 적절히 종료하지 않으면 애플리케이션이 종료되지 않는 문제가 발생할 수 있습니다. 작업이 완료된 후에는 반드시 **`shutdown()`** 또는 `shutdownNow()`를 호출해야 합니다.
- 리소스를 과도하게 사용하지 않도록 적절한 스레드 풀 크기를 설정해야 합니다.

Executor Framework의 이점은 다음과 같습니다:

- 스레드 관리의 복잡성이 감소합니다.
- 자원 사용이 최적화되고 성능이 향상됩니다.
- 코드의 가독성과 유지보수성이 향상됩니다.

## Runnable 과 Callable

## **@Functional Interface**

Java에서 Functional Interface는 람다 표현식의 대상이 되는 인터페이스로, 오직 하나의 추상 메소드를 가집니다. 이러한 특성 때문에 종종 Single Abstract Method (SAM) 인터페이스라고도 불립니다.

Java 8 이후로 함수형 프로그래밍 패러다임을 지원하기 위해 도입되었으며, **`@FunctionalInterface`** 어노테이션을 사용하여 명시적으로 선언됩니다. 이 어노테이션은 인터페이스가 함수형 인터페이스의 요구 사항을 충족하는지 컴파일 시점에 검사하는 데 사용됩니다.


함수형 인터페이스는 일반적으로 간결하고 특정한 연산을 수행하는 작은 코드 조각을 구현하는 데 사용됩니다. 이들은 종종 고차 함수(higher-order functions)의 인자로 사용되거나 결과로 반환됩니다.

예를 들어, 자바 API에는 여러 내장 함수형 인터페이스가 있으며,  가장 대표적인 것은 **`Consumer`**, **`Supplier`**, **`Function`** 및 **`Predicate`** 등이 있습니다.

## Runnable 과  Callable

Java에서 `Runnable`과 **`Callable`** 인터페이스는 스레드 또는 스레드 풀에서 실행할 수 있는 태스크를 정의하기 위해 사용됩니다. 두 인터페이스 모두 병렬 처리나 비동기 작업에 사용되며,

`ExecutorService`와 같은 고급 스레드 관리 도구와 함께 사용되곤 합니다.

### **Runnable 인터페이스**

**`Runnable`** 인터페이스는 다음과 같이 정의됩니다:

```java
@FunctionalInterface
public interface Runnable {
    // 결과를 리턴 하거나 예외를 던질 수 없다.
    void run();
}

```

- **메소드 `run()`**: 이 메소드는 반환 값이 없으며 (**`void`**), 예외를 던지지 않습니다. 실제로 작업을 수행하는 로직을 포함하며, 작업이 완료되면 메소드가 종료됩니다.

### 사용 예시

**Runnable 사용 예시:**

```java
public static void main(String[] args) {
    Runnable runnable = () -> System.out.println("Runnable is running");
    Thread thread = new Thread(runnable);
    thread.start();
}

```

### **Callable 인터페이스**

java에서 **`Callable`** 인터페이스는 실행할 작업을 나타내며, **`Runnable`** 인터페이스와 유사하지만 몇 가지 중요한 차이가 있습니다.

`Callable`은 결과를 반환하고, `작업 수행 중 발생할 수 있는 예외를 처리할 수 있습니다.` 이러한 특징은 `Callable`을 통해 보다 복잡한 연산을 수행하고 그 결과를 외부에서 활용할 수 있게 해줍니다.

**`Callable`** 인터페이스는 다음과 같이 정의됩니다:

```java
@FunctionalInterface
public interface Callable<V> {
    // 결과를 리턴 하거나 예외를 던질 수 있다.
    V call() throws Exception;
}

```

- **메소드 `call()`**: 이 메소드는 작업의 실행 결과를 반환하는 **`V`** 타입의 값을 리턴합니다. 또한, 작업 중 발생할 수 있는 예외를 던질 수 있습니다 (**`throws Exception`**).

### **Future 인터페이스**

**`Future`** 인터페이스는 **비동기 연산의 결과**를 나타냅니다. **`Callable`** 태스크가 실행되면, `ExecutorService`는 즉시 **`Future`** 객체를 반환하고, 태스크는 비동기적으로 수행됩니다. `Future`는 연산이 완료될 때까지 기다렸다가 결과를 검색하거나, 연산이 완료되었는지 여부를 확인하거나, 연산을 취소할 수 있는 방법을 제공합니다.

**주요 메소드**:

- **`boolean cancel(boolean mayInterruptIfRunning)`**: 작업이 완료되기 전에 작업을 취소하려고 시도합니다.
- **`boolean isCancelled()`**: 작업이 취소되었는지 여부를 반환합니다.
- **`boolean isDone()`**: 작업이 완료되었는지 여부를 반환합니다.
- **`V get()`**: 작업이 완료될 때까지 대기한 후 결과를 반환합니다.
- **`V get(long timeout, TimeUnit unit)`**: 작업이 완료되거나 지정된 시간이 지나거나 현재 스레드가 인터럽트되면 작업 결과 또는 예외를 반환합니다.

### **사용 예시**

**Callable & Future 사용 예시**:

```java
import java.util.concurrent.*;

public class CallableFutureExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {
        ExecutorService executor = Executors.newFixedThreadPool(1);

        Callable<Integer> callable = () -> {
            TimeUnit.SECONDS.sleep(2); // 시뮬레이션을 위한 2초 지연
            return 123;
        };

        Future<Integer> future = executor.submit(callable);

        // 미래 결과를 가져옵니다. 필요하다면 이 시점에서 작업 완료를 기다립니다.
        Integer result = future.get();  // 작업이 완료될 때까지 블록됩니다.
        System.out.println("Result: " + result);

        executor.shutdown();
    }
}

```

이 예제에서는 **`Callable`** 태스크를 `ExecutorService`에 제출하고, 결과를 **`Future`** 객체를 통해 얻습니다. **`get()`** 메소드는 필요한 경우 작업이 완료될 때까지 현재 스레드를 차단하며, 작업 결과를 반환합니다.

### **주요 용도**

- **비동기 계산**: `Callable`과 `Future`는 계산 결과를 나중에 필요할 때 사용할 수 있도록 하며, 메인 스레드가 다른 작업을 계속 처리할 수 있도록 합니다.
- **시간이 많이 걸리는 작업 관리**: 긴 작업을 비동기적으로 실행하고, 결과가 준비되면 알림을 받거나 결과를 검색할 수 있습니다.
- **멀티스레드 환경에서의 예외 처리**: `Callable`은 `Exception`을 던질 수 있어, 멀티스레드 환경에서 예외를 적절하게 처리할 수 있습니다.

### **Runnable과 Callable의 차이점**

다음은 `Runnable`과 `Callable`의 주요 차이점을 정리한 표입니다:

| 특성 | Runnable | Callable |
| --- | --- | --- |
| 반환 값 | 반환 값 없음 (void) | 반환 값 있음 (V) |
| 예외 처리 | 예외를 선언적으로 던지지 않음 | 선언적으로 예외를 던질 수 있음 (throws Exception) |
| 메소드 | run() | call() |
| 사용 시나리오 | 단순한 작업을 실행하고 결과를 반환할 필요가 없는 경우 | 결과를 반환하거나 예외 처리가 필요한 경우 |
| 기능적 인터페이스 | @FunctionalInterface | @FunctionalInterface |


## Future 과 Callback

### Future

앞서 설명을 했지만 **`Future`** 인터페이스는 비동기 작업의 결과를 나타내는데 사용됩니다. `Future`는 작업이 완료되기를 기다리고, 완료되면 결과를 가져오거나, 작업 실행 중에 발생할 수 있는 예외를 처리할 수 있게 해줍니다.

**사용 시나리오**:

- 결과를 기다리면서 다른 작업을 동시에 수행할 수 있도록 비동기 작업을 관리하고 싶을 때 사용됩니다.
- 긴 작업을 서브 스레드에서 실행시키고, 그 결과를 메인 스레드에서 활용하고자 할 때 유용합니다.

### **Callback**

Callback은 비동기 프로그래밍에서 사용되는 기술로, 특정 코드 블록(함수 또는 메소드)이 작업 완료 시 호출됩니다. Callback을 사용하면 비동기 작업이 완료될 때 수행할 작업을 지정할 수 있으며, 이는 작업의 결과를 처리하거나 다음 작업을 연쇄적으로 시작하는 데 사용됩니다.

> **Callback의 개념**
> Callback은 프로그래밍에서 사용되는 중요한 개념으로, **특정 작업이나 이벤트가 완료될 때 실행될 함수나 코드 블록을 의미**합니다.

Callback을 사용하는 주된 이유는 **비동기 작업을 처리**하고, **결과나 상태 변경에 대응하는 코드를 구성**하기 위해서입니다. Callback은 프로그램의 흐름을 비동기적으로 만들어, 주 스레드가 멈추지 않고 다른 작업을 계속 수행할 수 있게 합니다.
>
>
>
> **Callback의 기본 원리**
>
> Callback은 함수를 다른 함수의 인자로 전달하는 방식으로 사용됩니다. 이렇게 전달된 함수는 외부의 이벤트 처리나 비동기 요청의 결과 등을 처리하는 데 호출됩니다. 이러한 방식은 주로 이벤트 리스너, 시간 초과, 네트워크 요청, 파일 입출력 등과 같이 비동기적으로 발생하는 다양한 시스템 이벤트나 상태에서 유용합니다.
>

**구현 방식**:

- Java에서는 직접적으로 Callback 인터페이스가 존재하지 않으나, 개발자가 인터페이스를 정의하여 사용할 수 있습니다.
- 일반적으로는 인터페이스를 정의하고, 해당 인터페이스의 메소드를 구현하여 비동기 작업이 완료되었을 때 호출되게 합니다.

**예제**:

```java

interface Callback {
    void onComplete(String result);
    void onError(Exception e);
}

public class AsyncService {
    public void doWork(Callback callback) {
        new Thread(() -> {
            try {
                // 시간이 많이 걸리는 작업 수행
                String result = "Completed";
                callback.onComplete(result);
            } catch (Exception e) {
                callback.onError(e);
            }
        }).start();
    }
}

```

- 비동기 작업의 결과를 특정 시점에 처리하고 싶을 때, 또는 여러 단계의 비동기 작업을 연결하고 싶을 때 사용됩니다.
- 네트워크 요청, 파일 I/O, 긴 계산 작업 완료 후 UI 업데이트 등의 상황에서 활용됩니다.

### 차이점

| 특징 | Future | Callback |
| --- | --- | --- |
| 작업 완료의 확인 | 작업 완료를 명시적으로 확인해야 함 (isDone()) | 작업 완료 시 자동으로 함수가 호출됨 |
| 결과 처리 | get() 메소드를 통해 결과를 동기적으로 검색 | 작업 완료 시 호출되는 함수를 통해 결과를 비동기적으로 처리 |
| 작업 중단 | 작업을 취소할 수 있는 기능 제공 (cancel()) | 일반적으로 취소 메커니즘이 명시적으로 제공되지 않음 |
| 오류 처리 | get() 호출 시 발생한 예외를 ExecutionException으로 캡처 | onError 메소드 등을 통해 예외를 직접 처리 |
| 응답성 | 작업 완료를 기다리는 동안 블로킹 될 수 있음 | 비동기적으로 이벤트 처리, 논블로킹 |
| 용도 | 결과가 필요한 경우, 결과를 기다리는 동안 다른 작업 수행 가능 | 비동기 흐름 제어, 여러 단계의 비동기 작업을 연결할 때 유리 |

### 두 패턴이 필요한 이유
- 비동기 작업에서 스레드 간 결과를 받을 방법이 필요하다.
- 비동기 작업은 스레드 간 **실행의 흐름이 독립적**이기 때문에 비동기 작업의 완료 시점에 결과를 얻을 수 있어야 한다.

### **Future의 구조**
자바에서 Future는 비동기 작업의 결과를 가져올 수 있도록 도와주는 인터페이스이다. 비동기 작업이 완료되었는지 여부를 확인하고 조건에 따라 작업취소 또는 작업의 결과를 얻을 수 있다.

작업의 결과를 가져올 때까지는 블로킹되며 여러 작업을 조합하는 문제, 예외처리 등의 어려움이 존재하지만 **자바 8부터는 CompletedFuture** 와 같은 개선된 비동기 도구를 제공한다.


**`Future`** 인터페이스는 다음과 같은 주요 메소드를 제공합니다:

1. **boolean cancel(boolean mayInterruptIfRunning)**
    - 이 메소드는 실행 중인 작업을 취소하려고 시도합니다. **`mayInterruptIfRunning`** 파라미터가 `true`이면 진행 중인 스레드를 중단시킬 수 있습니다.(작업결과를 가져올때 취소 예외가 발생) 작업이 취소되면 `true`를, 그렇지 않으면 `false`를 반환합니다.
    - **`mayInterruptIfRunning`** 파라미터가 `false`이면 진행중인 작업을 완료할 수 있습니다. 단, 작업결과를 가져올때 취소 예외가 발생합니다.
2. **boolean isCancelled()**
    - 작업이 취소되었는지 여부를 반환합니다. 작업이 취소되었다면 `true`를 반환합니다.
3. **boolean isDone()**
    - 작업이 완료되었는지 여부를 확인합니다. 작업이 완료되었거나 예외가 발생했거나, 작업이 취소되었으면 `true`를 반환합니다.
4. **V get()**
    - 계산된 결과를 반환받습니다. 결과가 준비될 때까지 호출 스레드가 블록됩니다.
    - 예외발생:CancellationException(작업이 취소된 경우) , ExecutionException(작업이 예외를 발생시킨 경우) , InterruptedException(현재 스레드가 대기중에 인터럽트 된 경우)
5. **V get(long timeout, TimeUnit unit)**
    - 지정된 시간 내에 결과를 반환받습니다. 지정된 시간이 초과되면 `TimeoutException`을 던집니다.

### 흐름도
```plaintext
┌────────────┐
│   Client   │
└────────────┘
      │
      ▼
┌────────────┐
│  Executor  │
│ (ThreadPool)│
└────────────┘
      │
      ▼
┌──────────────────────┐
│    Callable/         │
│  Runnable Task       │
└──────────────────────┘
      │
      ▼
┌──────────────────────┐
│      Thread          │
│(from ThreadPool)     │
└──────────────────────┘
      │
      ▼
┌─────────────────────────┐
│      Future Object      │
│(Holds result or error)  │
└─────────────────────────┘
      │
      ▼
┌──────────────────────────┐
│      Future.get()        │
│(Blocks if not completed) │
└──────────────────────────┘
      │
      ▼
┌──────────────────────────┐
│      Result or Error     │
└──────────────────────────┘
```

### **원리**

`Future`는 다음과 같은 원리로 동작합니다:

- **작업 제출**: `ExecutorService`를 통해 **`Callable`** 또는 **`Runnable`** 작업이 제출됩니다. 이때 `ExecutorService`는 작업을 수행할 스레드에 할당하고, 해당 작업을 나타내는 **`Future`** 객체를 반환합니다.
- **작업 실행**: 작업은 별도의 스레드에서 비동기적으로 실행됩니다. 이 실행은 `ExecutorService`에 의해 관리되는 스레드 풀 내에서 이루어질 수 있습니다.
- **결과 대기 및 검색**: **`Future.get()`** 메소드를 호출하여 작업 결과를 검색할 수 있습니다. 이 메소드는 결과가 준비될 때까지 호출 스레드를 블록합니다. 결과가 이미 준비되어 있으면 즉시 반환됩니다.
- **작업 취소**: **`Future.cancel()`** 메소드를 통해 실행 중이거나 대기 중인 작업을 취소할 수 있습니다. 작업이 성공적으로 취소되면 더 이상 해당 작업의 결과를 검색할 수 없습니다.

### **사용 예제**

```java
public static void main(String[] args) {
    ExecutorService executor = Executors.newCachedThreadPool();
    Callable<String> task = () -> {
        TimeUnit.SECONDS.sleep(2); // 시뮬레이션을 위한 지연
        return "Result of Task";
    };
    Future<String> future = executor.submit(task); // 비동기

    try {
        String result = future.get(3, TimeUnit.SECONDS); // 3초 안에 결과를 기다립니다.
        System.out.println("Task completed: " + result);
    } catch (TimeoutException e) {
        System.err.println("Task did not complete within the time limit.");
    } catch (InterruptedException | ExecutionException e) {
        System.err.println("Task encountered an error: " + e.getMessage());
    } finally {
        executor.shutdown();
    }
}

```

이 예제에서는 `Callable`을 통해 반환값이 있는 작업을 `ExecutorService`에 제출하고, `Future`를 사용하여 결과를 비동기적으로 검색합니다.

**`get()`** 메소드를 사용하여 작업 완료를 최대 3초까지 기다리고, 그 시간 안에 작업이 완료되면 결과를 출력합니다. 이때 결과값이 `Future`에 전달되지 않았다면 내부적으로 **wait()** 을 통해 결과값을 얻기까지 메인 스레드가 대기한다.(결과 값이 전달 되면 **notify()** 호출해서 메인 스레드를 깨움)

`Future`는 Java에서 비동기 작업을 관리하고 결과를 효율적으로 처리하는 강력한 메커니즘을 제공합니다.

### FutureTask의 주요 특징
FutureTask는 Future와 Runnable을 구현하는 클래스입니다. 이는 비동기 작업을 수행하고 그 결과를 저장하는 데 사용됩니다.

FutureTask는 비동기 작업을 관리하는 데 유용하며, 이를 통해 작업의 상태를 추적하고, 작업이 완료되었는지 여부를 확인하고, 작업 결과를 가져오거나 취소할 수 있습니다.
```java
public static void main(String[] args) {
    // Callable을 사용하여 비동기 작업 정의
    Callable<String> callableTask = () -> {
        Thread.sleep(2000);
        return "Hello from Callable!";
    };

    // FutureTask를 사용하여 Callable 감싸기
    FutureTask<String> futureTask = new FutureTask<>(callableTask);

    // ExecutorService를 사용하여 FutureTask 실행
    ExecutorService executorService = Executors.newSingleThreadExecutor();
    executorService.execute(futureTask);

    // FutureTask 결과 가져오기
    try {
        System.out.println("FutureTask 결과: " + futureTask.get());
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    } finally {
        executorService.shutdown();
    }
}  
```
- Runnable 및 Callable 인터페이스 구현:
    - FutureTask는 Runnable 인터페이스와 Callable 인터페이스를 모두 구현합니다. 따라서 실행 가능한 작업을 표현할 수 있으며, 비동기적으로 결과를 반환할 수 있습니다.
- 작업의 상태 관리:
    - FutureTask는 작업의 상태를 관리합니다. 작업이 실행되었는지, 완료되었는지, 취소되었는지 등의 상태를 추적할 수 있습니다.
    - ```java
      private volatile int state; // 작업 상태 변수
      private static final int NEW          = 0; //작업 시작
      private static final int COMPLETING   = 1; // 작업 진행 중
      private static final int NORMAL       = 2; // 작업 완료
      private static final int EXCEPTIONAL  = 3; // 예외 발생
      private static final int CANCELLED    = 4; // 작업 취소
      private static final int INTERRUPTING = 5; // 인트럽트 중
      private static final int INTERRUPTED  = 6; // 인트럽트 됨
    - 상태 변화
        - 정상 완료 : NEW > COMPLETING
        - 예외 발생 : NEW > COMPLETING > EXCEPTIONAL
        - 작업 취소 : NEW > COMPLETING > INTERRUPTED // 작업 취소 인자 true
        - 작업 취소 : NEW > CANCELLED // 작업 취소 인자 false
- 결과 저장:
    - 작업이 완료되면 그 결과를 저장하고, 필요할 때 이 결과를 가져올 수 있습니다.
- 동기화 메커니즘:
    - FutureTask는 동기화 메커니즘을 사용하여 여러 스레드에서 안전하게 결과를 가져오거나 작업을 취소할 수 있습니다.

### 내부 구조
FutureTask의 내부 구조는 다음과 같습니다:

- state:
    - 작업의 현재 상태를 나타내는 내부 변수입니다. 작업이 실행 중인지, 완료되었는지, 취소되었는지를 추적합니다.
- callable:
    - 실행할 실제 작업(Callable 또는 Runnable)을 감싸는 내부 변수입니다.
- outcome:
    - 작업의 결과 또는 예외를 저장하는 내부 변수입니다.
- runner:
    - 작업을 실행하는 스레드를 나타내는 내부 변수입니다.

FutureTask는 비동기 작업의 실행과 결과 관리를 위한 강력한 도구로, 여러 스레드에서 작업을 안전하게 관리할 수 있도록 합니다. 이를 통해 복잡한 비동기 작업을 보다 쉽게 처리할 수 있습니다.

```java
   public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(1);

        Callable<Integer> callable = () -> {
            System.out.println("비동기 작업 시작..");
            Thread.sleep(2000);
            System.out.println("비동기 작업 종료..");

            return 30;
        };

        Future<Integer> future = executorService.submit(callable);
        

        try {
            Integer result = future.get();
            System.out.println("result = " + result);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }finally {
            executorService.shutdown();
        }
    }
```
위 코드는 어떻게 동작 하는지 알아보자
```java
executorService.submit(callable);
```
이 코드 내부로 타고 가보면 `AbstractExecutorService` 클레스 안에 submit 메서드를 호출하게 된다.
```java

    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task); 
        execute(ftask);
        return ftask;
    }
```
이 코드를 확인 해보면 `newTaskFor(task)` 메서드의 진자로 Callabe task 값을 전달해주고 return 값으로 RunnableFuture 인터페이스를 반환 받는 것을 확인할 수 있다.  
newTaskFor:  FutureTask 객체를 return 한다.
```java
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        return new FutureTask<T>(callable);
    }
```
앞에서 확인 했듯이 FutureTask 객체는 내부적으로 상태값을 가지고 실행을 제어한다.  
이렇게 생성된 FutureTask 객체를 `execute(ftask)` 메서드에 전달하고 바로 FutureTask를 return 하게된다.  
이때 RunnableFuture 인터페이스는  Runnable, Future<V> 를 상속 받는 인터페이스임을 확인할 수 있다.
```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```  
이렇게 바로 return 한 FutureTask 객체를 우리는 비동기적으로 받아 작업을 처리하게 된다.  
비동기 작업을 처리하는 `execute` 메서드는 `Executor` 인터페이스를 상속 받아 구현하게 되어있고 우리는 앞에서
```java
Executors.newFixedThreadPool(1);
```
Executors 의 newFixedThreadPool 메서드를 통해 ExecutorService 를 return 받았다.
```
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```
`ThreadPoolExecutor` 클레스에 들어가 execute 메서드의 구현체를 확인해 보자
```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }

```
여기서 `addWorker` 메서드 에서 우리가 전달한 Runnable task 값을 비동기적으로 Worker라는 클레스를 생성하면서 새로운 스레드를 생성하게된다.(스레드풀에서
```java
// addWorker 내부 로직 중 일부
boolean workerStarted = false;
boolean workerAdded = false;
Worker w = null;
        try {
w = new Worker(firstTask);
final Thread t = w.thread;
            if (t != null) {
final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
```
이 Worker 클레스는 Runnable 구현한 클레스로 생성자로 futureTask 를 받고 있다.
```java
    private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }
    }
```
이렇게 비동기적으로 FutureTask 객체를 return 한다음에 main 스레드가 아닌 스레드 풀에서 생성한 스레드가 비동기 적으로 Worker 클레스의 run 메서드를 호출한다.  
![img.png](src/resources/static/img/img.png)
```java
     public void run() {
            runWorker(this);
        }
```  
```java
final void runWorker(Worker w) {
    ...
    task.run(); // Worker 클레스 안에 있는 futureTask
}
```
runWorker 에서 실행한 run 메서드는 결국 FutureTask 안에 있는 run 메서드를 호출하므로(우리가 전달한 구현체가 FutureTask)
```java
public void run() {
        if (state != NEW ||
            !RUNNER.compareAndSet(this, null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }
```
FutureTask 클레스는 내부적으로 상태값을 가지고 task를 제어한다.  
정상적으로 로직을 마무리하게 되면 **set** 메서드를 통해서 상태값을 NEW 에서 COMPLETING 로 변경하고 outcome 에 결과값을 전달하고 상태값을 NORAML 변경한다.
```java
    protected void set(V v) {
        if (STATE.compareAndSet(this, NEW, COMPLETING)) {
            outcome = v;
            STATE.setRelease(this, NORMAL); // final state
            finishCompletion();
        }
    }
```  
이렇게 비동기 작업을 수행하고 마지막으로 get 메서드를 호출하게 되면
```java
    public V get() throws InterruptedException, ExecutionException {
        int s = state;
        if (s <= COMPLETING)
            s = awaitDone(false, 0L); // 값을 전달 받을때 까지 대기
        return report(s);
    }
```
내부 상태값을 확인하고 완료되지 않았다면 완료까지 대기했다가 그값을 return 하게 된다.

## 스레드 풀 실행 및 관리 ExecutorService
### 실행을 제어하는 2가지 메서드
비동기 작업을 실행하고 관리하기 위한 두가지 메서드를 제공
- void execute(Runnable r) : 작업 제출하면 작업을 **실행하고 종료**
- Future submit(Callable c) : 작업을 제출하면 **실행함과 동시에 Future 반환**(결과값을 포함하고 있음).

| 특징 | submit() | execute() |
| --- | --- | --- |
| 반환 타입 | Future 객체 | void |
| 예외 처리 | 호출한 스레드에서 예외 발생 | 실행된 스레드에서 예외 발생 |
| 반환 값 | 작업의 결과 또는 예외가 포함된 Future 반환 | 반환 값 없음 |
| 블로킹 여부 | 비블로킹 | 비블로킹 |
| 사용 용도 | 결과를 반환하거나 예외를 처리할 필요가 있는 작업 | 결과가 필요 없고 예외를 별도로 처리하지 않는 작업 |

다음은 `submit`과 `execute` 메서드를 사용하는 기본 구현 코드입니다.

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ExecutorServiceExample {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        // submit 사용 예제
        Callable<String> callableTask = () -> {
            Thread.sleep(1000);
            return "Callable Task's Result";
        };
        Future<String> future = executorService.submit(callableTask);
        try {
            String result = future.get(); // 결과를 기다림
            System.out.println("submit 결과: " + result);
        } catch (Exception e) {
            e.printStackTrace();
        }

        // execute 사용 예제
        Runnable runnableTask = () -> {
            try {
                Thread.sleep(1000);
                System.out.println("Runnable Task 실행 완료");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };
        executorService.execute(runnableTask);

        executorService.shutdown();
    }
}

```

### **스레드 풀 중단 및 종료 방법**

### **1. `shutdown()`**

**`shutdown()`** 메소드는 스레드 풀의 새로운 작업 수락을 중단하고, 이미 제출된 모든 작업이 완료된 후에 스레드 풀의 스레드들을 종료합니다. 이 메소드는 즉시 반환되며, 작업이 실제로 완료되는 것을 기다리지 않습니다. 실행중인 스레드를 강제로 인터럽트 하지 않기 때문에 InterruptedExetion 예외 구문을 작성할 필요 없다.

- **사용 예제**:

```java
public static void main(String[] args) {
    ExecutorService executor = Executors.newFixedThreadPool(4);
// 여기에 작업 제출
    executor.shutdown();
}

```


### **2. `shutdownNow()`**

**`shutdownNow()`** 메소드는 스레드 풀의 새로운 작업 수락을 즉시 중단하고, 실행 중인 모든 작업을 시도할 수 있는 대로 중단하며, 대기 중인 작업 목록을 반환합니다. 이 메소드는 가능한 한 빨리 스레드 풀을 종료하려고 할 때 사용됩니다. 단, 실행중인 스레드를 강제로 인터럽트 하지만 해당 작업이 인터럽트에 응답하는 작업이 아닌경우 작업 종류를 보장하지 않는다.

- **사용 예제**:

```java
public static void main(String[] args) {
    ExecutorService executor = Executors.newFixedThreadPool(4);
// 여기에 작업 제출
    List<Runnable> notExecutedTasks = executor.shutdownNow();

}
```



### **중단 및 종료 과정의 중요성**

- **리소스 관리**: 열린 스레드를 관리하지 않으면 시스템의 성능에 영향을 줄 수 있습니다. 스레드는 운영 체제 리소스를 사용하므로 적절한 시점에 이를 해제해야 합니다.
- **애플리케이션의 안정성**: 스레드 풀이 제대로 종료되지 않으면 애플리케이션이 완전히 종료되지 않는 문제가 발생할 수 있습니다.
- **데이터 무결성**: 실행 중인 작업이 갑자기 중단되면 예상치 못한 결과를 초래할 수 있으므로, 가능하다면 정상적인 종료를 기다리거나 제어된 방식으로 중단되어야 합니다.

### 주의사항

`ExecutorService`의 **`shutdownNow()`** 메소드를 사용할 때는 여러 가지 주의사항을 고려해야 합니다. 잘못 관리되면 예기치 않은 문제나 데이터 손실이 발생할 수 있습니다.

**1. 작업의 완료성 보장**

- `shutdownNow()`는 스레드에 `Thread.interrupt()`를 호출하여 현재 진행 중인 작업을 중단하려고 시도합니다. 하지만 모든 작업이 인터럽트를 적절히 처리하는 것은 아닙니다. 작업 코드가 인터럽트를 적절히 처리하고 있지 않다면, **`shutdownNow()`** 호출 후에도 작업이 계속 실행될 수 있습니다.
- 중요한 데이터를 처리하는 작업을 강제로 중단할 때는 데이터 일관성과 완전성이 손상될 수 있으므로, 작업이 중단 가능한지와 중단 시 어떤 상태로 남는지를 정확히 이해해야 합니다.

**2. 인터럽트 처리**

- 작업 코드 내에서 `InterruptedException`이 발생했을 때 이를 적절히 처리하는 것이 중요합니다. 인터럽트 예외를 무시하면 스레드가 중지되지 않고 계속 실행될 수 있습니다.
- 작업이 인터럽트를 받았을 때 적절한 정리(clean-up) 작업을 수행하고 안전하게 종료되도록 해야 합니다.

**3. 리소스 누수 방지**

- 작업 중에 열린 파일이나 네트워크 연결 등의 리소스는 작업이 중단되더라도 반드시 정리되어야 합니다. 작업 중단 시 리소스 정리 로직을 실행하지 않으면 리소스 누수가 발생할 수 있습니다.

**4. 응답성 보장**

- `shutdownNow()`는 가능한 한 빨리 스레드 풀을 종료시키려 하므로, 일부 처리가 완료되지 않고 종료될 수 있습니다. 시스템의 응답성을 유지하려면 중단 시점을 신중하게 결정하고, 사용자나 다른 시스템 컴포넌트에 적절한 피드백을 제공해야 합니다.

**5. 예외 처리와 로깅**

- 작업 중단 과정에서 발생할 수 있는 예외를 적절히 처리하고, 필요한 경우 로깅을 통해 문제를 추적할 수 있도록 해야 합니다. 이는 문제 발생 시 빠른 진단과 해결을 돕습니다.

## 종료 상태 확인

**`ExecutorService`** 인터페이스는 작업 실행을 관리하고 스레드 풀을 제어하는 데 사용되는 여러 메소드를 제공합니다.

### 1. **`isShutdown()`**

- **기능**: **`isShutdown()`** 메소드는 `ExecutorService`가 종료(shutdown) 절차를 시작했는지 여부를 확인합니다.
- **반환 값**: 이 메소드는 종료 절차가 시작되면 `true`를, 그렇지 않으면 `false`를 반환합니다.
- **사용 시점**: **`shutdown()`** 또는 **`shutdownNow()`** 메소드가 호출된 후, 서비스가 종료 절차에 들어갔는지 확인할 때 사용합니다.

### **2.`isTerminated()`**

- **기능**: **`isTerminated()`** 메소드는 `ExecutorService`의 종료 절차가 완전히 완료되었는지를 확인합니다.
- **반환 값**: 모든 작업이 완료되고, 연관된 리소스가 정리된 후에 `true`를 반환합니다. 만약 종료 절차가 아직 완료되지 않았다면 `false`를 반환합니다.
- **사용 시점**: **`shutdown()`** 호출 후 모든 작업이 완료되었는지 확인할 때 사용하며, **`awaitTermination()`** 메소드와 함께 종종 사용됩니다.

### 3. **`awaitTermination(long timeout, TimeUnit unit)`**

- **기능**: **`awaitTermination()`** 메소드는 호출하는 스레드가 `ExecutorService`가 완전히 종료될 때까지, 또는 제공된 타임아웃 시간이 경과할 때까지 대기하도록 합니다.
- **반환 값**: 서비스가 종료 절차를 완료하면 `true`를, 타임아웃 시간이 경과하면 `false`를 반환합니다.
- **사용 시점**: 일반적으로 `shutdown()`이나 **`shutdownNow()`** 메소드 호출 후에 사용하여, 모든 작업이 완료되기를 기다릴 때 사용됩니다.


### **사용 예제**

```java
public static void main(String[] args) {
    ExecutorService executor = Executors.newFixedThreadPool(4);

// 작업을 제출합니다.
    executor.execute(() -> {
        try {
            Thread.sleep(2000);
            System.out.println("Task completed");
        } catch (InterruptedException e) {
            System.out.println("Task interrupted");
        }
    });

// 스레드 풀 종료 시작
    executor.shutdown();

// 종료 확인
    if (executor.isShutdown()) {
        System.out.println("Shutdown has been initiated");
    }

    try {
        // 모든 작업이 완료될 때까지 5초간 대기
        if (executor.awaitTermination(5, TimeUnit.SECONDS)) {
            System.out.println("All tasks have finished");
        } else {
            System.out.println("Not all tasks finished before the timeout");
        }
    } catch (InterruptedException e) {
        executor.shutdownNow();
    }

// 최종적으로 스레드 풀이 종료되었는지 확인
    if (executor.isTerminated()) {
        System.out.println("All tasks are terminated");
    } else {
        System.out.println("Some tasks are still running");
    }
}

```

이 예제는 `ExecutorService`의 종료 절차를 시작하고, 종료 여부를 확인하며, 필요한 경우 종료를 기다리는 과정을 보여줍니다. 이러한 메소드들은 서비스의 정상적인 종료와 리소스의 올바른 해제를 보장하는 데 필수적입니다.

## 종료 및 대기 흐름도

1. **작업 제출**
    - `ExecutorService`에 작업을 제출합니다 (예: **`execute`**, **`submit`**).
2. **종료 시작 (`shutdown()`)**
    - **`shutdown()`** 메소드를 호출하여 `ExecutorService`가 새로운 작업을 받지 않도록 합니다.
    - 이미 제출된 작업은 계속 처리됩니다.
3. **상태 확인 (`isShutdown()`)**
    - **`isShutdown()`** 메소드를 사용하여 종료 절차가 시작되었는지 확인합니다.
    - 이 메소드는 종료 절차가 시작되면 **`true`**를 반환합니다.
4. **작업 완료 대기 (`awaitTermination()`)**
    - **`awaitTermination()`** 메소드를 호출하여 스레드 풀의 모든 작업이 완료될 때까지 대기합니다.
    - 지정된 시간 동안 모든 작업이 완료되면 `true`를 반환하고, 그렇지 않으면 `false`를 반환합니다.
5. **완전한 종료 확인 (`isTerminated()`)**
    - `isTerminated()`를 호출하여 `ExecutorService`가 완전히 종료되었는지 확인합니다.
    - 모든 작업이 완료되면 `true`를 반환합니다.
6. **긴급 종료 (`shutdownNow()`)**
    - 필요한 경우 `shutdownNow()`를 호출하여 실행 중인 작업을 즉시 중단하고, 대기 중인 작업 목록을 반환받을 수 있습니다.
    - 이 단계는 선택적이며, 일반적으로 정상적인 종료 과정 중에 필요한 작업 완료를 기다릴 수 없을 때 사용됩니다.

```lua
+------------------+        +------------------+       +------------------+
| 작업 제출        | -----> | 종료 시작        | ----> | 상태 확인        |
| (submit, execute)|        | (shutdown())     |       | (isShutdown())   |
+------------------+        +------------------+       +------------------+
                                                             |
                                                             V
                                                    +------------------+       +----------------------+
                                                    | 작업 완료 대기    | ----> | 긴급 종료             |
                                                    | (awaitTermination)|       | (shutdownNow())      |
                                                    +------------------+       +----------------------+
                                                             |
                                                             V
                                                    +------------------+
                                                    | 완전한 종료 확인  |
                                                    | (isTerminated()) |
                                                    +------------------+

```

이 흐름도는 **`ExecutorService`** 종료 과정에서 각 단계의 목적과 흐름을 나타냅니다. `shutdown()`을 호출한 후에는 `awaitTermination()`을 사용하여 작업이 완료될 때까지 기다리는 것이 일반적인 절차입니다. 필요한 경우, 작업이 너무 오래 걸리거나 긴급한 상황에서는 **`shutdownNow()`**를 사용하여 스레드 풀을 즉시 종료할 수 있습니다. 이 과정을 통해 `ExecutorService`의 리소스를 안전하고 효율적으로 관리할 수 있습니다.

## 다중 작업 처리

`ExecutorService`는 여러 가지 방식으로 다중 작업을 처리할 수 있습니다. 가장 기본적인 메소드는 `execute(Runnable)`와 **`submit(Callable)`** 혹은 `submit(Runnable)`입니다. 또한, `invokeAll()`과 **`invokeAny()`** 같은 고급 도구를 제공하여 여러 작업을 효율적으로 처리할 수 있습니다.

### **1. `submit()`**

- **`submit()`** 메소드는 **`Callable`** 또는 **`Runnable`** 객체를 받아 작업을 큐에 추가하고, **`Future`** 객체를 반환합니다. 이 **`Future`** 객체를 통해 작업의 결과를 나중에 받아올 수 있습니다.
- 반환된 `Future`는 작업의 완료를 확인하고, 결과를 검색하며, 작업을 취소하는 데 사용할 수 있습니다.

```java
import java.util.concurrent.*;

public class SubmitExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        Callable<String> task = () -> {
            TimeUnit.SECONDS.sleep(1);
            return "Result of Task";
        };

        Future<String> future = executor.submit(task);

        // 작업의 결과를 기다리며, 완료되면 출력
        System.out.println("Future result: " + future.get());

        executor.shutdown();
    }
}

```

### **2. `invokeAll()`**

- **`invokeAll()`** 메소드는 **`Callable`** 객체의 컬렉션을 받아, 모든 작업이 완료될 때까지 대기합니다. 이 메소드는 모든 작업에 대한 **`Future`** 객체 목록을 반환합니다.
- 이 방법은 모든 작업이 완료되기를 기다릴 필요가 있을 때 유용하며, 각 작업의 결과를 순차적으로 검토할 수 있습니다.

```java
import java.util.*;
import java.util.concurrent.*;

public class InvokeAllExample {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        List<Callable<String>> tasks = Arrays.asList(
            () -> "Result of Task 1",
            () -> "Result of Task 2",
            () -> "Result of Task 3"
        );

        List<Future<String>> futures = executor.invokeAll(tasks);

        for (Future<String> future : futures) {
            // 각 작업의 결과 출력
            System.out.println("Future result: " + future.get());
        }

        executor.shutdown();
    }
}

```

### **3. `invokeAny()`**

- **`invokeAny()`** 메소드는 **`Callable`** 객체의 컬렉션을 받아, 주어진 작업 중 하나라도 성공적으로 완료되면 즉시 결과를 반환합니다.
- 이 메소드는 여러 작업 중 최소 하나가 성공적으로 완료되기만 하면 되는 시나리오에 적합합니다. 실패한 작업은 무시되며, 성공한 첫 번째 결과가 반환됩니다.

```java
import java.util.*;
import java.util.concurrent.*;

public class InvokeAnyExample {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        List<Callable<String>> tasks = Arrays.asList(
            () -> {
                TimeUnit.SECONDS.sleep(2);
                return "Result of Task 1";
            },
            () -> {
                TimeUnit.SECONDS.sleep(1);
                return "Result of Task 2";
            },
            () -> {
                TimeUnit.SECONDS.sleep(3);
                return "Result of Task 3";
            }
        );

        String result = executor.invokeAny(tasks);

        System.out.println("First completed task result: " + result);

        executor.shutdown();
    }
}

```