# 동기화 개념
### 싱글 스레드 와 멀티 스레드
프로세스는 오직 한개의 스레드로만 구성하는 싱글 스레드 프로세스와 하나 이상의 스레드로 구성하는 멀티 스레드 프로세스로 구분할 수 있다. 작업 처리에 있어서 단일 스레드와 멀티 스레드의 선택 기준은 어떤 방식이 자원을 효율적으로 사용하고 성능처리에 유리한가 하는 점이다.

### 단일 스레드
순차 실행

| 장점 | 단점 |
| --- | --- |
| 문맥교환이 없다 | CPU 멀티코어 활용 못함 |
| 동기화 이슈가 없다 | 순차적 실행으로 응답성 및 전체 처리량이 낮다 |
| 자원 비용이 적다 | I/O 처리 시 CPU 가 낭비된다 |
| 프로그래밍 난이도가 낮다 | 스레드에 오류가 발생하면 프로그램이 종료된다 |

### 멀티 스레드
동시적, 병렬적 실행

| 장점 | 단점 |
| --- | --- |
| 동시성으로 사용자의 응답성 향상 | 빈번한 문맥교환으로 성능이 저하 된다 |
| CPU 멀티코어의 병렬성으로 성능 향상 | 스레드 간 동기화 이슈가 발생한다 |
| CPU 낭비 없는 자원의 효율적인 사용 | 스레드 생성 비용이 작지 않다 |
| 한 스레드 오류는 다른 스레드에 영향이 없다 | 프로그래밍 난이도가 높다 |

현대 CPU는 대부분 멀티코어를 지원하기 때문에 병렬적 성능 및 동시적 자원 사용 관점에서는 싱글 스레드보다 멀티 스레드 기반 프로그래밍이 유리한 점이 많다. 간혹 **싱글 스레드에서 비동기 프로그래밍**은 많은 수의 멀티 스레드 기반 프로그래밍 보다 더 좋은 성능과 응답성을 보여줄 수 있다.

## 멀티 스레딩 과 동시성

CPU 의 동시적 작업 처리는 CPU 코어 개수보다 스레드의 개수가 많을 때 즉 , 멀티스레딩 환경에서 자원을 효율적으로 배분하고 사용하기 위해 설계된 방식이다. 같은 프로그램 안에서 실행되는 여러 스레드가 읽기 및 쓰기 **작업을 같은 메모리 영역에서 동시에 실행할 경우** `동시성 문제`가 대두된다.

동시성 문제라 함은 하나의 스레드가 어떤 메모리 영역의 데이터를 쓰고 있는데 또 다른 스레드가 같은 메모리 영역의 데이터를 읽거나 쓸 경우 발생할 수 있는 문제이다.**동시성 문제는 싱글스레드에서는 절대 발생하지 않으며 멀티 스레드를 운용하는 어플리케이션에서 나타나는 현상**이다.

> **멀티 스레딩 (Multithreading)**
>
> 1. **정의**: 멀티 스레딩은 프로세스 내에서 여러 스레드가 동시에 실행되는 것을 말합니다. 스레드는 프로세스의 가장 작은 실행 단위로, 프로세스의 자원을 공유하면서 독립적인 작업을 수행할 수 있습니다.
> 2. **목적**: 멀티 스레딩은 CPU의 사용률을 극대화하고, 응답 시간을 단축시키며, 자원의 효율적인 사용을 가능하게 합니다. 특히, I/O 바운드 작업이 많은 애플리케이션에서 성능 향상을 가져올 수 있습니다.

이 멀티 스레딩 환경에서 `공유 작원을 선점`하기 위해 발생하는 스레드간의 동시성 문제는 자바 프로그램 개발에 있어서 반드시 이해해야 할 중요한주제이고 복잡하며 난해하다.

### **멀티 스레딩과 동시성 프로그래밍의 주요 포인트**

- **동기화**: 공유 자원에 대한 접근을 제어하여 데이터의 일관성을 유지합니다.
- **데드락 방지**: 여러 자원을 요청하는 스레드 간의 무한 대기 상태를 방지합니다.
- **스레드 관리**: 스레드 생명주기를 관리하고, 자원을 효율적으로 할당합니다.
- **성능 최적화**: 스레드 풀, 비동기 I/O와 같은 기술을 활용하여 시스템 자원을 최적화합니다.
- **오류 처리**: 멀티 스레딩 환경에서 발생할 수 있는 예외와 오류를 효과적으로 처리합니다.

이 밖에 확인해야 되고 알아야 할 주제가 방대하다.

## 동기화 와 CPU 관계

## 동기화(Synchronization) 란

여러 스레드가 동시에 같은 데이터나 자원에 접근할 때, 데이터의 일관성과 정확성을 유지하기 위해 사용된다. 멀티스레딩 환경에서 여러 스레드가 동시에 같은 메모리(변수, 객체 등)에 접근하게 되면, 예상치 못한 결과나 데이터 불일치가 발생할 수 있다. 이러한 문제를 **동시성 문제**라고 한다. `동기화`는 이러한 문제를 방지하기 위해 필하다.

## CPU 연산처리 이해

모든 기계어 명령(machine instruction) 은 **원자성(atimicity)** 을 갖는데 이는 **하나의 기계어 명령어가 실행을 시작할 경우 그 명령의 수행 종료시 까지는 인터럽트(interrupt)를 받지 않는다.** 분리 불가능(indivisible) 이라고도 한다.

**CPU 가 두 개 이상의 명령어를 처리할 경우에은 원자성이 보장되지 않는데** 이는 각 명령을 수행하는 중에 OS 가 다른 스케줄링으로 CPU 에게 다른 명령을 수행하게 함으로써 현재 수행중인 명령을 인터럽트 즉 중단하게 된다는 의미이다. **두 개 이상의 명령어를 원자성으로 묶기 위해서는 스레드 간 동기화 메카니즘이 필요**하다. 즉 한 스레드가 모든 명령을 다 수행될 때까지 도중에 중단되지 않도록 해야 한다.

> **원자성(Atomicity)이란**
> 컴퓨터 프로그래밍과 CPU 연산에서 사용되는 중요한 개념으로, **하나의 작업이나 명령이 중간 단계 없이 완전히 수행되거나** **전혀 수행되지 않는 성질을 의미**합니다. 원자적인 작업은 분할할 수 없으며, 실행 중에는 어떠한 다른 프로세스나 스레드에 의해 방해받지 않습니다.
>

### **원자성의 예**

- **원자적 연산**: 예를 들어, 변수에 대한 증가 연산(**`x++`**)은 원자적이지 않습니다.  이 연산은 실제로 '값 읽기', '값 증가', '값 쓰기'의 세 단계로 구성됩니다. 멀티스레딩 환경에서 두 스레드가 동시에 **`x++`** 연산을 수행하면, 동시성 문제로 인해 예상치 못한 결과가 발생할 수 있습니다.
- **원자성 보장 메커니즘**: 이를 해결하기 위해, 자바에서는 **`synchronized`** 블록이나 메서드를 사용하여 연산 전체를 원자적으로 만들 수 있습니다. 또한, **`java.util.concurrent.atomic`** 패키지의 클래스들은 원자적 연산을 지원합니다.

여기서 하나의 기계 명령어에 한해서 원자성을 보장해준다고 했을때 하나의 기계 명령어란 **값 읽기**, **값 증가**, **값 쓰기**   이 3개중 1개의 명령어에 한해서 원자성을 보장해서 동시성 문제가 발생하지 않는다는 말이다.

즉, 특정 변수에 대한 증가 중에서 오직 값 읽기, 오직 값 증가, 오직 값 쓰기 각각의 명령어만 원자성을 보장해주고 이 모든것을 합친 변수에 대한 증가에 대해서는 원자성을 보장하지 않는다.(2개 이상의 기계어 명령어는 원자성을 보장하지 않음)  
따라서 동시성문제가 발생하고 이를 해결하기 위해서 동기화 작업이 필요하다.
### **원자성 구현 방법**

1. **Synchronized 키워드**: **`synchronized`** 블록이나 메서드는 한 번에 하나의 스레드만 해당 코드 블록을 실행할 수 있도록 합니다. 이는 여러 스레드에 의한 동시 접근을 방지하여 원자성을 보장합니다.
2. **Lock 인터페이스**: **`java.util.concurrent.locks.Lock`** 인터페이스를 사용하여 명시적인 락을 제공하고, 락을 획득하고 해제하는 방식으로 원자성을 보장할 수 있습니다.
3. **Atomic 클래스**: **`java.util.concurrent.atomic`** 패키지는 원자적 연산을 지원하는 클래스들을 제공합니다. 예를 들어, `AtomicInteger`는 원자적으로 정수 값을 증가시키거나 감소시킬 수 있는 메서드를 제공합니다.

즉, 결론적으로 CPU 에서 원자성을 보장하지 않는 모든 연산 처리는 스레드 간 동시적 접근에 의해 데이터 불일치가 발생할 수 있다.

### **동기화의 방법**

1. **Synchronized 메서드**:
    - 메서드 전체를 동기화합니다.
    - 해당 메서드는 한 시점에 하나의 스레드만 실행할 수 있습니다.
    - 예: **`public synchronized void method() { /* ... */ }`**
2. **Synchronized 블록**:
    - 코드의 특정 부분만을 동기화합니다.
    - 동기화할 객체를 명시할 수 있습니다.
    - 예:

        ```java
        synchronized(this) {
            // 동기화 블록
        }
        
        ```


### **동기화의 특징**

- **락(Lock)**: 동기화를 사용하면, 해당 부분의 코드(블록 또는 메서드)에 락이 걸립니다. 이 락은 동기화된 블록이나 메서드를 실행하는 스레드에 의해서만 해제될 수 있습니다.
- **스레드 안전(Thread Safety)**: 동기화는 스레드 안전을 보장합니다. 즉, 여러 스레드가 동시에 같은 객체의 동기화된 메서드나 블록에 접근하더라도 데이터의 일관성과 정확성이 유지됩니다.
- **성능 저하**: 동기화는 필요한 경우에만 사용해야 합니다. 불필요한 동기화는 성능 저하를 초래할 수 있습니다.

### **동기화의 예시**

Java에서 동기화를 사용하는 간단한 예시는 다음과 같습니다.

```java
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

```

이 예제에서 **`increment`** 메서드와 **`getCount`** 메서드는 **`synchronized`** 키워드를 사용하여 동기화되어 있습니다. 이는 한 번에 하나의 스레드만이 이 메서드들을 실행할 수 있음을 의미하며, **`count`** 변수에 대한 동시 접근을 방지합니다.



### 스레드 불일치 예시
```java
class Counter {
    private int count = 0;

    // 원자적이지 않은 증가 메서드
    public void increment() {
        count++;  // '읽기', '증가', '쓰기'의 세 단계로 구성됨
    }

    public int getCount() {
        return count;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        final Counter counter = new Counter();

        // 스레드 1
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        // 스레드 2
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Expected count: 2000");
        System.out.println("Actual count: " + counter.getCount());
    }
}
```

## Critical Section(임계영역, 공유 변수 영역)

임계 영역(Critical Section)은 멀티스레딩 프로그램에서 **두 개 이상의 스레드가 동시에 접근하면 안 되는 코드 영역**을 말한다. 이 영역은 공유 자원(예: 변수, 파일)을 사용하는 코드를 포함하고 있으며, 여러 스레드에 의해 동시에 접근되면 데이터 불일치나 예상치 못한 결과를 초래할 수 있다.

이 임계 영역은 entry section, critical section, exit section, remainder section 으로 구성 된다.

- entry section(입장영역) : critical section 에 진입하기 위해 진입허가를 요청하는 영역입니다.
- **critical section(임계영역)** : 하나의 스레드만 접근할 수 있는 영역이다
- exit section(퇴장영역) : critical section 에서 빠져나올 때 신호를 알리는 영역이다
- remainder section (나머지영역) : entry section, critical section, exit section 을 제외한 나머지 영역이다


### Critical Section Problem
한 스레드가 임계 영역을 실행하고 일을 때 다른 스레드가 같은 임계영역을 상용함으로서 발생한다.  
이 문제의 해결책을 위해서 3가지 충족조건이 있다.
* **Mutual Exclusion (상호 배제)**
    * 어떤 스레드가 임계 영역을 실행중이면 다른 스레드는 동일한 임계영역을 실행할 수 없다.
* **Progress(진행)**
    * 임계 구역에서 실행 중인 스레드가 없고 임계 구역에 진입하련느 스레드가 있을때 어떤 스레드가 들어갈 것인지 적절히 선택해 줘야 하며 이러한 결정은 무한정 미뤄져선 안된다.
* **Bounded Waiting(한정 대기)**
    * 다른 스레드가 임계 영역에 들어가도록 요청한 후 해당 요청이 수락되기 전에 기존 스레드가 임계영역에서 실행할 수 있는 횟수에 제한이 있어야한다.
    * Starvation(기아상태) 이 발생하지 않도록 한다.

### 동기화 도구
뮤텍스, 세마포어, 모니터, CAS(Compare and Swap) 와 같은 동기화 도구를 통해 임계영역에서 문제가 발생하지 않도록 할 수 있으며 자바에서는 synchronized 키워드를 포함한 여러 동기화 도구들을 제공하고 있다.

### **자바에서의 임계 영역 처리 방법**

1. **Synchronized 메서드**
    - 메서드 전체를 임계 영역으로 지정합니다.
    - **`synchronized`** 키워드를 메서드 선언에 추가하여 사용합니다.
    - 이 메서드는 한 번에 하나의 스레드만이 접근할 수 있습니다.
    - 예:

        ```java
        
        public synchronized void increment() {
            // 임계 영역
        }
        
        ```

2. **Synchronized 블록**
    - 특정 객체에 대한 동기화된 블록을 생성합니다.
    - 임계 영역 내에서 필요한 최소한의 코드만을 포함시킵니다.
    - 예:

        ```java
        
        public void increment() {
            synchronized(this) {
                // 임계 영역
            }
        }
        
        ```

3. **Lock 인터페이스**
    - **`java.util.concurrent.locks`** 패키지의 **`Lock`** 인터페이스를 사용합니다.
    - 명시적으로 락을 획득하고 해제합니다.
    - **`ReentrantLock`** 클래스가 일반적으로 사용됩니다.
    - 예:

        ```java
        
        Lock lock = new ReentrantLock();
        
        public void increment() {
            lock.lock();
            try {
                // 임계 영역
            } finally {
                lock.unlock();
            }
        }
        
        ```

4. **Atomic 변수**
    - **`java.util.concurrent.atomic`** 패키지에 있는 클래스들을 사용합니다.
    - 원자적 연산을 통해 락 없이도 스레드 안전을 보장할 수 있습니다.
    - 예: **`AtomicInteger`**, **`AtomicLong`** 등

   ### 예시

    ```java
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    class CriticalSectionExample {
        private final Lock lock = new ReentrantLock();
        private int sharedResource = 0;
    
        public void criticalSection() {
            // 진입 구역 (Entry Section)
            lock.lock(); // 임계 영역 진입 전 락을 획득
    
            try {
                // 임계 구역 (Critical Section)
                sharedResource++; // 공유 자원에 대한 연산 수행
    
                // 퇴장 구역 (Exit Section)
                // 이 경우 특별한 퇴장 작업은 없음
    
            } finally {
                // 락 해제
                lock.unlock();
            }
    
            // 나머지 구역 (Remainder Section)
            // 임계 영역과 무관한 나머지 작업 수행
            nonCriticalSection();
        }
    
        public void nonCriticalSection() {
            // 임계 영역 외의 작업 수행
        }
    }
    ```

    - **진입 구역**: **`lock.lock()`** 호출로 시작합니다. 이 부분에서 현재 스레드는 임계 구역에 진입하기 위해 락을 획득하려고 시도합니다.
    - **임계 구역**: `sharedResource++`는 실제 공유 자원을 수정하는 임계 구역입니다. 이 부분은 한 번에 하나의 스레드만 접근할 수 있어야 합니다.
    - **퇴장 구역**: **`finally`** 블록 내부에서 `lock.unlock()`을 호출하여 임계 구역을 빠져나옵니다. 이는 다른 스레드가 이제 임계 구역에 진입할 수 있음을 의미합니다.
    - **나머지 구역**: **`nonCriticalSection()`** 메서드는 임계 구역과 무관한 다른 작업을 수행하는 부분으로, 락과 관련이 없습니다.

### Race Condition(경쟁상태, 경쟁조건, 경합 상태)
여러 스레드가 동시에 **공유 자원에 접근하고 조작할때 스레드간 접근하는 순서나 시점에 따라 실행 결과가 달라질** 수 있는데 이것을 경쟁상태 라고 한다. 경쟁 상태는 임계영역에서 발생하는 문제들이 해결 되지 않는 상태에서 여러 스레드가 동시에 임계 영역에 접근해서 공유 데이터를 조작함으로써 발생하는 상태라 할 수 있다.


## 안전한 스레드 구성

여러 스레드에서 클래스나 객체에 동시에 접근해서 계속 실행하더라도 **지속적인 정확성이 보장**되는 코드를 **스레드 세이프(thread-safe)** 즉 스레드에 안전하다고 한다. 기본적으로 클래스 명세에 스레드 안정성을 헤치는 코드나 상태를 가지고 있지 않으면 스레드에 안전하다라고 정의할 수 있다. 스레드에 안전한 코드에는 경쟁상태가 없으며 경쟁 상태는 다수의 스레드가 공유 자원에 쓰기 작업을 시도할 때 발생하기 때문에 스레드가 실행될 때 어떤 자원을 공유하게 되는지 아는 것이 중요하다.

### **스레드 세이프의 중요성**

- **데이터 일관성**: 멀티스레딩 환경에서 공유 자원에 대한 동시 접근은 데이터의 불일치를 초래할 수 있습니다. 스레드 세이프한 구현은 이러한 문제를 방지한다.
- **오류 방지**: 잘못된 동기화는 데드락, 레이스 컨디션 등의 오류를 발생시킬 수 있습니다. 스레드 세이프한 코드는 이러한 오류를 최소화한다.

### 스레드에 안전한 구조

- **임계영역을 동기화 한다**
    - 동시에 여러개의 스레드가 임계영역을 접근하지 못하도록 락(Lock) 메카니즘을 사용한다
- **동기화 도구를 사용한다**
    - 세마포어, CAS, Atomic 변수, 동시성 자료구조 등의 동기화 도구들을 사용해서 스레드 안전성을 구현한다
        - 만약에 여러 스레드가 Reader라는 개체를 통해서 DB에서 특정 데이터를 조회하려고 한다. 이때 이 조회데는 데이터는 여러스레드가 동시에 중복해서 읽어오면 안되는 상황일때 `synchronized` 키워드를 통해 한번에 하나의 스레드만 접근해서 데이터를 읽어 올 수 있게 처리할 수 있다.
- **스레드의** **스택에 한정해서 상태를 관리한다**
    - 스레드마다 할당된 스택 메모리 내에서 상태를 관리함으로서 다른 스레드와 상태를 공유할 수 없도록 한다’
    - **지역변수 활용:** 스레드마다 독립적으로 스택에 저장되기 떄문에 스레드간에 공유될 수 없다.
    - **지역객체 참조 :** 변수와 다르게 객체는 스택에 저장되지 않고 힙 영역에 저장된다. 하지만 **지역적으로 생성된 객체가 해당 메서드에서 벗어나지 않고 사용 된다면 스레드는 자신만의 객체를 참조할 수 있게 되어 스레드에 안전하다.**
    - **멤버 변수 참조:** 멤버 변수 참조 역시 스레드 마다 객체를 생성하는 원리는 동일하다. 즉 스레드의 스택별로 객체가 생성되어 참조되도록 구현하면 된다.
- **ThreadLocal** **을 사용한다**
    - 스레드마다 가지고 있는 전용 저장소인 ThreadLocal 을 사용해서 상태를 관리함으로서 다른 스레드와 상태를 공유할 수 없도록 한다
- **불변 객체를 사용한다**
    - 객체의 상태를 변경할 수 없는 클래스를 사용하거나 클래스를 설계할 때 상태를 변경할 수 없도록(final 키워드) 만들어서 스레드에 안전하도록 한다
- **고립(Isolation)**
    - 스레드들이 서로 영향을 주지 않도록 데이터를 고립시킵니다.
