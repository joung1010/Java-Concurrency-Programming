# 비동기 프로그래밍
## 동기 와 비동기, Blocking 과 Non Blocking  
### 동기 (Synchronous)
동기(Synchronous)는 **작업이 순차적으로 실행**되며 **한 작업의 시작과 완료**가 다음 작업의 시작과 완료와 밀접하게 연결된 방식을 의미한다.  
  
**하나의 작업이 실행 중인 동안** **다른 작업은 대기**해야 하며 **작업의 결과를 기다린 후에 다음 작업이 진행**됩니다. 작업은 한번에 하나씩 진행되며 건너 뛰거나 빠뜨릴 수 없습니다.  
  
즉 작업을 요청하고 그 작업이 완료되기까지 기다리며, 이후에 다음 작업을 처리합니다. 만약 하나의 작업을 서로 다른 스레드가 공유해서 처리하게 된다면 동기는 깨질 수 가 있다.  
- **예시**:
    - 함수 호출 후 그 함수의 결과가 반환될 때까지 기다림.
    - 일반적인 메소드 호출은 동기적입니다.

```java
public String fetchDataSynchronously() {
    // 데이터를 가져오는 작업을 동기적으로 수행
    return "data";
}
```
  
### 비동기 (Asynchronous)
비동기 (Asynchronous)는 작업이 순차적으로 실행되지 않고 **각 작업이 다른 작업의 완료를 기다리지 않고 `독립적`으로 실행**되는 방식을 의미한다.  
  
한 작업이 시작된 후에도 다음 작업이 바로 시작될 수 있으며 **작업의 결과에 관심이 없고** 기다리지 않으며 다른 작업을 실행할 수 있습니다. 따라서 비동기 작업은 주로 **I/O 작업**과 같이 **시간이 오래 걸리는 작업**을 다룰 때 유용하며 다**수의 작업을 동시에 처리**하거나 **빠른 응답을 보장**해야 하는 경우에 활용 됩니다.  
  
`Fire and Forget` 이라는 용어가 있는데 이는 비동기 프로그래밍 용어로서 작업을 시작하고 그 결과에 대해 더 이상 관심을 갖지 않고 진행하는 것을 의미 한다.  

즉 작업이 완료될 때까지 기다리지 않고 다른 작업을 할 수 있습니다. 즉 작업을 위임하는 쪽에서 해당 작업에 대한 결과를 신경 쓰지 않는 것이다/
- **예시**:
  - AJAX 요청
  - `CompletableFuture`, `Future`를 이용한 비동기 작업

```java
public CompletableFuture<String> fetchDataAsynchronously() {
    return CompletableFuture.supplyAsync(() -> {
        // 데이터를 비동기적으로 가져오는 작업
        return "data";
    });
}

```
  

그러면 여기서 비동기 처리로 각 작업이 독립적으로 실행되는 상황에서도 동기식 처리가 가능할까???  
  
이는 작업을 위임하는 쪽에서 주기적으로 위임한 작업에 대한 결과를 확인하는 방법으로 비동기에서 동기적 처리가 가능하게 됩니다.
  
### 블록킹(Blocking)
블록킹(Blocking)은 동기 작업에서 나타나는 현상으로 **작업이 완료될 때까지 실행 흐름을 멈추고 대기하는 상태**를 말합니다.  
  
예를들어 파일을 읽거나 네트워킹에서 데이터를 받아오는 I/O 작업이 블록킹 작업에 해당하며 작업이 완료될때까지 다른 작업은 차단되고 대기 상태에 놓이게 됩니다.  
  
즉 자원이 준비될 때까지 호출한 스레드가 멈춥니다.  
- **예시**: 파일을 읽는 동안, 파일이 다 읽힐 때까지 스레드가 멈춰있는 상태.

```java
public String readFileBlocking() throws IOException {
    // 파일을 동기적이고 블로킹 방식으로 읽음
    BufferedReader reader = new BufferedReader(new FileReader("file.txt"));
    return reader.readLine();
}
```
  
그러면 하나의 작업을 서로 다른 스레드가 처리할때에도 블록킹이 발생할 수 있는가???  
비동기는 동시적 처리이며 작업에 대한 결과를 신경쓰지 않는다. 일반적으로 블록킹이 발생할 수 있는 경우가 없다고 생각하는게 맞다.  
  
하지만 만약에 작업을 위임하고 위임한 스레드가 해당 작업이 끝날때까지 아무 것도 하지 않는 경우 즉 위임한 작업이 완료될때 까지 대기하는 경우에 해당한다.(블록킹 발생)
  
### 논 블록킹(Non-Blocking)
논 블록킹(Non-Blocking)은 비동기 작업에서 나타나는 현상으로 블록킹 되지 않고 **실행 흐름이 지속**되는 특서을 나타낸다.  
  
특정 작업이 진행 중일 때에도 다른 작업이 계속 실행되며, 작업이 완료되지 않았더라고 대기하지 않고 다음 작업을 처리하는 방식을 의미한다. 논 블로킹 작업은 다른 작업들과 동시에 진행될 수 있어서 전체 시스템의 응답성을 향상시킬 수있다.  
  
### 정리
- **동기/비동기**는 작업의 결과를 어떻게 처리할지에 대한 개념입니다.
  - 동기: 결과를 기다림
  - 비동기: 결과를 기다리지 않음
- **블로킹/논블로킹**은 스레드가 자원을 기다릴 때의 동작 방식에 대한 개념입니다.
  - 블로킹: 자원이 준비될 때까지 스레드가 멈춤
  - 논블로킹: 자원이 준비되지 않았더라도 스레드가 멈추지 않고 계속 실행

이 두 개념은 결합될 수 있으며, 아래와 같은 조합이 가능합니다.

1. **동기 + 블로킹**: 작업이 완료될 때까지 기다리며, 스레드는 그동안 멈춤.
2. **동기 + 논블로킹**: 작업을 요청하고 바로 제어권을 반환받지만, 작업이 완료될 때까지 그 결과를 기다림.
3. **비동기 + 블로킹**: 비동기 작업을 요청하지만, 결과가 필요할 때까지 스레드는 멈춤.
4. **비동기 + 논블로킹**: 비동기 작업을 요청하고, 결과를 기다리지 않고 바로 다른 작업을 처리할 수 있음.