# 비동기 프로그래밍

## 동기 와 비동기, Blocking 과 Non Blocking

### 동기 (Synchronous)

동기(Synchronous)는 **작업이 순차적으로 실행**되며 **한 작업의 시작과 완료**가 다음 작업의 시작과 완료와 밀접하게 연결된 방식을 의미한다.

**하나의 작업이 실행 중인 동안** **다른 작업은 대기**해야 하며 **작업의 결과를 기다린 후에 다음 작업이 진행**됩니다. 작업은 한번에 하나씩 진행되며 건너 뛰거나 빠뜨릴 수 없습니다.

즉 작업을 요청하고 그 작업이 완료되기까지 기다리며, 이후에 다음 작업을 처리합니다. 만약 하나의 작업을 서로 다른 스레드가 공유해서 처리하게 된다면 동기는 깨질 수 가 있다.

- **예시**:
    - 함수 호출 후 그 함수의 결과가 반환될 때까지 기다림.
    - 일반적인 메소드 호출은 동기적입니다.

```java
public String fetchDataSynchronously() {
    // 데이터를 가져오는 작업을 동기적으로 수행
    return "data";
}
```

### 비동기 (Asynchronous)

비동기 (Asynchronous)는 작업이 순차적으로 실행되지 않고 **각 작업이 다른 작업의 완료를 기다리지 않고 `독립적`으로 실행**되는 방식을 의미한다.

한 작업이 시작된 후에도 다음 작업이 바로 시작될 수 있으며 **작업의 결과에 관심이 없고** 기다리지 않으며 다른 작업을 실행할 수 있습니다. 따라서 비동기 작업은 주로 **I/O 작업**과 같이 **시간이 오래
걸리는 작업**을 다룰 때 유용하며 다**수의 작업을 동시에 처리**하거나 **빠른 응답을 보장**해야 하는 경우에 활용 됩니다.

`Fire and Forget` 이라는 용어가 있는데 이는 비동기 프로그래밍 용어로서 작업을 시작하고 그 결과에 대해 더 이상 관심을 갖지 않고 진행하는 것을 의미 한다.

즉 작업이 완료될 때까지 기다리지 않고 다른 작업을 할 수 있습니다. 즉 작업을 위임하는 쪽에서 해당 작업에 대한 결과를 신경 쓰지 않는 것이다/

- **예시**:
    - AJAX 요청
    - `CompletableFuture`, `Future`를 이용한 비동기 작업

```java
public CompletableFuture<String> fetchDataAsynchronously() {
    return CompletableFuture.supplyAsync(() -> {
        // 데이터를 비동기적으로 가져오는 작업
        return "data";
    });
}

```

그러면 여기서 비동기 처리로 각 작업이 독립적으로 실행되는 상황에서도 동기식 처리가 가능할까???

이는 작업을 위임하는 쪽에서 주기적으로 위임한 작업에 대한 결과를 확인하는 방법으로 비동기에서 동기적 처리가 가능하게 됩니다.

### 블록킹(Blocking)

블록킹(Blocking)은 동기 작업에서 나타나는 현상으로 **작업이 완료될 때까지 실행 흐름을 멈추고 대기하는 상태**를 말합니다.

예를들어 파일을 읽거나 네트워킹에서 데이터를 받아오는 I/O 작업이 블록킹 작업에 해당하며 작업이 완료될때까지 다른 작업은 차단되고 대기 상태에 놓이게 됩니다.

즉 자원이 준비될 때까지 호출한 스레드가 멈춥니다.

- **예시**: 파일을 읽는 동안, 파일이 다 읽힐 때까지 스레드가 멈춰있는 상태.

```java
public String readFileBlocking() throws IOException {
    // 파일을 동기적이고 블로킹 방식으로 읽음
    BufferedReader reader = new BufferedReader(new FileReader("file.txt"));
    return reader.readLine();
}
```

그러면 하나의 작업을 서로 다른 스레드가 처리할때에도 블록킹이 발생할 수 있는가???  
비동기는 동시적 처리이며 작업에 대한 결과를 신경쓰지 않는다. 일반적으로 블록킹이 발생할 수 있는 경우가 없다고 생각하는게 맞다.

하지만 만약에 작업을 위임하고 위임한 스레드가 해당 작업이 끝날때까지 아무 것도 하지 않는 경우 즉 위임한 작업이 완료될때 까지 대기하는 경우에 해당한다.(블록킹 발생)

### 논 블록킹(Non-Blocking)

논 블록킹(Non-Blocking)은 비동기 작업에서 나타나는 현상으로 블록킹 되지 않고 **실행 흐름이 지속**되는 특서을 나타낸다.

특정 작업이 진행 중일 때에도 다른 작업이 계속 실행되며, 작업이 완료되지 않았더라고 대기하지 않고 다음 작업을 처리하는 방식을 의미한다. 논 블로킹 작업은 다른 작업들과 동시에 진행될 수 있어서 전체 시스템의
응답성을 향상시킬 수있다.

### 정리

- **동기/비동기**는 작업의 결과를 어떻게 처리할지에 대한 개념입니다.
    - 동기: 결과를 기다림
    - 비동기: 결과를 기다리지 않음
- **블로킹/논블로킹**은 스레드가 자원을 기다릴 때의 동작 방식에 대한 개념입니다.
    - 블로킹: 자원이 준비될 때까지 스레드가 멈춤
    - 논블로킹: 자원이 준비되지 않았더라도 스레드가 멈추지 않고 계속 실행

이 두 개념은 결합될 수 있으며, 아래와 같은 조합이 가능합니다.

1. **동기 + 블로킹**: 작업이 완료될 때까지 기다리며, 스레드는 그동안 멈춤.
2. **동기 + 논블로킹**: 작업을 요청하고 바로 제어권을 반환받지만, 작업이 완료될 때까지 그 결과를 기다림.
3. **비동기 + 블로킹**: 비동기 작업을 요청하지만, 결과가 필요할 때까지 스레드는 멈춤.
4. **비동기 + 논블로킹**: 비동기 작업을 요청하고, 결과를 기다리지 않고 바로 다른 작업을 처리할 수 있음.

## 함수 관점

### 동기 와 비동기

함수를 호출한자를 (Caller) 와 호출된 함수를 수행하는 주체를 (Callee)가 **동일 스레드이면 동기**, **서로 다은 스레드이면 비동기** 관계가 형성된다.

함수를 호출한자(Caller) 와 **호출된 함수의 작업 결과 및 종료 여부**에 대해 **관심을 가지고 있으면 동기 없으면 비동기**라고 할 수 있다.

즉 동기와 비동기는 작업을 **실행하는 작업자들인 스레드간 구성**에 관한 문제라고도 할 수 있다.

```less
동기(Synchronous)

:
[ Caller ]
|
| ------ 호출 ------ > [ Callee

(
같은 스레드

)
]
|

<
----- 결과 반환 ----
   |

(
결과에 관심을 가짐

)

비동기(Asynchronous)

:
[ Caller ] [ Callee

(
다른 스레드

)
]
|
| ------ 호출 ----- >
|
|

(
결과에 무관심

)

동기인데

비동기(Synchronous but Asynchronous Element)

:
[ Caller ]
|
| ------ 호출 ------ > [ Callee

(
다른 스레드

)
]
| |
| |

(
작업 수행 중

)
| |
|

<
----- 결과 반환 ---------
   |

(
결과에 관심이 있어 기다림

)

```

### Blocking , Non Blocking

함수를 호출한자(Caller) 와 호출된 함수를 수행하는 주체(Callee)가 동일한 스레드이면 Blocking, 서로 다른 스레드이면 Non Blocking이 발생한다고 볼 수 있다.

함수를 호출한자(Caller) 와 호출된 함수를 수행하는 주체(Callee) 가 순차적으로 작업을 진행한다면 Blocking, 동시적으로 진행한다면 Non Blocking 이라 할 수 있다.

즉 Blocking 과 Non Blocking 은 작업자의 작업 즉, **스레드간 행위**에 관한 문제이다.

## CompletableFuture

`CompletableFuture`는 Java 8에서 도입된 비동기 프로그래밍을 위한 클래스입니다. 이 클래스는 `Future`의 발전된 버전으로, 더 많은 기능을 제공하며 비동기 작업을 작성하고 처리하는 데 매우
유용합니다. `CompletableFuture`는 비동기 작업을 더 쉽게 관리하고, 작업의 완료 또는 실패 시 특정 작업을 수행할 수 있도록 하는 여러 메서드를 제공합니다.

### 주요 개념

1. **비동기 작업**: `CompletableFuture`를 사용하면 비동기적으로 작업을 수행하고, 해당 작업이 완료될 때 추가적인 작업을 정의할 수 있습니다.
2. **체이닝(Chaining)**: `CompletableFuture`는 메서드 체이닝을 통해 작업을 순차적으로 연결할 수 있습니다. 예를 들어, 한 작업이 완료된 후에 다른 작업을 수행할 수 있습니다.
3. **콜백(Callback)**: 비동기 작업이 완료되면, `thenApply`, `thenAccept`, `thenRun` 같은 메서드를 통해 완료 후 실행할 작업을 정의할 수 있습니다.

### Future 랑 뭐가 달라??

CompletableFuture는 기존의 Future와 비교했을 때 여러 가지 중요한 개선점과 차이점을 가지고 있습니다. Future는 비동기적으로 작업의 결과를 가져올 수 있는 인터페이스를 제공하지만, 한계가
있으며, 이를 CompletableFuture가 보완합니다.

- **비차단(non-blocking)**: `Future`는 결과를 기다리기 위해 `get()` 호출 시 차단되지만, `CompletableFuture`는 결과가 준비되면 콜백을 통해 비차단 방식으로 처리할 수
  있습니다.
- **체이닝 및 콜백**: `CompletableFuture`는 `thenApply()`, `thenAccept()`, `thenCombine()` 등 다양한 메서드를 통해 비동기 작업을 연결하고, 완료 후 추가
  작업을 정의할 수 있습니다.
- **예외 처리**: `CompletableFuture`는 `exceptionally()` 메서드를 통해 비동기 작업 중 발생한 예외를 명시적으로 처리할 수 있습니다.
- **직접 완료 가능**: `CompletableFuture`는 `complete()` 메서드로 작업을 강제로 완료하거나 수동으로 완료 상태로 변경할 수 있습니다.

### 장점

- **비동기 작업 처리**: 스레드 차단 없이 작업을 비동기적으로 처리할 수 있습니다.
- **더 나은 작업 체이닝**: `CompletableFuture`는 작업 완료 후 처리할 작업을 간결하게 연결할 수 있는 기능을 제공합니다.
- **예외 처리**: `CompletableFuture`는 비동기 작업 중 발생하는 예외를 명시적으로 처리할 수 있습니다.

### `CompletableFuture` vs `Future`

- **Future**는 비동기 작업의 결과를 기다리는 방식으로 `get()` 메서드를 호출할 때 작업이 완료될 때까지 차단(blocking)됩니다.
- **CompletableFuture**는 비차단 방식으로 결과를 처리하며, 작업이 완료되면 자동으로 콜백을 통해 결과를 처리할 수 있는 추가적인 메서드를 제공합니다.

`CompletableFuture`는 복잡한 비동기 작업 흐름을 보다 유연하고 쉽게 관리할 수 있는 Java의 강력한 도구로, 특히 비동기 프로그래밍이 중요한 현대 애플리케이션에서 매우 유용하게 사용됩니다.

## CompletableFuture API 구조

CompletableFuture 는 비동기 작업과 함수형 프로그래밍의 콜백 패턴을 조합한 Future라 할 수 있으며 2가지 유형의 API로 구분할 수 있다.

CompletableFuture 는 Future 와 CompletionStage 를 구현한 클래스로서 `Future + CompletionStage` 라고 정의할 수도 있다.

### **CompletionStage와의 관계**

`CompletionStage`는 Java 8에서 도입된 인터페이스로, 비동기 작업 간의 **의존 관계**를 선언적으로 정의할 수 있도록 지원합니다. 즉, **작업 간의 순차적인 실행** 또는 **병렬 실행**을
쉽게 구성할 수 있습니다. `CompletionStage`는 하나의 비동기 작업이 완료되면 이후에 어떤 작업을 수행할지를 정의하는 메서드들을 제공합니다.

`CompletableFuture`는 `CompletionStage`의 구현체로서, 여러 비동기 작업을 **결합**하고 **연쇄적으로 처리**하는 데 매우 유용한 기능을 제공합니다.

### **CompletionStage 주요 메서드**

`CompletionStage`는 여러 비동기 작업을 체인으로 연결할 수 있는 메서드들을 제공하며, 이 메서드들은 주로 두 가지 형태로 나눌 수 있습니다:

1. **단일 작업 후 콜백 실행**

- `thenApply()`: 이전 작업이 완료되면 그 결과를 받아서 **새로운 작업을 수행**한 후 값을 반환합니다.
- `thenAccept()`: 이전 작업이 완료되면 그 결과를 받아서 **소비(consume)**만 하고 반환값은 없습니다.
- `thenRun()`: 이전 작업의 결과에 상관없이 **특정 작업을 실행**하며, 반환값은 없습니다.

**예시:**

```java
CompletableFuture.supplyAsync(() ->"Hello")
        .

thenApply(result ->result +" World")
        .

thenAccept(result ->System.out.

println(result));

```

여기서 `supplyAsync`는 비동기 작업으로 "Hello" 문자열을 반환하고, `thenApply`는 그 결과를 받아서 " World"를 추가합니다. 마지막으로 `thenAccept`는 최종 결과를 출력합니다.

2. **두 개 이상의 작업 결합**

- `thenCombine()`: 두 개의 비동기 작업이 완료되면 그 결과를 받아 **새로운 작업을 수행**하고 결과를 반환합니다.
- `thenCompose()`: 이전 작업이 완료되면, 그 결과를 기반으로 **새로운 비동기 작업을 실행**합니다.
- `runAfterBoth()`: 두 개의 비동기 작업이 완료된 후 **별도의 작업을 수행**하지만, 결과를 반환하지 않습니다.

**예시:**

```java
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> " World");

future1.

thenCombine(future2, (result1, result2) ->result1 +result2)
        .

thenAccept(result ->System.out.

println(result));  // 결과: Hello World

```

### **CompletableFuture와 CompletionStage의 연계성**

`CompletableFuture`는 `CompletionStage`의 연산을 사용하여 다양한 비동기 작업을 연결하고 결과를 처리합니다.

- **비동기 작업의 정의**: 비동기 작업을 정의할 때는 `CompletableFuture`를 사용하여 작업을 시작하지만, **작업의 연속성과 연결성**은 `CompletionStage`의 메서드를 통해
  이루어집니다. 이를 통해 복잡한 비동기 작업 흐름을 **간결하게 정의**할 수 있습니다.
- **비동기 흐름의 유연한 조합**: `CompletionStage` 메서드를 통해 다양한 비동기 작업을 병렬로 실행하거나 순차적으로 연결하여 **비동기 작업의 흐름을 유연하게 조합**할 수 있습니다.

### CompletableFuture 주요 메서드

### **1. 단일 비동기 작업**

단일 비동기 작업은 하나의 `CompletableFuture`를 사용하여 비동기 작업을 수행하고, 그 결과를 처리하거나 후속 업을 정의합니다. 아래 메서드들은 단일 비동기 작업에서 자주 사용됩니다.

---

### **1.1. `supplyAsync`**

- **설명**: 결과를 반환하는 비동기 작업을 수행합니다.
- **사용 예시**:

```java

CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    // 비동기 작업
    return "Result";
});

```

---

### **1.2. `thenApply`**

- **설명**: 이전 비동기 작업의 결과를 처리하고, 다른 결과를 반환합니다.
- **사용 예시**:

```java

future.thenApply(result ->"Processed "+result);

```

---

### **1.3. `thenAccept`**

- **설명**: 이전 비동기 작업의 결과를 처리하지만, 새로운 결과를 반환하지 않습니다.
- **사용 예시**:

```java

future.thenAccept(result ->System.out.

println("Result: "+result));

```

---

### **1.4. `thenRun`**

- **설명**: 이전 작업의 결과를 처리하지 않고, 완료된 후에 실행됩니다.
- **사용 예시**:

```java

future.thenRun(() ->System.out.

println("Task Completed"));

```

---

### **1.5. `join`**

- **설명**: 비동기 작업이 완료될 때까지 기다리고, 그 결과를 반환합니다.
- **사용 예시**:

```java

String result = future.join();  // 비동기 작업이 완료될 때까지 대기

```

---

### **1.6. `complete`**

- **설명**: 비동기 작업을 수동으로 완료하고, 그 결과를 설정합니다.
- **사용 예시**:

```java

CompletableFuture<String> future = new CompletableFuture<>();
future.

complete("Forced Result");  // 수동으로 결과 설정
System.out.

println(future.join());  // "Forced Result"

```

---

### **1.7. `orTimeout`**

- **설명**: 지정된 시간 내에 비동기 작업이 완료되지 않으면 타임아웃 예외를 발생시킵니다.
- **사용 예시**:

```java

CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try {
        Thread.sleep(5000);  // 5초 대기
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "Result";
}).orTimeout(2, TimeUnit.SECONDS);  // 2초 타임아웃

future.

exceptionally(ex ->{
        System.out.

println("Timeout occurred: "+ex.getMessage());
        return null;
        });

```

---

### **1.8. `completeOnTimeout`**

- **설명**: 작업이 지정된 시간 내에 완료되지 않으면 기본값으로 작업을 완료합니다.
- **사용 예시**:

```java

CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try {
        Thread.sleep(5000);  // 5초 대기
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "Result";
}).completeOnTimeout("Default Result", 2, TimeUnit.SECONDS);  // 2초 내에 완료되지 않으면 기본값 설정

future.

thenAccept(System.out::println);  // 2초 후 "Default Result" 출력

```

---

### **2. 복합 비동기 작업**

복합 비동기 작업은 여러 개의 `CompletableFuture`를 병렬로 실행하거나, 순차적으로 연결해서 실행할 때 사용됩니다.

---

### **2.1. `thenCompose`**

- **설명**: 이전 비동기 작업의 결과를 사용하여 또 다른 비동기 작업을 순차적으로 실행합니다.
- **사용 예시**:

```java

CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Task 1");
CompletableFuture<String> future2 = future.thenCompose(result ->
        CompletableFuture.supplyAsync(() -> result + " and Task 2")
);
future2.

thenAccept(System.out::println);  // "Task 1 and Task 2"

```

---

### **2.2. `thenCombine`**

- **설명**: 두 개의 `CompletableFuture`를 결합하여, 두 작업이 모두 완료된 후에 결과를 처리합니다.
- **사용 예시**:

```java

CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "World");

CompletableFuture<String> combined = future1.thenCombine(future2, (f1, f2) -> f1 + " " + f2);
combined.

thenAccept(result ->System.out.

println(result));  // "Hello World"

```

---

### **2.3. `allOf`**

- **설명**: 여러 개의 `CompletableFuture`들이 모두 완료될 때까지 기다립니다.
- **사용 예시**:

```java

CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Task 1");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "Task 2");

CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2);
allOf.

thenRun(() ->System.out.

println("All tasks completed"));

```

---

### **2.4. `anyOf`**

- **설명**: 여러 개의 `CompletableFuture` 중 하나라도 완료되면 후속 작업을 실행합니다.
- **사용 예시**:

```java

CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Task 1");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "Task 2");

CompletableFuture<Object> anyOf = CompletableFuture.anyOf(future1, future2);
anyOf.

thenAccept(result ->System.out.

println("First completed task: "+result));

```

---

### **3. 비동기 작업 예외 처리**

비동기 작업의 예외를 처리하는 기능입니다. 비동기 작업 중 발생하는 예외를 다루거나, 작업 성공/실패 여부와 상관없이 후속 작업을 수행하는 메서드들입니다.

---

### **3.1. `exceptionally`**

- **설명**: 비동기 작업에서 예외가 발생했을 때 예외를 처리하고, 대체 결과를 반환합니다.
- **사용 예시**:

```java

future.exceptionally(ex ->{
        System.out.

println("Exception occurred: "+ex.getMessage());
        return null;
        });

```

---

### **3.2. `handle`**

- **설명**: 작업이 성공적으로 완료되든, 예외가 발생하든 상관없이 결과를 처리합니다.
- **사용 예시**:

```java

CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("Error occurred");
});

future.

handle((result, ex) ->{
        if(ex !=null){
        System.out.

println("Handled exception: "+ex.getMessage());
        return"Fallback result";
        }
        return result;
}).

thenAccept(System.out::println);  // "Handled exception: Error occurred"

```

---

### **3.3. `whenComplete`**

- **설명**: 작업이 성공적으로 완료되든, 예외가 발생하든 상관없이 후속 동작을 정의합니다. 하지만 반환값은 처리하지 않습니다.
- **사용 예시**:

```java

CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Result");

future.

whenComplete((result, ex) ->{
        if(ex !=null){
        System.out.

println("Exception: "+ex.getMessage());
        }else{
        System.out.

println("Completed with: "+result);
    }
            });

```

---

### **3.4. `completeExceptionally`**

- **설명**: 비동기 작업을 강제로 예외 상태로 완료하여 작업을 실패 상태로 만듭니다.
- **사용 예시**:

```java

CompletableFuture<String> future = new CompletableFuture<>();
future.

completeExceptionally(new RuntimeException("Manual exception"));

        future.

whenComplete((result, ex) ->{
        if(ex !=null){
        System.out.

println("Exception: "+ex.getMessage());
        }
        });

```

---

### **결론**

- **단일 비동기 작업**: 주로 `supplyAsync`, `thenApply`, `thenAccept` 등을 통해 비동기 작업의 결과를 처리합니다.
- **복합 비동기 작업**: `thenCompose`, `thenCombine`, `allOf` 등을 사용하여 여러 작업을 병렬 또는 순차적으로 처리할 수 있습니다.
- **예외 처리**: 비동기 작업에서 발생하는 예외를 `exceptionally`, `handle`, `whenComplete` 등을 통해 처리하여 유연한 에러 핸들링을 구현할 수 있습니다.

### 예제: 비동기 API 호출 및 처리

다음은 `CompletableFuture`를 사용하여 비동기 작업을 체이닝하는 예제입니다.

```java

import java.util.concurrent.CompletableFuture;

public class CompletableFutureExample {
    public static void main(String[] args) {
        CompletableFuture.supplyAsync(() -> {
            // 비동기 작업 (API 호출 등)
            return "API Result";
        }).thenApply(result -> {
            // 비동기 작업 결과를 처리
            return "Processed " + result;
        }).thenAccept(processedResult -> {
            // 최종 처리
            System.out.println(processedResult);
        }).exceptionally(ex -> {
            // 예외 처리
            System.out.println("Exception: " + ex.getMessage());
            return null;
        });
    }
}

```

### 비동기 작업 실행 객체

CompletableFuture API를 실행하면 내붝으로 API와 연결되는 객체가 생성되어 동기 또는 비동기 작업을 수행하게 된다.

---

### **결론**

`CompletableFuture`의 구조는 비동기 작업 간의 흐름과 후속 작업을 **연속적으로 처리**할 수 있게 설계되었습니다. 비동기 작업이 **결과를 반환하는지 여부**에 따라, 또는 **결과를 변환할 필요가
있는지**에 따라 다양한 방법으로 후속 작업을 처리합니다. 각 계층은 다음과 같은 역할을 담당합니다:

- **`AsyncSupply`**: **결과를 반환하는** 비동기 작업을 처리.
- **`AsyncRun`**: **결과가 없는** 비동기 작업을 처리.
- **`Completion`**: 작업 완료 후 후속 작업을 관리.
- **`UniCompletion`**: **단일 비동기 작업 완료** 후 후속 작업을 처리.
- **`UniAccept`, `UniApply`, `UniRun`**: 각각 결과를 **소비**하거나 **변환**하거나 **결과 없이 후속 작업**을 처리합니다.

이 구조는 복잡한 비동기 작업 흐름을 **간결하고 유연하게 관리**할 수 있는 강력한 패턴을 제공합니다.

## 비동기 작업 시작 supplyAsync() , runAsync()

CompletableFuture 는 비동기 작업을 생성하고 실행하는 시작 메서드로 supplyAsync() , runAsync() 메서드를 제공합니다. 비동기 작업을 실행하기 위해 내부적으로는
ForkJoinPool.commonPool() 의 스레드풀을 사용하며 선택적으로 ThreadPoolExecutor 를 사용할 수 있다.

### 첫 시작 supplyAsync(Supplier S)

- 정적 메서드로서 비동기 작업을 시작하고 작업 수행 후 결과를 반환
- 인자 : Supplier<T>
- 반환: 새로운 CompletableFuture 객체
- 실행객체: AsyncSupply 는 다음작업으로 결과를 제공하기 위해 비동기적으로 수행해야할 경우 사용할 수 있다.

```java

CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    // 비동기 작업
    return "Result";
});

String result = future.get(); // 비동기 작업이 완료될 때 까지 대기
```

```sql
   +-------------------------------------------+
   |          CompletableFuture Set            |
   |                                           |
   |   1. 새로운 CompletableFuture 객체 생성     |
   |   2. 비동기 결과를 저장                     |
   |   3. 후속 작업을 위한 체이닝 가능          |
   |                                           |
   |       +--------------------------+        |
   |       | AsyncSupply Set          |        |
   |       |                          |        |
   |       |  1. Supplier 실행        |        |
   |       |  2. 결과 생성 및 전달    |        |
   |       |  3. run() 메서드에서 수행  |        |
   |       +--------------------------+        |
   |                                           |
   +-------------------------------------------+
                   |          |          |
                결과 저장   비동기 작업    ForkJoinPool 내 실행
                   |          |          |
    +---------------------------------------------+
    |       ForkJoinPool / Executor Set           |
    |                                             |
    |  1. 기본적으로 ForkJoinPool.commonPool 사용  |
    |  2. 필요한 경우 ForkJoinWorkerThread 생성    |
    |  3. 전달된 Supplier를 비동기적으로 실행       |
    |  4. 워크 스틸링을 통해 스레드 자원 최적화    |
    +---------------------------------------------+

```

> ForJoinPool  
> 기본적으로 ForJoinPool에서 생성되는 스레드는 데몬스레드 이기때문에  
> main 스레드가 종료되면 작업이 끝나지안항도 종료된다.

### 각 구성 요소와 교차 부분의 상세 설명

### 1. `CompletableFuture` Set

- 구성 요소:
    - 새로운 `CompletableFuture` 객체 생성: `supplyAsync()` 메서드를 호출하면 내부적으로 새로운 `CompletableFuture` 객체가 생성되어 작업의 결과를 보관할 준비를
      합니다.
    - 비동기 결과를 저장: `AsyncSupply`가 비동기 작업을 수행한 후 그 결과는 이 `CompletableFuture` 객체에 저장됩니다.
    - 후속 작업을 위한 체이닝 가능: `.thenApply()`, `.thenAccept()` 등의 체이닝을 통해 비동기 작업의 결과를 바탕으로 후속 처리를 할 수 있습니다.
- 교차 영역 (`CompletableFuture` ↔ `AsyncSupply`):
    - 비동기 작업 완료 후 결과 저장: `AsyncSupply`는 `Supplier`의 작업을 비동기적으로 실행하고, 그 결과를 `CompletableFuture`에 저장합니다.

### 2. `AsyncSupply` Set (교차 영역)

- 구성 요소:
    - `Supplier` 실행: `AsyncSupply`는 `supplyAsync()`에서 전달된 `Supplier`*를 실행합니다. 이 작업은 비동기적으로 수행됩니다.
    - 결과 생성 및 전달: `Supplier`의 `get()` 메서드가 호출되어 비동기 작업의 결과를 생성합니다.
    - `run()` 메서드에서 수행: `AsyncSupply` 객체는 `run()` 메서드를 통해 작업을 실행하고, 그 결과를 `CompletableFuture`에 전달합니다.
- 교차 영역 (`AsyncSupply` ↔ `ForkJoinPool/Executor`):
    - 비동기 작업 실행: `AsyncSupply`는 `ForkJoinPool` 또는 사용자 지정 `Executor`*에서 실행됩니다. 작업이 필요할 때는 `ForkJoinWorkerThread`가 생성되어
      작업을 처리하게 됩니다.

### 3. `ForkJoinPool / Executor` Set

- 구성 요소:
    - 기본 스레드 풀 사용: 기본적으로 `ForkJoinPool.commonPool()`이 사용되며, 이를 통해 스레드 풀에서 작업을 관리합니다.
    - `ForkJoinWorkerThread` 생성: 필요 시 `ForkJoinWorkerThread`*가 생성되어 비동기 작업을 수행합니다.
    - `Supplier`의 비동기 실행: `ForkJoinPool`은 전달된 `Supplier`의 `get()` 메서드를 비동기적으로 실행합니다.
    - 워크 스틸링을 통한 스레드 자원 최적화: `ForkJoinPool`은 워크 스틸링(work-stealing) 기법을 사용해 여러 스레드가 효율적으로 작업을 나누어 처리할 수 있도록 합니다.
- 교차 영역 (`ForkJoinPool / Executor` ↔ `AsyncSupply`):
    - `AsyncSupply`의 비동기 작업 실행이 `ForkJoinPool` 내에서 수행되며, 이 과정에서 작업을 실행하기 위해 필요한 스레드가 동적으로 할당됩니다.

### 각 요소 간의 연결성과 교차의 중요성

- `CompletableFuture` ↔ `AsyncSupply`:
    - `CompletableFuture`는 `AsyncSupply`에서 생성된 비동기 작업의 결과를 수신하고, 이를 저장합니다.
    - 작업 완료 후 `CompletableFuture`는 후속 처리 작업을 체이닝할 수 있도록 합니다. 이때 결과가 `CompletableFuture`에 저장된다는 점이 핵심입니다.
- `AsyncSupply` ↔ `ForkJoinPool/Executor`:
    - `ForkJoinPool` 또는 커스텀 `Executor`가 `AsyncSupply`의 작업을 실제로 실행합니다. 비동기적인 작업의 처리는 `ForkJoinWorkerThread`에 의해 이루어지며,
      작업이 완료되면 그 결과가 `CompletableFuture`에 전달됩니다.
- `ForkJoinPool/Executor` ↔ `CompletableFuture`:
    - `ForkJoinPool`에서 비동기 작업이 실행된 후, 그 결과는 `AsyncSupply`를 통해 `CompletableFuture` 객체에 저장됩니다. 이를 통해 `CompletableFuture`는
      결과를 후속 처리 작업에 사용할 수 있게 됩니다.

### runAsync(Runnable r)

- 정적 메서드로서 비동기 작업을 시작하고 수행 후 완료
- 인자: Runnable 객체
- 반환: 새로운 CompletableFuture 객체를 반환하고 작업 결과를 저장하지는 않는다.
- 실행객체 AsyncRun

```java

import java.util.concurrent.CompletableFuture;

CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
    // 작업
});
```

작업 결과를 저장하지 않기때문에 주로 로그를 남기거나 독립적인 백그라운드 작업 또는 다음 작업에서 결과를 기다리지 않고 다른 작업을 수행해야할 경우에 사용할 수 있다.

## 내부 코드 확인 CompletableFuture.supplyAsync

```java

    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {
    return asyncSupplyStage(ASYNC_POOL, supplier);
}
```
`asyncSupplyStage` 메서드를 호출하는데 인자로 기본적으로 ASYNC_POOL 을이용한다. 별도의 스레드 풀을 지정하지 않으면 내부적으로 `ForkJoinPool` 을 사용한다.  
```java

private static final boolean USE_COMMON_POOL =
        (ForkJoinPool.getCommonPoolParallelism() > 1);

    private static final Executor ASYNC_POOL = USE_COMMON_POOL ?
        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();
```

`USE_COMMON_POOL` 은 사용자 PC의 스레드 수이다.

`asyncSupplyStage`:  
```java 
    static <U> CompletableFuture<U> asyncSupplyStage(Executor e,
                                                     Supplier<U> f) {
        if (f == null) throw new NullPointerException();
        CompletableFuture<U> d = new CompletableFuture<U>();
        e.execute(new AsyncSupply<U>(d, f));
        return d;
    }
```
`CompletableFuture<U> d = new CompletableFuture<U>();` 이코드를 보면 위에 다이어그램에서 언급했듯이 새로운 `CompletableFuture`를 생성한다.  

위에서 인자로 `ForkJoinThreadPool` 을 전달하고  `e.execute()` 메서드는 통해서  작업을 수행한다.  
  
그러면 위에 코드에서 `e.execute()` 를 호출하고 바로 새로운 `CompletableFuture` 객체를 바로 return 한다.  
  
비동기 작업임으로 내부적으로 새로운 스레드가 생성되어서 Runnable 타입의 객체의 `run()` 메서드를 호출할 것이고 run() 이라는 메서드 안에서 `new AsyncSupply<U>(d, f)` 우리가 정의한 작업이 수행될 것이다.  
그러면 `execute()` 실행 상세 과정을 확인해보자:    
ForkJoinTask:  

```java
    final int doExec() {
        int s; boolean completed;
        if ((s = status) >= 0) {
            try {
                completed = exec();
            } catch (Throwable rex) {
                s = trySetException(rex);
                completed = false;
            }
            if (completed)
                s = setDone();
        }
        return s;
    }

```
`exec()` 메서드는 추상메서드로 이 구현체인 `CompletableFuture`의 내부 클레스인 `AsyncSupply`  exe() 메서드를 호출한다.  
``` java
 static final class AsyncSupply<T> extends ForkJoinTask<Void>
        implements Runnable, AsynchronousCompletionTask {
        // 기타 로직
  public final boolean exec() { run(); return false; }
}
```
`AsyncSupply` 클레스는  ForkJoinTask를 상속받아 사용한다.  
  
이전에 `ThreadPoolExecutor` 에서는 `FutureTask` 를 사용했었다. FutureTask는 큐에 등록된 작업을 꺼내서 run() 메서드를 호출한 것과 유사하게  
ForJoinThreadPool의 ForJoinTask 역시 유사하게 동작한다.  
이 ForkJoinThreadPool 이 큐에 저장되어 있는 `AsyncSupply` 를 꺼내서 실행하고 있다는 의미이다.  

```java

        public void run() {
            CompletableFuture<T> d; Supplier<? extends T> f;
            if ((d = dep) != null && (f = fn) != null) {
                dep = null; fn = null;
                if (d.result == null) {
                    try {
                        d.completeValue(f.get());
                    } catch (Throwable ex) {
                        d.completeThrowable(ex);
                    }
                }
                d.postComplete();
            }
        }
```
`d = dep` 우리가 위에서 인자로 전달한 새로운 CompletabeFuture 객체와 `f = fn` 작업이다.  
그래서 비동기적으로 작업결과를 `d.completeValue(f.get());`, CompletableFuture객체에 설정하고 있다. 
  
  
## 비동기 결과 조작 thenApply() , thenApplyAsync()
`thenApply()`와 `thenApplyAsync()`는 Java의 `CompletableFuture` API에서 비동기 작업이 완료된 후 결과를 처리하는 메서드입니다. 둘 다 작업이 끝난 후 결과를 받아서 새로운 결과로 변환하거나 추가 작업을 수행하는 데 사용되지만, 두 메서드의 동작 방식에는 차이가 있습니다.  
  
### thenApply()  

- 인스턴스 메서드로 (비)동기적으로 작업의 결과를 반환한다. Stream 의 map() 과 유사하다.
- 인수 : `Function<T,R>` 함수를 인수로 받고 작업결과 반환
- 반환 : 새로운 `CompleteFuture<T>` 객체를 반환
- 실행객체 : UniApply
  
```java
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 50);

// 작업 완료 후 결과에 10을 더함
CompletableFuture<Integer> resultFuture = future.thenApply(result -> result + 10);

resultFuture.thenAccept(result -> System.out.println(result)); // 60 출력
```
  
### 동기 실행
```java
import java.util.concurrent.CompletableFuture;

public static void main(String[] args) {
  CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> { // Async()로 끝나는 메서드는 무조건 비동기
    System.out.println(Thread.currentThread().getName());
    return 10;
  }).thenApply(result -> { // 작업이 시작될떄 result가 완료 된 경우 메인 스레드에서 동기로 처리됨
    System.out.println(Thread.currentThread().getName());
    return 10 * 2;
  }).get();
}
```

`thenApply()`는 작업을 실행하는 시점에서 이전 작업 결과가 완료 되었다면 `메인 스레드`에서 처리되고 그렇지 않으면 이전과 동일한 스레드에서 처리한다.   
  
### 비동기 실행
```java
import java.util.concurrent.CompletableFuture;

public static void main(String[] args) {
  CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> { // Async()로 끝나는 메서드는 무조건 비동기
    System.out.println(Thread.currentThread().getName());
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    return 10;
  }).thenApply(result -> { // 작업이 시작될떄 result가 아직 완료가 안된 경우 이전과 동일한 스레드가 처리됨
    System.out.println(Thread.currentThread().getName());
    return 10 * 2;
  }).get();
}
```
  
`thenApply()`는 작업을 실행하는 시점에서 이전 작업 결과가 완료 되지 않았다면 이전과 동일한 스레드에서 처리된다.  
즉 Async 가 붙지 않는 메서드는 상활에따라서 main 스레드에서 처리하는 동기적 처리와 다른 스레드가 처리하는 비동기적 처리로 한다.

### thenApplyAsync()  

- **설명**: `thenApplyAsync()`는 비동기 작업이 완료된 후, 추가 작업을 **비동기적으로** 수행하는 메서드입니다. 이 메서드는 작업 완료 후 새로운 스레드에서 후속 작업을 실행합니다.
- **실행 방식**: `thenApplyAsync()`는 새로운 스레드에서 작업을 처리합니다. 별도의 `Executor`를 지정하지 않으면 `ForkJoinPool.commonPool`이 사용됩니다. 즉, 후속 작업이 병렬로 수행될 수 있고, 원래의 작업을 실행한 스레드에 종속되지 않습니다.

### 예시:

```java
java
코드 복사
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 50);

// 작업 완료 후 결과에 10을 더함 (비동기적으로 처리)
CompletableFuture<Integer> resultFuture = future.thenApplyAsync(result -> result + 10);

resultFuture.thenAccept(result -> System.out.println(result)); // 60 출력

```

위 코드에서 `thenApplyAsync()`는 비동기 작업이 완료된 후 **새로운 스레드**에서 결과에 10을 더하는 작업을 처리합니다.

###  `thenApply()`와 `thenApplyAsync()` 차이점

| **특징** | **thenApply()** | **thenApplyAsync()** |
| --- | --- | --- |
| **실행 방식** | 호출된 스레드에서 동기적으로 실행 | 새로운 스레드에서 비동기적으로 실행 |
| **스레드 풀** | 추가 스레드 생성 없음 | 기본적으로 `ForkJoinPool.commonPool` 사용 |
| **사용 시기** | 추가 작업이 상대적으로 가볍고 스레드 전환이 필요 없을 때 사용 | 추가 작업이 비동기적으로 처리되어야 하거나 병렬 처리해야 할 때 사용 |
| **성능 고려** | 성능에 영향을 덜 미침 | 새로운 스레드를 생성하기 때문에 약간의 오버헤드 발생 |

### 4. `Executor`를 지정하는 `thenApplyAsync()`

비동기 작업을 실행할 때 기본 `ForkJoinPool` 대신 사용자 정의 `Executor`를 지정할 수도 있습니다.

```java
Executor executor = Executors.newFixedThreadPool(2);
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 50);

// 사용자 정의 Executor로 비동기 처리
CompletableFuture<Integer> resultFuture = future.thenApplyAsync(result -> result + 10, executor);

resultFuture.thenAccept(result -> System.out.println(result));

```

위 예시에서 `thenApplyAsync()`는 사용자 정의 `Executor`를 통해 비동기 작업을 처리합니다.  
  
### 실행흐름

`CompletableFuture`의 `thenApply()`와 `thenApplyAsync()`는 내부적으로 `UniApply`라는 스택에 `CompletableFuture`를 담아 실행 흐름을 관리합니다. 이를 통해 비동기 작업 후 결과 처리를 위한 작업들이 쌓이게 되며, 비동기 작업이 완료될 때 적절한 순서로 실행됩니다.

`CompletableFuture`는 복잡한 비동기 작업을 다루기 위해 다양한 콜백과 작업을 스택에 저장하고, 작업이 완료되면 순차적으로 실행하는 구조를 가지고 있습니다. 내부적으로 `thenApply()`와 `thenApplyAsync()`는 `UniApply`라는 클래스를 사용하여 이러한 동작을 관리합니다.

### `thenApply()` 내부 동작 흐름

`thenApply()`는 비동기 작업이 완료된 후 추가 작업을 **동기적**으로 처리하는 방식입니다. `CompletableFuture` 내부에서 `thenApply()`는 `UniApply`라는 스택에 `CompletableFuture`와 추가 작업을 담습니다. 비동기 작업이 완료되면 스택에 있는 후속 작업이 실행됩니다.

`thenApply()` 메서드의 동작을 요약하면 다음과 같은 흐름입니다:

1. 새로운 `CompletableFuture` 객체를 생성합니다.
2. 비동기 작업이 완료되면 해당 작업을 처리하는 `UniApply` 작업을 스택에 추가합니다.
3. 완료된 작업의 결과를 바탕으로 추가 작업을 처리합니다.

### `thenApply()`의 내부 코드 흐름 (개략적):

```java
public <U> CompletableFuture<U> thenApply(Function<? super T, ? extends U> fn) {
    // 새로운 CompletableFuture 생성
    CompletableFuture<U> dst = new CompletableFuture<>();
    // UniApply 작업을 스택에 추가
    if (fn == null) throw new NullPointerException();
    UniApply<T, U> action = new UniApply<>(this, dst, fn);
    // 스택을 관리하고, 완료된 작업을 처리함
    pushCompletion(action);
    // 작업이 완료되면 후속 작업 실행
    action.tryFire(SYNC); // 동기적으로 실행
    return dst;
}

```

여기서 `UniApply`는 비동기 작업이 완료되면 실행될 후속 작업을 관리하는 클래스입니다. `pushCompletion()`을 통해 스택에 작업이 추가되고, 완료된 작업을 동기적으로 실행(`tryFire(SYNC)`)하게 됩니다.

### `thenApplyAsync()` 내부 동작 흐름

`thenApplyAsync()`는 비동기 작업이 완료된 후 추가 작업을 **비동기적**으로 처리합니다. 이는 `thenApply()`와 유사하지만, 후속 작업을 새로운 스레드에서 처리하도록 설계되었습니다. 내부적으로 `thenApplyAsync()`도 `UniApply`를 사용하여 후속 작업을 스택에 추가하고, 별도의 스레드 풀에서 비동기 작업을 처리합니다.

### `thenApplyAsync()`의 내부 코드 흐름 (개략적):

```java
public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends U> fn) {
    return thenApplyAsync(fn, ForkJoinPool.commonPool());
}

public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends U> fn, Executor executor) {
    // 새로운 CompletableFuture 생성
    CompletableFuture<U> dst = new CompletableFuture<>();
    if (fn == null || executor == null) throw new NullPointerException();
    UniApply<T, U> action = new UniApply<>(this, dst, fn);
    // 스택에 비동기 작업을 추가
    pushCompletion(action);
    // 비동기적으로 후속 작업을 실행
    executor.execute(() -> action.tryFire(ASYNC));
    return dst;
}

```

`thenApplyAsync()`는 `Executor`를 사용하여 후속 작업을 **비동기적**으로 처리합니다. 만약 `Executor`를 지정하지 않으면 기본적으로 `ForkJoinPool.commonPool()`이 사용됩니다. 후속 작업은 스레드 풀에서 별도로 실행되며, 작업 완료 후 비동기적 흐름에 따라 `UniApply`가 실행됩니다.

### `UniApply` 클래스

`UniApply`는 `CompletableFuture` 내부에서 후속 작업을 정의하는 클래스입니다. `UniApply`는 `CompletableFuture`의 작업이 완료되면 특정 작업을 실행하기 위한 논리를 담고 있습니다. `tryFire()` 메서드를 통해 동기적 또는 비동기적 작업을 실행합니다.

### `UniApply` 클래스 개략적 구현:

```java
static final class UniApply<T, U> extends UniCompletion<T, U> {
    Function<? super T, ? extends U> fn;

    UniApply(CompletableFuture<T> src, CompletableFuture<U> dst, Function<? super T, ? extends U> fn) {
        super(src, dst);
        this.fn = fn;
    }

    final CompletableFuture<U> tryFire(int mode) {
        CompletableFuture<T> src = this.src;
        CompletableFuture<U> dst = this.dst;
        if (src == null || dst == null || fn == null) return null;
        // 결과를 처리하고 후속 작업을 수행
        if (src.result != null) {
            U value;
            try {
                value = fn.apply(src.result);
            } catch (Throwable ex) {
                dst.completeExceptionally(ex);
                return null;
            }
            dst.complete(value);
        }
        return dst;
    }
}

```

`UniApply` 클래스는 주어진 함수(`fn`)를 통해 후속 작업을 처리합니다. `src.result`는 원본 `CompletableFuture`의 결과이며, 이 결과를 바탕으로 후속 작업을 수행하고 새로운 결과를 `dst.complete()`로 설정합니다.

### 전체 동작 흐름 요약

1. **CompletableFuture 생성**: 비동기 작업을 수행하는 `CompletableFuture`가 생성됩니다.
2. **thenApply()/thenApplyAsync() 호출**: 비동기 작업이 완료된 후 처리할 작업을 정의하는 `thenApply()` 또는 `thenApplyAsync()`가 호출됩니다.
3. **UniApply 스택에 추가**: 내부적으로 `UniApply`가 생성되고, `CompletableFuture` 스택에 추가됩니다.
4. **작업 완료 후 후속 작업 실행**:
  - **thenApply()**: 동기적으로 후속 작업이 실행됩니다. 작업 완료 시, `tryFire(SYNC)`가 호출되어 후속 작업이 동기적으로 처리됩니다.
  - **thenApplyAsync()**: 비동기적으로 후속 작업이 실행됩니다. 작업 완료 시, `tryFire(ASYNC)`가 호출되어 다른 스레드에서 후속 작업이 처리됩니다.
5. **후속 작업 처리**: `src.result`에서 결과를 가져와 후속 작업을 수행한 후, 새로운 `CompletableFuture`에 그 결과를 저장합니다.
  
  
### 내부 코드
저번에 이어서 AsyncSupply run() 메서드를 보면
```java
        public void run() {
            CompletableFuture<T> d; Supplier<? extends T> f;
            if ((d = dep) != null && (f = fn) != null) {
                dep = null; fn = null;
                if (d.result == null) {
                    try {
                        d.completeValue(f.get());
                    } catch (Throwable ex) {
                        d.completeThrowable(ex);
                    }
                }
                d.postComplete();
            }
        }

```
  

`d.postComplete():`  
```java
    final void postComplete() {
        /*
         * On each step, variable f holds current dependents to pop
         * and run.  It is extended along only one path at a time,
         * pushing others to avoid unbounded recursion.
         */
        CompletableFuture<?> f = this; Completion h;
        while ((h = f.stack) != null || // stack 있으면 모두 실행
               (f != this && (h = (f = this).stack) != null)) {
            CompletableFuture<?> d; Completion t;
            if (STACK.compareAndSet(f, h, t = h.next)) {
                if (t != null) {
                    if (f != this) {
                        pushStack(h);
                        continue;
                    }
                    NEXT.compareAndSet(h, t, null); // try to detach
                }
                f = (d = h.tryFire(NESTED)) == null ? this : d;
            }
        }
    }
```
해당 메서드는 간단하게 말해서 completeFuture 안에 있는 stack이 있으면 안에 있는 stack 을 모두 실행하는 코드이다.  

`h.tryFire`구문은 우리가 코드에서 연속적으로 호출하는 thenApply나 thenApplyAsync가 있으면 그 코드를 실행한다고 보면된다.  
여기서 비동기를 실행할지를 판단한다.
```java
        final CompletableFuture<V> tryFire(int mode) {
            CompletableFuture<V> d; CompletableFuture<T> a;
            Object r; Throwable x; Function<? super T,? extends V> f;
            if ((a = src) == null || (r = a.result) == null
                || (d = dep) == null || (f = fn) == null)
                return null;
            tryComplete: if (d.result == null) {
                if (r instanceof AltResult) {
                    if ((x = ((AltResult)r).ex) != null) {
                        d.completeThrowable(x, r);
                        break tryComplete;
                    }
                    r = null;
                }
                try {
                    if (mode <= 0 && !claim())
                        return null;
                    else {
                        @SuppressWarnings("unchecked") T t = (T) r;
                        d.completeValue(f.apply(t));
                    }
                } catch (Throwable ex) {
                    d.completeThrowable(ex);
                }
            }
            src = null; dep = null; fn = null;
            return d.postFire(a, mode);
        }
```
  
thenAPply 이면 새로운 스레드를 생성하지 않고 바로 return
```java
    try {
                    if (mode <= 0 && !claim())
                        return null;
                    else {
                        @SuppressWarnings("unchecked") T t = (T) r;
                        d.completeValue(f.apply(t));
                    }
                } catch (Throwable ex) {
                    d.completeThrowable(ex);
                }
            }

```
그리고 마지막에 `d.postFire(a, mode);` 를통해서 스택에 다음 작업이 있는지 확인한다.  
```java
    final CompletableFuture<T> postFire(CompletableFuture<?> a, int mode) {
        if (a != null && a.stack != null) {
            Object r;
            if ((r = a.result) == null)
                a.cleanStack();
            if (mode >= 0 && (r != null || a.result != null))
                a.postComplete();
        }
        if (result != null && stack != null) {
            if (mode < 0)
                return this;
            else
                postComplete();
        }
        return null;
    }
```
  
### thenAccept() , thenRun()
`thenAccept()`와 `thenRun()`는 `CompletableFuture`에서 후속 작업을 정의하는 메서드로, 둘 다 비동기 작업이 완료된 후 수행될 작업을 설정하는 역할을 합니다. 이 메서드들은 `thenApply()`와 유사한 방식으로 작동하지만,  
  
각 메서드의 주요 목적과 반환 타입이 다릅니다. 특히 `thenAccept()`와 `thenRun()`는 처리 후 값을 반환하지 않는 특징이 있습니다.

### thenAccept() / thenAcceptAsync

`thenAccept()`는 `thenApply()`와 비슷하게 완료된 작업의 결과를 인수로 받아 특정 작업을 수행하지만, 결과를 반환하지 않고 후속 작업을 수행하는 것이 목적입니다.

- **인수**: `Consumer<T>` 타입을 인수로 받으며, 이는 완료된 작업의 결과를 처리하는 데 사용됩니다.
- **반환값**: `CompletableFuture<Void>`를 반환합니다. 이는 후속 작업이 특정 결과를 반환하지 않는다는 의미입니다.
- **비동기 실행**: `thenAcceptAsync()`를 사용하면 비동기적으로 실행되며, 기본적으로 `ForkJoinPool.commonPool()`을 사용합니다. 별도의 `Executor`를 전달해 실행 방식을 커스터마이즈할 수도 있습니다.

### 예제

```java
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 50);

// 작업 완료 후 결과를 출력 (결과를 소비만 함)
CompletableFuture<Void> resultFuture = future.thenAccept(result -> System.out.println("Result: " + result));

```

위 코드에서 `thenAccept()`는 작업이 완료된 후 결과를 출력하는 `Consumer`를 실행하고, 후속 결과는 반환하지 않습니다. `thenAcceptAsync()`를 사용하면 비동기적으로 처리됩니다.

`thenAcceptAsync()`는 이전 작업 결과와 상관없이 무조건 풀 스레드에서 비동기 처리가되고 풀 스레드는 이전과 동일한 스레드 혹은 새롭게 생성된 스레드가 될 수 있다.  
  
반면에 `thenAccept()`는 이전 작업 결과가 완료 되었다면 메인 스레드에서 동기 처리되고 그렇지 않으면 이전과 동일한 스레드에서 비동기 처리된다.  

---

### thenRun() / thenRunAsync

`thenRun()`는 이전 작업의 결과에 의존하지 않고, 완료된 후 단순히 새로운 작업을 실행하는 것이 목적입니다. 이 메서드는 실행 후 결과를 반환하지 않고, `Runnable`로 정의된 작업을 수행합니다.

- **인수**: `Runnable` 타입의 작업을 인수로 받으며, 이는 완료된 작업과 상관없이 단순히 실행될 코드입니다.
- **반환값**: `CompletableFuture<Void>`를 반환합니다. 후속 작업의 결과가 필요하지 않을 때 유용하게 사용할 수 있습니다.
- **비동기 실행**: `thenRunAsync()`를 사용하면 비동기적으로 실행되며, 기본적으로 `ForkJoinPool.commonPool()`을 사용합니다. 별도의 `Executor`를 전달해 실행 방식을 변경할 수도 있습니다.

### 예제

```java
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 50);

// 작업 완료 후 별도의 로그 출력 (결과는 필요하지 않음)
CompletableFuture<Void> resultFuture = future.thenRun(() -> System.out.println("Task completed!"));

```

위 코드에서 `thenRun()`은 이전 작업의 결과와 상관없이, 작업이 완료되면 단순히 "Task completed!"를 출력합니다. `thenRunAsync()`를 사용하면 비동기적으로 처리됩니다.

---

### thenAccept()와 thenRun() 차이점 요약

| **특징** | **thenAccept()** | **thenRun()** |
| --- | --- | --- |
| **인수** | `Consumer<T>` | `Runnable` |
| **이전 작업의 결과** | 결과를 사용 | 결과와 상관없이 실행 |
| **반환값** | `CompletableFuture<Void>` | `CompletableFuture<Void>` |
| **사용 예** | 결과에 기반하여 작업 수행 | 결과와 관계없이 별도 작업 수행 |

---

### thenAccept()의 내부 동작

`thenAccept()`는 완료된 작업의 결과를 `Consumer`로 소비하며, `thenApply()`와 유사하게 내부적으로 `UniAccept`라는 클래스를 사용하여 후속 작업을 관리합니다. `UniAccept`는 `UniApply`와 비슷한 구조로, `tryFire()` 메서드를 통해 후속 작업을 스택에 추가하고 실행합니다.

### 내부 코드 흐름 (개략적):

```java
public <U> CompletableFuture<Void> thenAccept(Consumer<? super T> action) {
    if (action == null) throw new NullPointerException();
    CompletableFuture<Void> dst = new CompletableFuture<>();
    UniAccept<T> completion = new UniAccept<>(this, dst, action);
    pushCompletion(completion);
    completion.tryFire(SYNC);
    return dst;
}

```

- `thenAccept()`는 `CompletableFuture`를 반환합니다.
- 내부적으로 `UniAccept` 객체가 생성되며, `pushCompletion()`을 통해 스택에 추가됩니다.
- 후속 작업은 `tryFire()` 메서드를 통해 실행되며, 동기적으로(`SYNC` 모드) 또는 비동기적으로 실행됩니다.

---

### thenRun()의 내부 동작

`thenRun()`는 결과와 관계없이 단순히 `Runnable`을 실행하기 위한 `UniRun` 클래스를 사용합니다. `thenAccept()`와 유사한 방식으로 동작하지만, 이전 결과를 필요로 하지 않는 점에서 차이가 있습니다.

### 내부 코드 흐름 (개략적):

```java
public CompletableFuture<Void> thenRun(Runnable action) {
    if (action == null) throw new NullPointerException();
    CompletableFuture<Void> dst = new CompletableFuture<>();
    UniRun completion = new UniRun(this, dst, action);
    pushCompletion(completion);
    completion.tryFire(SYNC);
    return dst;
}

```

- `thenRun()`은 `CompletableFuture`를 반환합니다.
- `UniRun` 객체가 생성되어 `pushCompletion()`을 통해 스택에 추가됩니다.
- `tryFire()`를 통해 동기적으로(`SYNC` 모드) 또는 비동기적으로 후속 작업이 실행됩니다.

---

### UniAccept와 UniRun 클래스

- **UniAccept**: `UniAccept`는 `Consumer`를 통해 완료된 작업의 결과를 소비하고, 후속 작업을 수행하는 역할을 합니다. `tryFire()` 메서드가 호출될 때 `Consumer`가 실행됩니다.

```java
static final class UniAccept<T> extends UniCompletion<T, Void> {
    Consumer<? super T> fn;

    UniAccept(CompletableFuture<T> src, CompletableFuture<Void> dst, Consumer<? super T> fn) {
        super(src, dst);
        this.fn = fn;
    }

    final CompletableFuture<Void> tryFire(int mode) {
        CompletableFuture<Void> d; CompletableFuture<T> a;
        Object r;
        if ((a = src) != null && (r = a.result) != null && (d = dep) != null) {
            if (mode <= 0 && !claim())
                return null;
            if (d.result == null) {
                try {
                    @SuppressWarnings("unchecked") T t = (T) r;
                    fn.accept(t);
                    d.complete(null);
                } catch (Throwable ex) {
                    d.completeExceptionally(ex);
                }
            }
            src = null; dep = null; fn = null;
            return d.postFire(a, mode);
        }
        return null;
    }
}

```

- **UniRun**: `UniRun`은 `Runnable`을 실행하여 후속 작업을 수행하는 역할을 합니다. `tryFire()` 메서드가 호출되면 `Runnable`이 실행됩니다.

```java
static final class UniRun extends UniCompletion<Object, Void> {
    Runnable fn;

    UniRun(CompletableFuture<?> src, CompletableFuture<Void> dst, Runnable fn) {
        super(src, dst);
        this.fn = fn;
    }

    final CompletableFuture<Void> tryFire(int mode) {
        CompletableFuture<Void> d;
        if ((d = dep) != null) {
            if (mode <= 0 && !claim())
                return null;
            if (d.result == null) {
                try {
                    fn.run();
                    d.complete(null);
                } catch (Throwable ex) {
                    d.completeExceptionally(ex);
                }
            }
            dep = null; fn = null;
            return d.postFire(null, mode);
        }
        return null;
    }
}

```

- `UniAccept`와 `UniRun`은 모두 `tryFire()` 메서드를 통해 동기적으로(`SYNC`) 또는 비동기적으로(`ASYNC`) 후속 작업을 실행합니다.
- 후속 작업이 완료되면 `postFire()`를 통해 스택에 있는 다음 작업이 있는지 확인하고, 존재한다면 이를 실행합니다.

---
  
### CompleteFuture의 NULL 값처리
`CompletableFuture`의 내부 동작에서 `null` 값 처리는 중요한 부분입니다. `CompletableFuture`는 작업 결과가 `null`인 경우와 예외가 발생한 경우를 구분하여 처리하며, 이를 위해 `AltResult` 클래스를 사용합니다.

### AltResult 클래스와 Null 값 처리

`AltResult`는 `CompletableFuture`의 내부 클래스 중 하나로, **null 값 또는 예외가 발생한 작업의 결과를 캡슐화**하는 역할을 합니다. 일반적으로 `CompletableFuture`는 작업 결과로 `null` 값을 직접 저장하지 않고, 대신 `AltResult`를 사용하여 `null` 값을 감쌉니다. 예외도 마찬가지로 `AltResult`를 사용하여 캡슐화합니다.

이렇게 `AltResult`로 처리하는 이유는 `null` 값과 예외가 동일하게 `result` 필드에 저장되기 때문에, 내부 로직에서 이를 명확히 구분하기 위함입니다.

### AltResult 구조

`AltResult`는 예외가 발생한 경우 해당 예외를 담고, 작업의 결과가 `null`인 경우에는 예외 필드가 `null`로 설정됩니다. `AltResult`의 구조는 대략 다음과 같습니다:

```java
static final class AltResult {
    final Throwable ex; // 예외 또는 null 값

    AltResult(Throwable x) { this.ex = x; }
}

```

- `ex`: 예외 정보를 저장하는 필드입니다. 작업이 정상적으로 완료되었으나 결과가 `null`인 경우 `ex`는 `null`이 됩니다.
- 작업에서 예외가 발생한 경우에는 `ex`에 예외 객체가 저장됩니다.

### AltResult의 Null 값 처리 방식

1. **결과가 null인 경우**:
  - `CompletableFuture`가 완료된 작업의 결과가 `null`이라면, `AltResult`의 `ex` 필드를 `null`로 설정하여 `AltResult` 인스턴스로 캡슐화합니다.
  - 이를 통해 내부적으로 `null` 값을 가질 때와 작업 결과가 정상적으로 완료되었을 때를 구분할 수 있습니다.
2. **예외가 발생한 경우**:
  - 작업 도중 예외가 발생하면 `AltResult`의 `ex` 필드에 해당 예외 객체를 저장합니다.
  - 이렇게 함으로써 `CompletableFuture`는 작업 실패와 성공을 구분할 수 있으며, 예외가 발생한 경우 후속 작업에서 예외 처리를 할 수 있습니다.

### AltResult의 내부 사용 예시

예를 들어, `CompletableFuture`의 후속 작업이 실행되는 `tryFire()` 메서드에서 `AltResult`가 어떻게 사용되는지 살펴보겠습니다.

```java
final CompletableFuture<V> tryFire(int mode) {
    CompletableFuture<V> d;
    CompletableFuture<T> a;
    Object r;
    Throwable x;
    if ((a = src) != null && (r = a.result) != null && (d = dep) != null) {
        tryComplete: if (d.result == null) {
            if (r instanceof AltResult) { // AltResult 확인
                if ((x = ((AltResult) r).ex) != null) { // 예외 발생 시
                    d.completeThrowable(x, r);
                    break tryComplete;
                }
                r = null; // 예외가 없으면 결과를 null로 간주
            }
            try {
                @SuppressWarnings("unchecked") T t = (T) r;
                d.completeValue(fn.apply(t));
            } catch (Throwable ex) {
                d.completeThrowable(ex);
            }
        }
        src = null; dep = null; fn = null;
        return d.postFire(a, mode);
    }
    return null;
}

```

위 코드에서 `tryFire()`는 작업 결과가 `AltResult`인지 확인하고, 두 가지 경우를 처리합니다.

1. **`AltResult`에 예외가 포함된 경우**:
  - 예외를 확인하고, 후속 `CompletableFuture`를 예외 상태로 설정합니다. (`completeThrowable()` 호출)
2. **`AltResult`에 예외가 없고 결과가 `null`인 경우**:
  - 이 경우 `AltResult`는 `null` 값을 나타내기 위한 객체로 사용됩니다.
  - `r`을 `null`로 설정하여 후속 작업이 `null` 값을 받을 수 있도록 합니다.

### AltResult 사용의 이점

- **`null` 값과 예외 구분**: `AltResult`를 통해 `null` 값과 예외를 구분하여 처리할 수 있습니다. 이를 통해 후속 작업에서 오류와 정상적인 `null`을 명확히 구분하여 처리할 수 있습니다.
- **예외 캡슐화**: 예외가 발생한 경우, 후속 작업에서 예외 정보를 안전하게 전달할 수 있습니다. `AltResult`가 예외를 포함하고 있으면, 후속 `CompletableFuture`가 해당 예외를 감지하고 `exceptionally()`, `handle()`, `whenComplete()` 등으로 예외 처리를 할 수 있습니다.

### AltResult와 후속 작업 예제

아래 예제에서는 `CompletableFuture` 작업에서 `null` 값과 예외가 발생한 경우 각각 어떻게 후속 작업에서 처리되는지 보여줍니다.

```java
import java.util.concurrent.CompletableFuture;

public class AltResultExample {
    public static void main(String[] args) {
        // 정상 완료된 작업의 결과가 null인 경우
        CompletableFuture<Void> nullResultFuture = CompletableFuture.supplyAsync(() -> null)
            .thenAccept(result -> {
                if (result == null) {
                    System.out.println("Result is null");
                }
            });

        // 예외가 발생한 경우
        CompletableFuture<Void> exceptionFuture = CompletableFuture.supplyAsync(() -> {
            throw new RuntimeException("Error occurred");
        }).exceptionally(ex -> {
            System.out.println("Caught exception: " + ex.getMessage());
            return null;
        });
    }
}

```

- 첫 번째 `nullResultFuture`에서는 `CompletableFuture`의 결과가 `null`이기 때문에 `AltResult`가 `ex` 필드가 `null`인 상태로 생성됩니다. 후속 작업에서 결과가 `null`인지 체크하고, `null` 값을 처리할 수 있습니다.
- 두 번째 `exceptionFuture`에서는 예외가 발생했기 때문에 `AltResult`가 예외 객체를 포함하게 됩니다. 이후 `exceptionally()`를 통해 후속 작업에서 예외를 처리할 수 있습니다.

### 결론

`AltResult`는 `CompletableFuture`에서 **null 값**과 **예외**를 안전하게 처리하기 위해 사용되는 내부 클래스입니다. `null` 값을 `AltResult`로 캡슐화하여 작업이 `null`로 완료된 경우와 예외가 발생한 경우를 구분하여 처리할 수 있으며, 이를 통해 후속 작업에서 `null` 값과 예외를 명확하게 구분할 수 있게 됩니다. `AltResult`를 통해 `CompletableFuture`는 작업의 정상 종료, null 반환, 예외 발생 등의 다양한 상황을 유연하게 처리할 수 있습니다.  
  
즉 `CompletableFuture`의 결과는 반드시 객체 타입으로 매핑되어서 저장이 된다. 정상적인 경우 뿐만아니라 NULL 이나 예외또한 객체타입으로 매핑해서 저장된다.
  
  
---   

### 전체 흐름 요약

1. `thenAccept()`와 `thenRun()`은 `CompletableFuture`에 후속 작업을 정의하는 메서드로, 각각 결과를 소비하거나 단순 작업을 실행합니다.
2. 내부적으로 `UniAccept`와 `UniRun` 클래스를 사용하여 후속 작업을 관리하며, 작업이 완료되면 `tryFire()`가 호출됩니다.
3. `thenAccept()`는 이전 작업 결과를 인수로 받아 처리하는 `Consumer`를 수행하고, `thenRun()`은 결과와 관계없이 `Runnable`을 실행합니다.
4. `postFire()` 메서드를 통해 스택에 남은 작업이 있다면 계속 실행합니다.


## **`thenCompose()`와 `thenComposeAsync()`**

`thenCompose()`와 `thenComposeAsync()`는 Java의 `CompletableFuture` API에서 **연속적인 비동기 작업**을 처리하기 위한 메서드입니다. 이전 작업의 결과를 바탕으로 새로운 비동기 작업을 실행하는 방식으로 작동하며, 작업 간의 **종속 관계**를 명확하게 정의할 수 있습니다.

---

### **1. `thenCompose()`**

### **1.1 정의**

- `thenCompose()`는 이전 작업의 결과를 사용하여 **새로운 비동기 작업**을 수행하고, 그 결과를 반환합니다.
- **동기적 실행**: 기본적으로 동일한 스레드에서 작업이 실행됩니다. 단, 이전 작업이 비동기적으로 실행된 경우, 해당 작업을 실행한 스레드에서 이어서 실행됩니다.

### **1.2 주요 특징**

- **연속적인 비동기 작업**: 작업 간의 순차적인 처리를 위해 사용됩니다.
- **새로운 비동기 작업 반환**: 이전 작업 결과를 바탕으로 새 `CompletableFuture`를 생성하고 반환합니다.
- **동기적 처리**: 후속 작업이 같은 스레드에서 실행됩니다.

### **1.3 예제**

```java
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Hello");

CompletableFuture<String> future2 = future1.thenCompose(result ->
    CompletableFuture.supplyAsync(() -> result + " World")
);

future2.thenAccept(System.out::println); // 출력: Hello World

```

### **1.4 실행 흐름**

1. `future1`에서 `"Hello"` 문자열을 반환합니다.
2. `thenCompose()`는 결과 `"Hello"`를 인수로 받아 새로운 비동기 작업을 생성하고 실행합니다.
3. 새 비동기 작업은 `"Hello World"`를 반환하며, `future2`의 결과로 저장됩니다.

---

### **2. `thenComposeAsync()`**

### **2.1 정의**

- `thenComposeAsync()`는 이전 작업 결과를 사용하여 **새로운 비동기 작업**을 수행하지만, 이를 **별도의 스레드에서 비동기적으로 실행**합니다.
- 기본적으로 `ForkJoinPool.commonPool`을 사용하며, 커스텀 `Executor`를 지정할 수도 있습니다.

### **2.2 주요 특징**

- **새로운 스레드에서 비동기 처리**: `ForkJoinPool` 또는 지정된 `Executor`에서 작업을 실행합니다.
- **비동기 처리 보장**: 후속 작업이 항상 별도의 스레드에서 실행됩니다.

### **2.3 예제**

```java
Executor executor = Executors.newFixedThreadPool(2);

CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Hello");

CompletableFuture<String> future2 = future1.thenComposeAsync(result ->
    CompletableFuture.supplyAsync(() -> result + " World", executor)
);

future2.thenAccept(System.out::println); // 출력: Hello World

```

### **2.4 실행 흐름**

1. `future1`에서 `"Hello"` 문자열을 반환합니다.
2. `thenComposeAsync()`는 결과 `"Hello"`를 인수로 받아 새로운 비동기 작업을 생성합니다.
3. 후속 작업은 지정된 `Executor`(혹은 기본 `ForkJoinPool`)에서 실행되며, `"Hello World"`를 반환합니다.

---

### **3. `thenCompose()`와 `thenComposeAsync()` 비교**

| **특징** | **thenCompose()** | **thenComposeAsync()** |
| --- | --- | --- |
| **실행 방식** | 동일 스레드에서 동기적으로 실행 | 별도의 스레드에서 비동기적으로 실행 |
| **스레드 풀** | 동일 스레드 또는 이전 작업의 스레드 | 기본 `ForkJoinPool` 또는 지정된 `Executor` |
| **사용 시기** | 작업이 가볍고 스레드 전환이 필요 없을 때 | 작업이 무겁거나 병렬 실행이 필요한 경우 |

---

## **`thenCombine()`와 `thenCombineAsync()`**

`thenCombine()`과 `thenCombineAsync()`는 **두 개의 독립적인 비동기 작업**의 결과를 조합하여 새로운 결과를 생성하는 데 사용됩니다. 두 작업이 모두 완료된 후에 후속 작업이 실행됩니다.

---

### **1. `thenCombine()`**

### **1.1 정의**

- `thenCombine()`는 **두 개의 비동기 작업 결과를 결합**하여 새로운 작업을 실행합니다.
- **동기적 실행**: 두 작업이 모두 완료된 후, 후속 작업은 동일한 스레드에서 실행됩니다.

### **1.2 주요 특징**

- **독립적인 작업 결합**: 두 작업의 결과를 받아 새로운 작업을 생성합니다.
- **동기적 처리**: 후속 작업이 같은 스레드에서 실행됩니다.

### **1.3 예제**

```java
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "World");

CompletableFuture<String> combinedFuture = future1.thenCombine(future2, (result1, result2) -> result1 + " " + result2);

combinedFuture.thenAccept(System.out::println); // 출력: Hello World

```

### **1.4 실행 흐름**

1. `future1`과 `future2`는 독립적으로 실행됩니다.
2. 두 작업이 완료되면 `thenCombine()`이 두 결과를 받아 후속 작업을 실행합니다.
3. 후속 작업에서 `"Hello World"`가 반환됩니다.

---

### **2. `thenCombineAsync()`**

### **2.1 정의**

- `thenCombineAsync()`는 두 작업 결과를 결합하는 방식은 같지만, **후속 작업이 별도의 스레드에서 비동기적으로 실행**됩니다.

### **2.2 주요 특징**

- **비동기 후속 작업**: 후속 작업은 `ForkJoinPool` 또는 지정된 `Executor`에서 실행됩니다.

### **2.3 예제**

```java
Executor executor = Executors.newFixedThreadPool(2);

CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "World");

CompletableFuture<String> combinedFuture = future1.thenCombineAsync(future2,
    (result1, result2) -> result1 + " " + result2, executor);

combinedFuture.thenAccept(System.out::println); // 출력: Hello World

```

### **2.4 실행 흐름**

1. `future1`과 `future2`는 독립적으로 실행됩니다.
2. 두 작업이 완료되면 `thenCombineAsync()`가 두 결과를 받아 후속 작업을 생성합니다.
3. 후속 작업은 지정된 `Executor`에서 실행되며, `"Hello World"`를 반환합니다.

---

### **3. `thenCombine()`와 `thenCombineAsync()` 비교**

| **특징** | **thenCombine()** | **thenCombineAsync()** |
| --- | --- | --- |
| **실행 방식** | 동일 스레드에서 동기적으로 실행 | 별도의 스레드에서 비동기적으로 실행 |
| **스레드 풀** | 동일 스레드 또는 이전 작업의 스레드 | 기본 `ForkJoinPool` 또는 지정된 `Executor` |
| **사용 시기** | 후속 작업이 가볍고 스레드 전환이 필요 없을 때 | 후속 작업이 무겁거나 병렬 실행이 필요한 경우 |

---

## **4. 내부 동작 요약**

### **4.1 `thenCompose()`의 내부 흐름**

- 이전 작업 결과를 받아 새로운 비동기 작업(`CompletableFuture`)을 생성.
- `UniCompose`를 사용하여 후속 작업을 관리하며, 완료된 작업의 결과를 기반으로 새로운 작업을 실행.

```java
public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn) {
    if (fn == null) throw new NullPointerException();
    CompletableFuture<U> dst = new CompletableFuture<>();
    UniCompose<T, U> action = new UniCompose<>(this, dst, fn);
    pushCompletion(action);
    action.tryFire(SYNC);
    return dst;
}

```

---

### **4.2 `thenCombine()`의 내부 흐름**

- 두 작업의 결과를 결합하여 새로운 결과를 생성.
- `BiCompletion`을 사용하여 두 작업의 결과를 결합하고 후속 작업을 실행.

```java
public <U, V> CompletableFuture<V> thenCombine(
        CompletionStage<? extends U> other,
        BiFunction<? super T, ? super U, ? extends V> fn) {
    if (other == null || fn == null) throw new NullPointerException();
    CompletableFuture<U> o = (CompletableFuture<U>) other;
    CompletableFuture<V> dst = new CompletableFuture<>();
    BiApply<T, U, V> action = new BiApply<>(this, o, dst, fn);
    pushCompletion(action);
    action.tryFire(SYNC);
    return dst;
}

```

---

### **5. 요약**

- `thenCompose()`와 `thenCombine()`은 **비동기 작업 간의 의존 관계**를 정의하는 데 유용합니다.
- `thenCompose()`는 이전 작업 결과를 기반으로 새 작업을 생성하며, **연속적인 비동기 작업**에 적합합니다.
- `thenCombine()`은 독립적인 두 작업 결과를 결합하며, **병렬 비동기 작업**을 결합하는 데 유용합니다.
- `Async` 버전은 후속 작업을 **별도의 스레드**에서 실행하여 병렬성을 향상시킵니다.


### **allOf()와 anyOf()**

`CompletableFuture`에서 제공하는 `allOf()`와 `anyOf()`는 **여러 비동기 작업**을 병렬로 실행하고 이를 조합하여 **동시성 제어**를 수행하는 메서드입니다.

---

## **1. allOf()**

### **1.1 정의**

- `allOf()`는 **여러 비동기 작업이 모두 완료**될 때까지 기다리는 메서드입니다.
- **반환값**: `CompletableFuture<Void>`를 반환하며, 결과 값 자체는 포함하지 않습니다.
- **용도**: 여러 비동기 작업의 완료 여부를 모니터링하거나, 모든 작업이 완료된 후 후속 작업을 실행할 때 사용합니다.

---

### **1.2 주요 특징**

- **동시 실행**: 전달된 모든 작업이 동시에 실행됩니다.
- **결과 값 포함 안 됨**: 반환된 `CompletableFuture`는 작업 완료 여부만 알려주며, 개별 작업의 결과를 직접 포함하지 않습니다.
- **에러 처리**: 하나의 작업이라도 예외가 발생하면, 반환된 `CompletableFuture`는 예외 상태로 완료됩니다.

---

### **1.3 예제**

```java
import java.util.concurrent.CompletableFuture;

public class AllOfExample {
    public static void main(String[] args) {
        CompletableFuture<Void> future1 = CompletableFuture.runAsync(() -> {
            System.out.println("Task 1");
        });

        CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {
            System.out.println("Task 2");
        });

        CompletableFuture<Void> future3 = CompletableFuture.runAsync(() -> {
            System.out.println("Task 3");
        });

        // 모든 작업이 완료될 때까지 대기
        CompletableFuture<Void> allOfFuture = CompletableFuture.allOf(future1, future2, future3);

        allOfFuture.thenRun(() -> System.out.println("All tasks completed!"));
    }
}

```

**출력 결과** (작업 순서는 비동기적 실행에 따라 다를 수 있음):

```arduino
Task 1
Task 2
Task 3
All tasks completed!

```

---

### **1.4 결과 수집**

`allOf()`는 작업 결과를 직접 포함하지 않으므로, 개별 작업의 결과를 수집하려면 작업 완료 후 `join()` 또는 `get()` 메서드를 호출해야 합니다.

```java
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Result 1");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "Result 2");

CompletableFuture<Void> allOfFuture = CompletableFuture.allOf(future1, future2);

allOfFuture.thenRun(() -> {
    String result1 = future1.join();
    String result2 = future2.join();
    System.out.println(result1 + " and " + result2);
});

```

**출력 결과:**

```rust
Result 1 and Result 2

```

---

### **1.5 내부 동작**

`allOf()`는 내부적으로 `CompletableFuture<Void>` 객체를 생성하며, 전달된 작업이 모두 완료될 때까지 대기합니다.  

메인스레드가 `join()`으로 대기하고 있다가 해제되는 기준은 `allOf()`로 반환된 CompletableFuture의 결과가 null 아닌 값(AltResult)으로 채워져야 한다.  
AltResult 는 모든 CompleteFuture의 비동기 작업이 완료되었을때 allOf()의 CompletableFuture에 저장되는 null 개념의 객체이다.

### **1.5.1 `CompletableFuture.allOf()` 구현**

`allOf()`는 다음과 같이 여러 `CompletableFuture`의 완료 상태를 감시하는 로직을 포함합니다. 이 로직은 모든 작업이 완료되면 `CompletableFuture`의 `result` 필드가 `null`이 아닌 값(여기서는 `AltResult`)으로 설정되도록 보장합니다.

```java

public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs) {
    if (cfs.length == 0)
        return CompletableFuture.completedFuture(null); // 작업이 없으면 즉시 완료된 CompletableFuture 반환

    CompletableFuture<Void> dst = new CompletableFuture<>(); // 결과 저장 객체 생성
    AtomicInteger remaining = new AtomicInteger(cfs.length); // 완료 대기 중인 작업 수

    for (CompletableFuture<?> cf : cfs) {
        cf.whenComplete((res, ex) -> { // 각 CompletableFuture의 완료 상태를 감시
            if (ex != null) { // 작업 중 예외 발생 시
                dst.completeExceptionally(ex); // 전체 작업을 예외 상태로 설정
            } else if (remaining.decrementAndGet() == 0) { // 모든 작업이 완료되었는지 확인
                dst.complete(null); // 모든 작업 완료 후 결과를 저장
            }
        });
    }

    return dst;
}

```

---

### **1.5.2. `join()`에서 대기 상태 해제**

메인 스레드가 `join()`으로 대기하다가 해제되는 과정은 `CompletableFuture`의 `join()` 메서드 내부에서 확인할 수 있습니다.

### `join()` 구현 (요약)

```java

public T join() {
    Object r;
    if ((r = result) == null) { // 결과가 아직 준비되지 않은 경우
        r = waitingGet(false); // 대기
    }
    return reportJoin(r); // 결과 반환
}

private Object waitingGet(boolean interruptible) {
    boolean queued = false;
    int spins = SPINS;
    Object r;
    while ((r = result) == null) { // 결과가 준비될 때까지 반복
        if (spins > 0) {
            spins--; // 스핀락(spin lock) 사용
        } else if (!queued) {
            queued = tryPushStack(new Signaller(interruptible, 0L, 0L)); // 대기 스택에 등록
        } else {
            ForkJoinPool.managedBlock(signaller); // 대기 상태로 전환
        }
    }
    return r;
}

```

### **대기 해제 기준**

1. `result` 필드가 `null`이 아닌 값으로 채워지면 대기 상태 해제.
2. `AltResult`가 저장되면 `result`가 `null`이 아닌 상태로 간주됩니다.

---

### **1.5.3. `complete()`에서 `AltResult`의 설정**

`CompletableFuture`의 `complete()` 메서드가 호출되면, 내부적으로 `result` 필드에 값을 설정하며, `AltResult`가 이 과정에서 활용됩니다.

### `complete()` 메서드

```java
public boolean complete(T value) {
    if (result == null) {
        boolean complete = tryCompleteValue(value);
        postComplete();
        return complete;
    }
    return false;
}

```

### `tryCompleteValue()` 메서드

```java

final boolean tryCompleteValue(T value) {
    return RESULT.compareAndSet(this, null, (value == null) ? NIL : value);
}

```

- `value == null`이면 `NIL`로 설정.
- 여기서 `NIL`은 `AltResult` 객체로 정의되어 있으며, 이는 내부적으로 `null`을 나타냅니다.

---

### **1.5.4. 전체 동작 요약**

1. `allOf()`가 반환한 `CompletableFuture`는 초기 상태에서 `result == null`입니다.
2. 각 비동기 작업이 완료되면 `whenComplete()`에 의해 `remaining` 카운터가 감소됩니다.
3. 마지막 작업이 완료되면 `dst.complete(null)`이 호출됩니다.
  - 내부적으로 `AltResult`가 `result` 필드에 저장됩니다.
4. `join()` 메서드가 `result` 필드의 값이 설정된 것을 확인하고, 대기 상태를 해제합니다.

---

### **AltResult의 Null 처리**

`AltResult` 객체는 다음과 같이 정의되어 있습니다:

```java
static final class AltResult {
    final Throwable ex;

    AltResult(Throwable x) {
        this.ex = x;
    }
}

static final AltResult NIL = new AltResult(null); // Null 값 처리

```

- 작업 결과가 `null`인 경우, `NIL`(`AltResult`)이 `result`에 저장됩니다.
- `result`가 `null`이 아니므로 `join()`은 대기 상태를 종료하고 반환합니다.


---

## **2. anyOf()**

### **2.1 정의**

- `anyOf()`는 **여러 비동기 작업 중 하나라도 완료**되면 즉시 반환되는 메서드입니다.
- **반환값**: `CompletableFuture<Object>`를 반환하며, 완료된 작업의 결과를 포함합니다.
- **용도**: 여러 비동기 작업 중 가장 빠르게 완료된 작업의 결과를 사용하는 경우 유용합니다.

---

### **2.2 주요 특징**

- **첫 번째 완료된 작업 반환**: 전달된 작업 중 하나라도 완료되면, 해당 작업의 결과를 반환합니다.
- **나머지 작업 무시 가능**: 첫 번째 완료된 작업 이후 나머지 작업 결과는 무시할 수 있습니다.
- **에러 처리**: 첫 번째로 완료된 작업이 예외를 발생시키면, 반환된 `CompletableFuture`도 예외 상태로 완료됩니다.

---

### **2.3 예제**

```java
import java.util.concurrent.CompletableFuture;

public class AnyOfExample {
    public static void main(String[] args) {
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            try { Thread.sleep(200); } catch (InterruptedException e) {}
            return "Task 1";
        });

        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            return "Task 2";
        });

        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {
            try { Thread.sleep(300); } catch (InterruptedException e) {}
            return "Task 3";
        });

        // 가장 빠른 작업의 결과 반환
        CompletableFuture<Object> anyOfFuture = CompletableFuture.anyOf(future1, future2, future3);

        anyOfFuture.thenAccept(result -> System.out.println("First completed task: " + result));
    }
}

```

**출력 결과:**

```arduino
First completed task: Task 2

```

---

### **2.4 내부 동작**
메인 스레드가 `join()`으로 대기하고 있다가 해제되는 기준은 `anyOf()`로 반환된 `CompletableFuture`의 결과값이 채워져야 한다 이때 결과값이 채워지면 다른 값으로 수정되거나 변경될 수 없다.

`anyOf()`는 내부적으로 전달된 작업 중 하나라도 완료되면 즉시 해당 결과를 반환하는 `CompletableFuture`를 생성합니다.

```java
public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs) {
    if (cfs.length == 0)
        return CompletableFuture.completedFuture(null);

    CompletableFuture<Object> dst = new CompletableFuture<>();
    for (CompletableFuture<?> cf : cfs) {
        cf.whenComplete((res, ex) -> {
            if (ex != null) {
                dst.completeExceptionally(ex);
            } else {
                dst.complete(res);
            }
        });
    }
    return dst;
}

```

---

## **3. allOf()와 anyOf() 비교**

| **특징** | **allOf()** | **anyOf()** |
| --- | --- | --- |
| **완료 조건** | 모든 작업이 완료될 때 반환 | 첫 번째 완료된 작업의 결과를 반환 |
| **반환값** | `CompletableFuture<Void>` | `CompletableFuture<Object>` |
| **결과 처리** | 결과를 직접 포함하지 않으므로, 개별 작업의 결과를 수집하려면 `join()` 사용 필요 | 첫 번째 완료된 작업의 결과를 바로 반환 |
| **실행 방식** | 모든 작업을 병렬로 실행하며, 전부 완료될 때까지 대기 | 병렬로 실행하며, 첫 번째 완료된 작업의 결과를 반환 |
| **사용 사례** | 모든 작업이 완료되어야 후속 작업을 실행해야 할 때 | 가장 빠르게 완료된 작업 결과를 사용해야 할 때 |

---

## **4. 요약**

- `allOf()`는 모든 작업이 완료될 때까지 기다린 후 후속 작업을 실행합니다. 주로 **동시성 제어** 또는 **모든 작업 완료 확인**이 필요할 때 유용합니다.
- `anyOf()`는 가장 빠르게 완료된 작업의 결과를 반환하며, **최초 작업 결과 사용**이 중요할 때 사용됩니다.
- 두 메서드는 모두 `CompletableFuture`에서 제공하는 **병렬 작업 관리**의 강력한 도구로, 비동기 작업의 동시성 처리에 필수적입니다.
  
---    

### **`exceptionally()` 메서드**

`exceptionally()`는 Java의 `CompletableFuture`에서 제공하는 메서드로, **비동기 작업 도중 발생한 예외를 처리하고 대체 결과를 반환**하기 위해 사용됩니다. 이는 비동기 작업 흐름 중 **예외 복구**를 위해 매우 유용한 메서드입니다.

---

### **1. 주요 특징**

1. **예외 처리 전용**:
  - 작업 도중 발생한 예외를 처리합니다.
  - 예외가 없으면 호출되지 않습니다.
2. **대체 결과 반환**:
  - 예외가 발생했을 때 사용할 기본값을 반환할 수 있습니다.
  - 정상적으로 완료된 경우에는 기존 결과를 그대로 반환합니다.
3. **체이닝 가능**:
  - `exceptionally()`를 호출한 후에도 후속 작업을 체이닝할 수 있습니다.

---

### **2. 메서드 시그니처**

```java
public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn);

```

- **인수**:
  - `Function<Throwable, ? extends T> fn`: 발생한 예외를 받아 처리하고 대체 결과를 반환하는 함수.
- **반환값**:
  - 새로운 `CompletableFuture` 객체를 반환하며, 예외가 처리된 후 후속 작업을 계속 진행합니다.

---

### **3. 사용 예제**

### **3.1 기본 예제**

```java
import java.util.concurrent.CompletableFuture;

public class ExceptionallyExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            if (true) {
                throw new RuntimeException("Error occurred");
            }
            return "Success";
        }).exceptionally(ex -> {
            System.out.println("Exception: " + ex.getMessage());
            return "Default Result";
        });

        future.thenAccept(System.out::println); // 출력: Default Result
    }
}

```

**출력 결과**:

```plaintext
Exception: Error occurred
Default Result

```

- `supplyAsync()`에서 `RuntimeException`이 발생하므로, `exceptionally()`가 호출되어 "Default Result"를 반환합니다.
- 후속 `thenAccept()`는 "Default Result"를 출력합니다.

---

### **3.2 정상 작업 처리**

```java
import java.util.concurrent.CompletableFuture;

public class ExceptionallyExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Success")
            .exceptionally(ex -> "Default Result");

        future.thenAccept(System.out::println); // 출력: Success
    }
}

```

- 예외가 발생하지 않으면 `exceptionally()`는 호출되지 않습니다.
- 원래의 결과 `"Success"`가 반환되고 출력됩니다.

---

### **3.3 비동기 작업 체이닝**

```java
import java.util.concurrent.CompletableFuture;

public class ExceptionallyExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            if (true) {
                throw new RuntimeException("Error occurred");
            }
            return "Success";
        }).exceptionally(ex -> {
            System.out.println("Exception: " + ex.getMessage());
            return "Default Result";
        }).thenApply(result -> result + " Processed");

        future.thenAccept(System.out::println); // 출력: Default Result Processed
    }
}

```

- `exceptionally()`에서 대체 결과 `"Default Result"`를 반환합니다.
- 후속 `thenApply()`는 `"Default Result Processed"`를 반환하고 출력합니다.

---

### **4. 내부 동작**

### **4.1 `exceptionally()`의 동작 원리**

1. `exceptionally()`는 내부적으로 **결과를 검사**하며, 작업이 실패 상태(예외)인 경우 호출됩니다.
2. 발생한 예외를 `Function<Throwable, ? extends T>`에 전달합니다.
3. 반환된 대체 결과를 `CompletableFuture`의 결과로 설정합니다.

### **4.2 내부 구현 코드 (요약)**

```java

public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn) {
    if (fn == null) throw new NullPointerException();
    CompletableFuture<T> dst = new CompletableFuture<>();
    UniExceptionally<T> completion = new UniExceptionally<>(this, dst, fn);
    pushCompletion(completion);
    completion.tryFire(SYNC);
    return dst;
}

```

- **`UniExceptionally`**:
  - 예외를 처리하고 대체 결과를 반환하기 위한 내부 클래스.
  - `tryFire()` 메서드를 통해 예외가 발생한 경우에만 실행됩니다.

---

### **5. 내부 클래스 `UniExceptionally`**

### **5.1 구조**

```java
static final class UniExceptionally<T> extends UniCompletion<T, T> {
    Function<Throwable, ? extends T> fn;

    UniExceptionally(CompletableFuture<T> src, CompletableFuture<T> dst, Function<Throwable, ? extends T> fn) {
        super(src, dst);
        this.fn = fn;
    }

    final CompletableFuture<T> tryFire(int mode) {
        CompletableFuture<T> d; CompletableFuture<T> a;
        Object r;
        if ((a = src) != null && (r = a.result) != null && (d = dep) != null) {
            if (d.result == null) {
                try {
                    if (r instanceof AltResult && ((AltResult) r).ex != null) {
                        Throwable ex = ((AltResult) r).ex;
                        d.completeValue(fn.apply(ex)); // 예외를 처리하고 대체 결과 반환
                    } else {
                        d.completeValue((T) r);
                    }
                } catch (Throwable ex) {
                    d.completeThrowable(ex);
                }
            }
            src = null; dep = null; fn = null;
            return d.postFire(a, mode);
        }
        return null;
    }
}

```

### **5.2 동작 흐름**

1. `src.result`에 저장된 예외를 확인.
2. 예외가 존재하면 `fn.apply(ex)`를 호출하여 대체 결과 생성.
3. 대체 결과를 `d.completeValue()`로 설정.
4. 후속 작업 실행 (`postFire()`).

---

### **6. 예외 처리 흐름 요약**

1. **작업 실행**: `CompletableFuture`가 비동기 작업을 실행.
2. **예외 발생 확인**: 작업 도중 예외 발생 시 내부적으로 `AltResult`에 예외 저장.
3. **`exceptionally()` 실행**: 예외가 있을 경우, 등록된 `Function`을 호출하여 대체 결과 생성.
4. **대체 결과 설정**: 생성된 결과를 `CompletableFuture`의 결과로 설정.
5. **후속 작업 실행**: 후속 작업이 있다면 체이닝을 통해 계속 실행.

---

### **7. 결론**

- **`exceptionally()`는 비동기 작업에서 발생한 예외를 처리하고 대체 결과를 반환**하는 데 사용됩니다.
- **정상적인 작업에는 영향을 주지 않으며**, 예외가 없을 경우 호출되지 않습니다.
- 후속 작업과 체이닝이 가능하므로 **예외 복구를 통해 작업 흐름을 유지**할 수 있습니다.
  

### **`handle()` 메서드**

`handle()`은 Java의 `CompletableFuture`에서 **비동기 작업의 성공 또는 실패 여부와 관계없이 후속 작업을 처리**하기 위한 메서드입니다. 작업이 성공했을 때는 결과를, 실패했을 때는 예외를 처리할 수 있도록 설계되었습니다.

---

### **1. 주요 특징**

1. **성공 및 실패 처리 가능**:
  - 이전 작업의 결과가 성공했을 경우에는 결과를 처리합니다.
  - 실패했을 경우에는 발생한 예외를 처리할 수 있습니다.
2. **후속 작업 반환 가능**:
  - 결과 또는 예외를 처리한 후 새로운 값을 반환할 수 있습니다.
3. **체이닝 가능**:
  - `handle()`을 사용한 후에도 후속 작업을 체이닝할 수 있습니다.

---

### **2. 메서드 시그니처**

```java
public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);

```

- **인수**:
  - `BiFunction<? super T, Throwable, ? extends U>`: 작업의 결과(성공 시)와 예외(실패 시)를 모두 처리할 수 있는 함수.
- **반환값**:
  - 새로운 `CompletableFuture<U>` 객체를 반환하며, 성공 또는 실패 결과를 처리한 후 새로운 값을 포함합니다.

---

### **3. 사용 예제**

### **3.1 성공 및 실패 처리**

```java
import java.util.concurrent.CompletableFuture;

public class HandleExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            if (true) {
                throw new RuntimeException("Error occurred");
            }
            return "Success";
        }).handle((result, ex) -> {
            if (ex != null) {
                System.out.println("Exception: " + ex.getMessage());
                return "Default Result";
            }
            return result;
        });

        future.thenAccept(System.out::println); // 출력: Default Result
    }
}

```

**출력 결과**:

```plaintext
Exception: Error occurred
Default Result

```

- 작업이 실패하면 예외가 `handle()`의 두 번째 인수로 전달됩니다.
- `handle()`은 예외를 처리하고 `"Default Result"`를 반환합니다.

---

### **3.2 정상 처리**

```java
import java.util.concurrent.CompletableFuture;

public class HandleExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Success")
            .handle((result, ex) -> {
                if (ex != null) {
                    return "Default Result";
                }
                return result + " Processed";
            });

        future.thenAccept(System.out::println); // 출력: Success Processed
    }
}

```

- 작업이 성공하면 결과가 `handle()`의 첫 번째 인수로 전달됩니다.
- `handle()`은 결과를 처리하고 `"Success Processed"`를 반환합니다.

---

### **3.3 비동기 체이닝**

```java
import java.util.concurrent.CompletableFuture;

public class HandleExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            throw new RuntimeException("Error occurred");
        }).handle((result, ex) -> {
            if (ex != null) {
                return "Handled Error";
            }
            return result;
        }).thenApply(result -> result + " Chained");

        future.thenAccept(System.out::println); // 출력: Handled Error Chained
    }
}

```

- 예외가 발생하면 `"Handled Error"`를 반환하고, 체이닝된 `thenApply()`에서 이를 추가 처리합니다.

---

### **`whenComplete()` 메서드**

`whenComplete()`는 Java의 `CompletableFuture`에서 **비동기 작업의 성공 및 실패 여부와 관계없이 후속 동작을 정의**할 수 있는 메서드입니다. 결과를 반환하지 않으며, 작업의 결과 또는 예외를 단순히 확인하거나 로깅하는 데 유용합니다.

---

### **1. 주요 특징**

1. **성공 및 실패 확인**:
  - 작업 결과를 확인하거나 예외를 처리할 수 있습니다.
  - 결과를 반환하지 않고 단순히 확인만 수행합니다.
2. **후속 동작 반환 없음**:
  - 결과를 변환하거나 새로운 결과를 반환하지 않습니다.
  - 후속 작업에서 작업의 성공/실패를 참조할 수 있습니다.
3. **체이닝 가능**:
  - `whenComplete()`를 호출한 후에도 후속 작업을 체이닝할 수 있습니다.

---

### **2. 메서드 시그니처**

```java
public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable> action);

```

- **인수**:
  - `BiConsumer<? super T, ? super Throwable>`: 작업 결과(성공 시)와 예외(실패 시)를 처리하는 함수.
- **반환값**:
  - 기존 `CompletableFuture<T>` 객체를 반환합니다. 후속 작업을 계속 진행할 수 있습니다.

---

### **3. 사용 예제**

### **3.1 성공 및 실패 확인**

```java
import java.util.concurrent.CompletableFuture;

public class WhenCompleteExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            if (true) {
                throw new RuntimeException("Error occurred");
            }
            return "Success";
        }).whenComplete((result, ex) -> {
            if (ex != null) {
                System.out.println("Exception: " + ex.getMessage());
            } else {
                System.out.println("Result: " + result);
            }
        });

        future.join(); // 작업 완료 대기
    }
}

```

**출력 결과**:

```plaintext
Exception: Error occurred

```

---

### **3.2 정상 작업 확인**

```java
import java.util.concurrent.CompletableFuture;

public class WhenCompleteExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Success")
            .whenComplete((result, ex) -> {
                if (ex != null) {
                    System.out.println("Exception: " + ex.getMessage());
                } else {
                    System.out.println("Result: " + result);
                }
            });

        future.join(); // 작업 완료 대기
    }
}

```

**출력 결과**:

```plaintext
Result: Success

```

---

### **3.3 체이닝**

```java
import java.util.concurrent.CompletableFuture;

public class WhenCompleteExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            throw new RuntimeException("Error occurred");
        }).whenComplete((result, ex) -> {
            if (ex != null) {
                System.out.println("Handled exception: " + ex.getMessage());
            }
        }).exceptionally(ex -> "Recovered").thenApply(result -> result + " Chained");

        future.thenAccept(System.out::println); // 출력: Recovered Chained
    }
}

```

---

### **예외 처리 메서드 비교**

| **특징** | **`exceptionally()`** | **`handle()`** | **`whenComplete()`** |
| --- | --- | --- | --- |
| **사용 목적** | 실패(예외)만 처리 | 성공 및 실패 모두 처리 | 성공 및 실패 여부를 확인, 결과를 반환하지 않음 |
| **인수** | `Function<Throwable, ? extends T>` | `BiFunction<? super T, Throwable, ? extends U>` | `BiConsumer<? super T, ? super Throwable>` |
| **결과 반환** | 새로운 결과를 반환 | 결과를 변환하여 반환 | 결과를 반환하지 않고, 확인만 수행 |
| **적용 시점** | 작업 실패 시 호출 | 작업 성공/실패 상관없이 호출 | 작업 성공/실패 상관없이 호출 |
| **체이닝 가능 여부** | 가능 | 가능 | 가능 |
| **사용 사례** | 실패 복구 및 대체 값 설정 | 결과를 반환하며 성공 및 실패를 모두 처리 | 성공/실패를 확인하거나 로깅할 때 사용 |
| **실제 코드 영향** | 새로운 결과로 대체 | 새로운 결과를 반환 | 기존 결과를 유지 |
  
  
### exceptionally 상세 구현

### **1. 비동기 작업 생성**

`CompletableFuture.supplyAsync()`는 새로운 비동기 작업을 생성하고, 이를 `AsyncSupply` 객체로 래핑하여 실행합니다. `AsyncSupply`는 비동기적으로 실행해야 할 작업을 캡슐화한 객체입니다.

### **1.1 supplyAsync 내부 코드**

```java
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {
    return asyncSupplyStage(ASYNC_POOL, supplier);
}

static <U> CompletableFuture<U> asyncSupplyStage(Executor e, Supplier<U> f) {
    if (f == null) throw new NullPointerException();
    CompletableFuture<U> d = new CompletableFuture<>();
    e.execute(new AsyncSupply<>(d, f)); // AsyncSupply를 실행
    return d;
}

```

- `CompletableFuture<U> d`: 비동기 작업의 결과를 저장하는 객체입니다.
- `AsyncSupply<U>`: 실행할 작업(`Supplier<U>`)을 캡슐화한 객체로, 내부적으로 작업 결과를 처리합니다.
- `e.execute(...)`: 작업은 기본적으로 `ForkJoinPool.commonPool`에 의해 실행됩니다.

---

### **2. AsyncSupply의 실행**

`AsyncSupply` 객체는 작업을 수행하고, 결과를 `CompletableFuture`의 `result` 필드에 저장합니다. 작업 중 예외가 발생하면 이를 캡슐화하여 저장합니다.

### **2.1 AsyncSupply 클래스**

```java
static final class AsyncSupply<T> extends ForkJoinTask<Void> implements Runnable, AsynchronousCompletionTask {
    final CompletableFuture<T> dep; // 작업의 결과를 저장할 CompletableFuture
    final Supplier<? extends T> fn; // 작업 내용

    AsyncSupply(CompletableFuture<T> dep, Supplier<? extends T> fn) {
        this.dep = dep;
        this.fn = fn;
    }

    public final boolean exec() {
        run(); // 작업 실행
        return false;
    }

    public void run() {
        CompletableFuture<T> d;
        Supplier<? extends T> f;
        if ((d = dep) != null && (f = fn) != null) {
            dep = null; fn = null;
            if (d.result == null) {
                try {
                    d.completeValue(f.get()); // 작업 성공 시 결과 저장
                } catch (Throwable ex) {
                    d.completeThrowable(ex); // 작업 중 예외 발생 시 예외 저장
                }
            }
            d.postComplete(); // 후속 작업 실행
        }
    }
}

```

### **2.2 결과 저장**

- `d.completeValue(f.get())`: 작업 결과를 `CompletableFuture`의 `result` 필드에 저장합니다.
- `d.completeThrowable(ex)`: 예외가 발생하면 이를 `AltResult` 객체로 캡슐화하여 `result`에 저장합니다.

---

### **3. 예외 발생 처리**

`CompletableFuture`는 예외를 `AltResult` 객체로 캡슐화하여 처리합니다.

### **3.1 completeThrowable**

```java
final boolean completeThrowable(Throwable x) {
    return RESULT.compareAndSet(this, null, new AltResult(x));
}

```

- 예외(`Throwable x`)를 `AltResult`로 감싸서 `result`에 저장합니다.
- `result`는 이제 `AltResult` 객체를 참조하게 됩니다.

### **3.2 AltResult**

```java
static final class AltResult {
    final Throwable ex;

    AltResult(Throwable x) {
        this.ex = x; // 발생한 예외를 저장
    }
}

```

- 예외 발생 시, `AltResult` 객체의 `ex` 필드에 예외가 저장됩니다.

---

### **4. thenApply에서의 처리**

`thenApply`는 이전 작업의 결과를 확인하여 후속 작업을 실행합니다. 만약 이전 작업에서 예외가 발생했으면 `AltResult`로 저장된 예외를 처리합니다.

### **4.1 thenApply 내부 코드**

```java
public <U> CompletableFuture<U> thenApply(Function<? super T, ? extends U> fn) {
    if (fn == null) throw new NullPointerException();
    CompletableFuture<U> dst = new CompletableFuture<>();
    UniApply<T, U> action = new UniApply<>(this, dst, fn);
    pushCompletion(action); // 후속 작업 등록
    action.tryFire(SYNC); // 작업 실행
    return dst;
}

```

### **4.2 UniApply**

`UniApply`는 작업 결과를 확인하고, 후속 작업을 실행합니다. 예외가 발생한 경우는 처리하지 않습니다.

```java
static final class UniApply<T, U> extends UniCompletion<T, U> {
    final Function<? super T, ? extends U> fn;

    UniApply(CompletableFuture<T> src, CompletableFuture<U> dst, Function<? super T, ? extends U> fn) {
        super(src, dst);
        this.fn = fn;
    }

    final CompletableFuture<U> tryFire(int mode) {
        CompletableFuture<U> d;
        CompletableFuture<T> a;
        Object r;
        if ((a = src) != null && (r = a.result) != null && (d = dep) != null) {
            try {
                if (r instanceof AltResult) {
                    Throwable ex = ((AltResult) r).ex; // 예외 확인
                    d.completeThrowable(ex); // 예외 전달(다음 작업으로 전달)
                } else {
                    @SuppressWarnings("unchecked") T t = (T) r;
                    d.completeValue(fn.apply(t)); // 결과 처리
                }
            } catch (Throwable ex) {
                d.completeThrowable(ex); // 후속 작업에서 발생한 예외 처리
            }
            src = null; dep = null; fn = null;
            return d.postFire(a, mode);
        }
        return null;
    }
}

```

- `r instanceof AltResult`: 예외가 발생한 경우, 예외 객체(`Throwable ex`)를 추출합니다.
- `d.completeThrowable(ex)`: 예외를 후속 작업으로 전달합니다.

---

### **5. exceptionally에서의 처리**

`exceptionally`는 이전 작업의 예외를 처리하고 복구 작업을 수행합니다.

### **5.1 exceptionally 내부 코드**

```java
public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn) {
    if (fn == null) throw new NullPointerException();
    CompletableFuture<T> dst = new CompletableFuture<>();
    UniExceptionally<T> action = new UniExceptionally<>(this, dst, fn);
    pushCompletion(action); // 후속 작업 등록
    action.tryFire(SYNC); // 작업 실행
    return dst;
}

```

### **5.2 UniExceptionally**

`UniExceptionally`는 이전 작업의 결과가 예외인 경우 이를 복구합니다.

```java
static final class UniExceptionally<T> extends UniCompletion<T, T> {
    Function<Throwable, ? extends T> fn;

    UniExceptionally(CompletableFuture<T> src, CompletableFuture<T> dst, Function<Throwable, ? extends T> fn) {
        super(src, dst);
        this.fn = fn;
    }

    final CompletableFuture<T> tryFire(int mode) {
        CompletableFuture<T> d;
        CompletableFuture<T> a;
        Object r;
        if ((a = src) != null && (r = a.result) != null && (d = dep) != null) {
            try {
                if (r instanceof AltResult) {
                    Throwable ex = ((AltResult) r).ex;
                    d.completeValue(fn.apply(ex)); // 예외 복구
                } else {
                    @SuppressWarnings("unchecked") T t = (T) r;
                    d.completeValue(t); // 정상 결과 전달
                }
            } catch (Throwable ex) {
                d.completeThrowable(ex); // 복구 중 발생한 예외 처리
            }
            src = null; dep = null; fn = null;
            return d.postFire(a, mode);
        }
        return null;
    }
}

```

---

### **6. 전체 흐름 요약**

1. **작업 실행**: `AsyncSupply`가 비동기 작업을 실행하고, 성공 시 결과를 저장하거나 실패 시 예외를 `AltResult`로 저장.
2. **thenApply 처리**:
  - 정상 결과: `thenApply`는 결과를 사용하여 후속 작업 실행.
  - 예외 발생: `AltResult`가 전달되며, 후속 작업 실행 없이 예외를 전달.
3. **exceptionally 처리**:
  - 예외 확인: `AltResult`에서 예외를 추출.
  - 복구 실행: 예외를 처리하고 대체 값을 반환.
4. **최종 결과**: 복구된 값 또는 예외가 최종적으로 `CompletableFuture`의 결과로 설정.

---

### **7. 예제 코드로 흐름 확인**

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("Initial Error");
}).thenApply(result -> result + " Processed") // 예외 전달
  .exceptionally(ex -> {
      System.out.println("Recovering from: " + ex.getMessage());
      return "Recovered";
  });

System.out.println(future.join()); // 출력: Recovered

```

**흐름**:

1. `supplyAsync`: 예외 발생 → `AltResult`로 저장.
2. `thenApply`: `AltResult`가 전달되어 작업 실행 없이 예외 전달.
3. `exceptionally`: 예외를 복구하고 `"Recovered"` 반환.
4. `join`: 최종 결과로 `"Recovered"`를 반환.
