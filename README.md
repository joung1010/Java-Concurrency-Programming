## 자바 동시성 프로그래밍
자바에서 쓰레드는 내부적으로는 운영체제의 도움을 받아 작동하게 된다.  
쓰레드 생성되는 시점에 운영체제가 개입을 해 제어하는 방식으로 동작한다.  
### 동작 방식
1. **쓰레드 생성**: 자바에서 쓰레드를 생성하면, JVM은 이 요청을 운영체제에 전달한다. 운영체제는 이를 수행하고, 자바 쓰레드에 대응하는 운영체제 수준의 쓰레드를 생성.
2. **쓰레드 스케줄링과 관리**: 쓰레드의 실행, 스케줄링(언제 어떤 쓰레드가 실행될지 결정하는 과정)은 운영체제의 책임이다. JVM은 운영체제의 스케줄링 정책을 따르며, 운영체제는 사용 가능한 프로세서 자원을 쓰레드에 할당
3. **사용자 수준 쓰레드와 커널 수준 쓰레드**: 일부 운영체제에서는 사용자 수준 쓰레드(운영체제 커널이 관리하지 않는 쓰레드)와 커널 수준 쓰레드(운영체제 커널에 의해 직접 관리되는 쓰레드)를 지원한다. `자바`는 이러한 구분 없이 **투명하게 쓰레드를 관리**하도록 설계되었습니다.
4. **플랫폼 독립성**: 자바의 플랫폼 독립성으로 인해, 동일한 자바 쓰레드 코드가 다양한 운영체제에서 동일하게 작동할 수 있다. 그러나 쓰레드의 성능과 행동은 운영체제에 따라 다를 수 있다.
5. **JVM과 운영체제의 최적화**: 최신 JVM과 운영체제는 쓰레드 성능을 최적화하기 위해 긴밀하게 협력한다. 예를 들어, 가비지 컬렉션, 쓰레드 풀 관리 등은 JVM과 운영체제 간의 효율적인 상호작용을 통해 이루어진다.
  
이처럼 자바의 쓰레드와 운영체제는 긴밀하게 서로 소통하기 때문에 이 쓰레드를 잘 이해하기 위해서는 그 밑단에 흐르는 운영체제에서 동작하는 기본적인 쓰레드 원리 와 작동원리 및 도시성에 대하여 알 필요가 있다.  
즉, 자바쓰레드가 실행되는 시점에 운영체제의 상태와 쓰레드간의 전환이 발생하는 문제에 대한 처리 방법등 이러한 기본적인 흐름에 대한 이해가 필요하다.  
  
# 프로세스 와 쓰레드
| 프로세스 | 쓰레드 |
| --- | --- |
| 운영체제로부터 자원을 할당 받은 작업 단위 | 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위 |  
## 프로세스
### 프로그램
운영체제에 의해 시스템에 설치되어 있는 파일을 프로그램이라 말한다.  
예를들어 윈도우의 `.exe` 파일이나 Mac의 `.dmg` 파일과 같은 컴퓨터에서 실행할 수 있는 파일을 통칭한다.  
즉 아직 **파일을 실행하지 않는 상태**를 말한다.  
  
### 프로세스
프로그램이 실행하지 않는 파일을 말한다면 이를 **동작시켜서 프로그램이 돌아가고 있는 상태**를 프로세스라고 한다.  
즉, 프로세스는 프로그램의 실제 실행을 의미하며 이를 실행함으로써 프로그램의 **데이터들이 메모리에 올라와 cpu를 할당받고 명령을 수행하고 있는 상태** 이다.  

| 프로그램 | 프로세스 |
| --- | --- |
| 어떤 작업을 하기 위해 실행할 수 있는 파일 | 실행되어 작업중인 컴퓨터 프로그램 |
| 파일이 저장 장치에 있지만 메모리에는 올라가 있지 않은 정적인 상태 | 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태 |
| 코드 덩어리 | 코드 실행시킨 것 |  
    
프로세스가 메모리를 할당받으면 할당받은 메모리 일부를 커널 서비스를 위해 별도로 할당해준다.
## 쓰레드
오늘날 우리가 컴퓨터에서 파일을 다운로드 받으면 다른 작업을 당연하게 할 수 있지만 예전에는 파일을 다운로드 받으면 이 작업이 종료될때까지 기다려야 다음 작업을 할 수 있었다. 그렇다고 동일한 프로그램을 여러개의 프로세스로 만들게 되면 메모리와 CPU의 자원이 중복되게 되는 문제점이 발생한다. 이러한 한계를 극복하고자 나온 개념이 쓰레드이다.  
  
즉, **하나의 프로세스 내에서 동시에 진행되는 작업의 갈래, 흐름의 단위를 말한다.** 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다. 실질적으로 **프로세스는 운영체제로부터 메모리 자원을 할당 받는 것**이고 실제 **CPU를 할당받아서 우리가 제안한 코드를 실행하는 주체는 스레드**이다.
  
## 프로세스의 메모리 구조
- **코드 영역(Code/ Text)**: 프로그래머가 작성한 프로그램 함수들의 코드가 CPU가 해석 가능한 기계어 형태로 저장
- **데이터 영역(Data)**: 코드가 실행되면서 사용하는 전역 변수나 각종 데이터들이 모여있다. 데이터영역은 .data ,.rodata, .bss 영역으로 세분화 된다.
    - .data: 전역변수, 또는 static 변수 등 프로그램이 사용하는 데이터를 저장
    - .BSS : 초기값 없는 전역 변수, static 변수가 저장
    - .rodata: const 같은 상수 키워드 선언 된 변수나 문자열 상수가 저장
- **스택 영역(Stack):** 지역 변수와 같은 호출한 함수가 종료되면 되돌아올 임시적인 자료를 저장하는 독립적인 공간. Stack은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 만일 stack 영역을 초과하면 stack overflow 에러가 발생한다.
- **힙 영역(Heap):** 생성자, 인스턴스와 같은 동적으로 할당되는 데이터들을 위해 존재하는 공간이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
  
운영 체제는 프로세스마다 위처럼 각각 독립적인 메모리 영역을 할당해 주게 된다. 이때 코드 영역과 데이터 영역은 크기가 정해져 있지만, **스택 영역과 힙영역은 실행 되는 동안 크기가 늘었다가 줄었다가 하는 동적 영역**이다.  
이렇게 프로세스 마다 독립된 메모리 영역이 할당되기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행 할 수 있다. 기본적으로 프로세스간의 정보 공유가 완전히 불가능한 것은 아닌데 IPC(Inter-Process Communication) , LPC(Local inter-Process Communication), 별도로 공유 메모리를 만들어서 정보를 주고받도록 설정하면 공유가 가능하다.  
  
## 쓰레드의 자원 공유
 쓰레드는 프로세스가 운영체제로부터 할당 받은 자원을 이용하는 실행,흐름 단위로서 하나의 프로세스는 하나 이상의 스레드를 갖는다. 스레드가 여러개 있으면 우리가 브라우저에서 파일을 다운로드 받으면서 동시에 웹서핑을 할 수 있게 해준다.  
이 쓰레드는 **프로세스의 자원을 공유** 하면서 실행 흐름의 일부가 되기때문에 **동시 작업이 가능**한 것이다. 이 프로세스의 자원공유란 프로세스 내에서 각 필요한 스택(함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수 내에서 선언하는 변수 등을 저장하는 공간)만 할당 받고 `코드,데이타,힙 영역`을 공유한다.  
이때 스레드 간 메모리 스택 영역에는 서로 접근할 수 없으므로 스레드는 독립적인 실행 흐름을 가질 수 있게되어 독립적인 함수 호출이 가능해 진다.  
  
# CPU
## CPU
CPU (Central Processing Unit)는 컴퓨터의 주요 구성 요소로, **컴퓨터의 모든 명령을 처리**하는 데 필요한 계산 및 제어 작업을 수행합니다. CPU는 컴퓨터의 `두뇌`로 간주되며, 모든 프로그램 실행, 데이터 처리, 명령 실행 등을 담당합니다. CPU의 성능은 컴퓨터의 전반적인 속도와 성능에 중요한 영향을 미칩니다.
  
### CPU와 스레드
**스레드는 운영체제의 스케줄러에 의해 관리되는 CPU의 최소 실행단위를 의미한다.** 스케줄러 알고리즘에 따라 프로세스에 속한 한개의 스레드가 선점되어 CPU에 할당되고 스레드 선점이 일어날 때 CPU의 실행 흐름(문맥)이 전환되는 **컨텍스트 스위칭**이 발생한다.

### 멀티 코어와 쓰레드
컴퓨터 부품을 검색해보면 CPU 4코어 12쓰레드, 8코어 4쓰레드 이런 단어를 본적이 있을 것이다. CPU 한개는 여러 코어를 가질 수 있다.  
이 코어는 말그대로 CPU 코어 유닛인데, 명령어를 메모리에서 뽑아 해석하고 실행하는 유닛이 물리적으로 4개가 있으면 4코어, 8개가 있으면 8코어라고 불린다.  
이때 4코어 2쓰레드는 물리적인 코어 하나가 쓰레드 2개 이상을 동시에 실행 가능하다는 의미이고, 운영체제는 8개의 작업(4코어*2쓰레드)을 동시에 처리할 수 있다는 의미이기도 한다. 이를 하이퍼스레딩(Hyper-Threading) 기술이라 말한다.  

# CPU 작업의 병렬성(Parallelism) 과 동시성(Concurrency)
## 동시성
동시성은 둘 이상의 작업이 동시에 실행되는 것을 의미하는데 이는 **CPU가 한번에 많은 일을 처리하는 것**에 중점을 두고 있다. 즉, 많은 작업들을 아주 빠른 시간으로 교체하면서 전체 작업을 수행한다. 예를 들어 1개의 코어가 있고 여러개의 작업이 존재한다면 CPU는 프로세스들을 번걸아가며 조금씩 아주 빠르게 처리함으로써 마치 프로그램이 동시에 실행되는 것처럼 보인다.
이때 작업들을 번갈아가면서 실행하기 때문아 아주 잘게 나누어 조금씩 작업을 수행하고 다음 작업으로 넘어가는 식으로 동작한다. 이렇게 하는 이유는 여러 작업을 동시에 처리하는 것처럼 보이게 만들어 사용자에게 더 빠른 반응성을 제공하기 위해서이다.  
진행중인 작업들을 A -> B -> C -> D -> A 이런식으로 번걸아 바꾸는 작업을 **Context Switching** 이라고 부른다.  
이 동시성 **작업은 처리를 빠르게 하기 위한 목적이 아닌 CPU를 효율적으로 사용하는 것에 더 중점**을 두고 있다. 예를 들어 스레드가 작업을 처리하다가 IO 작업을 만나게 되면 현재 스레드를 대기시키고 다시 다른 스레드로 전환(다른 스레드를 할당)해서 작업을 진행한다. 따라서 이 동시성 작업에 대한 처리 방식을 어떤식으로 진행할 것인지(많은 작업들 어떻게 하면 효율적으로 처리 할지) 고려해야하며 동시성으로 작업해햐할 수가 CPU 코어 수 보다 많을 경우 해당되며 동시성이 없으면 작업을 순차적으로 진행한다.  
  
## 병렬성
병렬성은 직관적으로 명령어를 메모리에 뽑아 해석하고 실행하는 반도체 유닛인 **코어에 맞춰 여러개의 프로세스, 스레드를 돌려 병렬로 작업을 동시 수행**하는 것을 말한다. 이 병렬성은 **CPU가 동시에 많은 일을 수행하는 것에 중점**을 두고 CPU가 놀지않고 바쁘게 동작한다. 따라서 병렬성은 런타임에 동시에 물리적으로 작업을 실행하는 것이며 여러 컴퓨팅 리소스가 있는 하드웨어가 필요함로 한 개의 코어에서는 절대 병렬성이 구현될 수 없다.  
이 병렬성은 동시성의 하위 개념으로 여러 쓰레드로 작업을 분리하여 그 쓰레드를 CPU에 적절히 분배하여 동시적으로 실행하도록 하는 것이므로 병렬 작업해야할 수가 CPU 코어 수보다 같거나 적을 경우 효율이 가장 좋다.  
  
### 병렬성과 동시성의 조합
1. ThreadPoolExecutor
   * 병렬성으로 처리 성능을 극대화하고 동시성으로 CPU 자원을 효율적으로 관리
2. ForkJoinPool
   * **Parallelism Divide and Conquer 알고리즘**
   * Fork 생성하다는 의미 이다. 즉 하나의 큰 작업을 여러 하위 작업으로 분할한다음 여러개의 CPU 코어로 이 분할된 작업을 병렬로 처리하고 그결과들을 연결(Join) 하여 최종적으로 결과를 도출한다.
   * 하나의 작업을 서브 작업으로 분할하여 병렬처리함으로써 전체 작업 성늘을 높임

##   동시성의 개념차이
`"동시성"`이라는 용어는 컴퓨팅에서 다소 다른 맥락으로 두 가지 방식에서 사용된다. 하나는 프로세스 또는 스레드가 시스템에서 동시에 실행되는 것처럼 관리되는 일반적인 개념이고, 다른 하나는 멀티스레드 프로그래밍에서 발생할 수 있는 특정한 문제들과 관련된 개념이다.

1. **동시성(Concurrency) - 일반적 개념**:
    - 이 개념은 컴퓨터 프로그램, 프로세스, 스레드 등이 시스템 내에서 "동시에" 실행되는 것처럼 보이게 만드는 기능을 의미
    - 단일 코어 CPU에서는 이것이 시분할 방식으로 번갈아가며 실행되어, 동시에 실행되는 것처럼 보이게 하는 것이다. 멀티코어 CPU에서는 실제로 여러 작업이 동시에 실행될 수 있습니다.
2. **동시성(Concurrency) - 멀티스레드 프로그래밍의 문제점**:
    - 멀티스레드 환경에서 동시에 여러 스레드가 공유 자원에 접근할 때 발생하는 문제들을 지칭
    - 여기에는 경합 상태, 데드락, 라이브락, 스타베이션 등과 같은 문제가 포함됩니다. 이러한 문제들은 멀티스레드 환경에서 데이터의 무결성과 일관성을 유지하는 데 중요한 영향을 미칩니다.
        1. **경합 상태(Race Condition)**:
            - 두 개 이상의 스레드가 동시에 같은 데이터에 접근하고, 적어도 하나의 스레드가 그 데이터를 수정할 때 발생합니다.
            - 경합 상태는 데이터가 예상치 못한 방식으로 변경되어 부정확한 결과나 시스템의 실패를 초래할 수 있습니다.
        2. **데드락(Deadlock)**:
            - 두 개 이상의 스레드가 서로가 보유한 자원을 기다리며 무한히 대기하는 상태입니다.
            - 이 상황에서는 어떤 스레드도 진행할 수 없으며, 프로그램이 멈춰버릴 수 있습니다.
        3. **라이브락(Livelock)**:
            - 데드락과 유사하게, 스레드가 실행되고 있지만 실제로는 유용한 작업을 수행하지 못하는 상태입니다.
            - 스레드들이 서로를 피해 계속 상태를 변경하지만, 결국에는 아무런 진전도 이루지 못합니다.
        4. **스타베이션(Starvation)**:
            - 한 스레드가 필요한 자원에 접근하지 못하고 무한히 대기하는 상황입니다.
            - 특정 스레드가 CPU 시간이나 필요한 자원을 독점하여 다른 스레드가 작업을 수행할 기회를 얻지 못하는 경우 발생합니다.

따라서 동시성이라는 용어는 컴퓨팅의 광범위한 영역에서 다양한 맥락으로 사용되며, 그 의미는 사용되는 상황에 따라 달라진다. 일반적으로는 시스템이 여러 작업을 동시에 처리할 수 있는 능력을 나타내며, 멀티스레딩 환경에서는 이러한 동시 작업 처리로 인해 발생할 수 있는 특정 문제들을 가리킨다.



# 프로세스,스레드의 생명주기
프로세스와 스레드의 생명주기는 운영 체제의 스케줄링 및 자원 관리와 밀접하게 연관되어 있습니다. 프로세스는 보다 무거운 자원 사용을 하며, 스레드는 같은 프로세스 내에서 더 가볍게 자원을 공유한다.  
  
## 프로세스 스케줄링
프로세스 스케줄링(Process Scheduling)은 운영체제에서 CPU를 사용할 수 있는 프로세스를 선택하고, CPU를 할당하는 작업을 말한다.이는 시스템의 효율성, 반응성, 공정성을 극대화하는 데 중요한 역할을 하고 다양한 스케줄링 알고리즘이 있으며, 각각의 사용 환경과 요구 사항에 따라 적합한 알고리즘이 선택된다.  

프로세스 스케줄링은 프로세스의 우선순위, 작업량등을 고려하여 효율적으로 배치하고 이를 통해 운영체제는 CPU를 효율적으로 사용하며 시스템 전반적인 성능을 향상시킨다. 이는 멀티 태스킹 작업을 만들어내는 데에 있어서 핵심적인 부분이다.  
  
대표적으로는 해당 알고리즘 등이 있다. 
1. FCFS (First-Come, First-Served)  
   특징: 가장 간단한 스케줄링 알고리즘으로, 먼저 도착한 프로세스가 먼저 서비스를 받습니다.  
   장점: 구현이 쉽고, 공정합니다.  
   단점: 짧은 작업이 긴 작업 뒤에 오면 대기 시간이 길어지는 '호위 효과(Convoy Effect)' 발생 가능.
2. SJF (Shortest-Job-First)
   특징: 예상 실행 시간이 가장 짧은 프로세스를 먼저 실행합니다.  
   장점: 평균 대기 시간을 최소화할 수 있습니다.  
   단점: 실행 시간을 미리 알아야 하며, 긴 작업은 무한정 대기할 수 있습니다 (기아 현상).  
3. 우선순위 스케줄링 (Priority Scheduling)  
   특징: 각 프로세스에 우선순위를 부여하고, 높은 우선순위의 프로세스를 먼저 실행합니다.  
   장점: 중요한 작업을 빠르게 처리할 수 있습니다.  
   단점: 낮은 우선순위의 프로세스가 기아 상태에 빠질 수 있습니다.  
4. RR (Round-Robin)  
   특징: 각 프로세스에 동일한 시간 할당량(Time Quantum)을 주고, 순서대로 실행합니다.  
   장점: 모든 프로세스가 공정하게 CPU 시간을 받으며, 반응 시간이 짧습니다.  
   단점: 시간 할당량의 크기에 따라 성능이 크게 달라질 수 있습니다.  
5. 멀티레벨 큐 (Multilevel Queue)  
   특징: 프로세스를 여러 큐로 분류하고, 각 큐에 다른 스케줄링 알고리즘을 적용합니다.  
   장점: 다양한 유형의 프로세스를 효율적으로 관리할 수 있습니다.  
   단점: 큐 사이의 이동 규칙과 각 큐에 대한 스케줄링이 복잡할 수 있습니다.  
  
## 프로세스 상태
프로세스의 상태는 프로세스가 실행되는 동안 변경되는 고유의 상태를 의미 하며 프로세스가 생성되어 실행하기 까지 프로세스는 여러가지의 상태를 갖게 되고, 상태의 변화에 따라 프로세스가 동작 되는 것이다.  
1. **생성 (Creation)**: 프로세스가 생성되며, 이 때 필요한 자원과 메모리가 할당됩니다.
2. **준비 (Ready)**: 프로세스가 CPU에서 실행될 준비가 되어 대기합니다.
3. **실행 (Running)**: 프로세스가 CPU를 할당받아 명령을 실행합니다.
4. **대기 (Waiting)**: 프로세스가 특정 이벤트나 자원을 기다리는 동안 일시적으로 중지됩니다.
5. **종료 (Termination)**: 프로세스가 실행을 완료하고 모든 자원이 해제됩니다.
  
## 프로세스 상태 전이
프로세스의 상태전이(Process State Transition)는 프로세스가 생명주기 동안 거치는 다양한 상태와 그 상태들 간의 전환을 나타낸다. 일반적으로 프로세스는 다음과 같은 상태들을 거진다.  

1. 신규 (New): 프로세스가 생성되고 초기화되는 단계입니다. 이때 커널 영역에 PCB가 만들어 짐

2. 준비 (Ready): 프로세스가 CPU에서 실행될 준비가 되어 있으며, 실행을 기다리는 상태입니다.

3. 실행 (Running): 프로세스가 CPU를 할당받아 명령어들을 실행하는 상태입니다.

4. 대기 (Waiting): 프로세스가 I/O 작업이나 특정 이벤트의 완료를 기다리는 상태입니다.

5. 종료 (Terminated): 프로세스가 실행을 완료하고 시스템에서 제거되는 상태입니다.

### 상태전이
1. 신규 -> 준비: 프로세스가 생성되어 실행을 위해 준비됩니다.

2. 준비 -> 실행: 스케줄러가 프로세스를 선택하여 CPU를 할당합니다.

3. 실행 -> 대기: 프로세스가 I/O 작업을 요청하거나 특정 이벤트를 기다려야 할 때입니다.

4. 대기 -> 준비: I/O 작업이 완료되거나 기다리던 이벤트가 발생하여 다시 CPU에서 실행될 준비가 됩니다.

5. 실행 -> 준비: 선점형 스케줄링에서, 프로세스가 CPU 할당 시간을 다 쓰거나 더 높은 우선순위의 프로세스가 준비 상태가 되었을 때 발생합니다.

6. 실행 -> 종료: 프로세스가 모든 작업을 완료하고 시스템에서 제거됩니다.
  
## 스레드 생명주기
스레드는 프로세스 내에서 실행되는 실행 단위이다. 스레드의 생명주기는 다음과 같다:

1. 생성 (New): 스레드가 생성되고 초기화됩니다.
2. 준비 (Ready): 스레드가 실행을 위해 준비되며 CPU 할당을 기다립니다.
3. 실행 (Running): 스레드가 CPU를 할당받아 실행됩니다.
4. 대기 (Blocked): 스레드가 I/O 작업과 같은 이유로 일시적으로 중지됩니다.
5. 종료 (Terminated): 스레드가 작업을 완료하고 종료됩니다.  

프로세스와 스레드의 생명주기는 운영 체제의 스케줄링 및 자원 관리와 밀접하게 연관되어 있다. 프로세스는 보다 무거운 자원 사용을 하며, 스레드는 같은 프로세스 내에서 더 가볍게 자원을 공유한다.  
  
# 프로세스 컨텍스트 스위칭
하나의 CPU는 동일한 시간에 하나의 작업만 수행할 수 있기 때문에 여러 프로세스를 동시에 실행할 수 없다. 하나의 CPU에서 여러 프로세스를 동시성으로 처리하기 위해서는 **한 프로세스에서 다른 프로세스로 전환**해야 하는데 이것을 **컨텍스트 스위치** 라고한다.  

즉, **컨텍스트 스위칭(Context Switching)은 운영 체제에서 CPU가 하나의 프로세스 또는 스레드에서 다른 프로세스 또는 스레드로 전환하는 과정**을 말한다.  
  
CPU는 한번에 하나의 프로세스만 실행할 수 있으므로, 여러개의 프로세스를 번갈아가며 실행하여 CPU 활용률을 높이기 위해 컨텍스트 스위칭이 필요하다.  
  
컨텍스트 스위칭은 **동작중인 프로세스가 대기를 하면서 해당 프로세스의 상태를 보관**하고, 대기하고 있던 **다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업**을 말한다. 이러한 컨텍스트 스위칭이 일어날때 다음번 프로세스는 스케줄러가 결정하게 된다.  
1. **현재 프로세스의 상태 저장**: 현재 실행 중인 프로세스 또는 스레드의 상태(컨텍스트)를 저장합니다. 컨텍스트에는 프로그램 카운터, 레지스터 값, 메모리 상태 등이 포함됩니다.

2. **다음 프로세스의 상태 복원**: 다음에 실행할 프로세스 또는 스레드의 컨텍스트를 복원합니다. 이를 통해 이전에 중단된 지점부터 실행을 계속할 수 있습니다.
  
### 컨텍스트(Context)
컨텍스트 스위치(context switch)에서의 `"컨텍스트"`는 운영 체제가 프로세스나 스레드를 **교체할 때 저장하고 복원해야 하는 그 프로세스나 스레드의 상태 정보**를 의미한다. Context는 CPU가 해당 프로세스를 실행하기 위한 프로세스의 정보를 의미하며 정보들은 운영체제가 관리하는 PCB 라고 하는 자료 구조 공간에 저장한다.  

## PCB( Process Control Block)
PCB(Process Control Block)는 운영 체제에서 프로세스를 관리하기 위해 사용하는 커널 내의 중요한 데이터 구조(프로세스의 상태정보등)이다.프로세스를 컨텍스트 스위칭 할때 기존 프로세스의 상태를 어딘가에 저장해 둬야 다음에 똑같은 작업을 이어 서 할 수 있을 것이고, 새로 해야 할 작업의 상태 또한 알아야 어디서부터 다시 작업을 시작할지 결졍할 수 있을 것이다.  

즉, PCB는 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보 저장하는 **임시저장소**인 것이고 컨텍스트 스위칭은 CPU가 프로세스 간 PCB(Process Control Block) 정보를 교체하고 기존에 저장했던 PCB(Process Control Block)를 비우는 일련의 과정이라고 불 수 있다.  
  
**프로세스가 생성되면 메모리에 해당 프로세스의 PCB가 함께 생성되고, 종료 시 삭제**된다. 따라서 운영체제는 PCB에 담긴 프로세스 고유 정보를 통해 프로세스를 관리하고, 프로세스의 실행 상태를 파악하고, 우선순위를 조정하며, 스케줄링을 수행하고, 다른 프로세스와의 동기화를 제어한다.  
### PCB의 주요 구성 요소
* **프로세스 식별자 (Process Identifier, PID)**: 각 프로세스를 구별하는 고유한 식별자입니다.

* **프로세스 상태 (Process State)**: 프로세스가 현재 어떤 상태에 있는지를 나타냅니다 (예: 준비, 실행, 대기).

* **프로그램 카운터 (Program Counter)**: 프로세스가 다음에 어떤 명령어를 실행해야 하는지를 가리키는 카운터입니다.

* **레지스터 세트 (Register Set)**: 프로세스 실행 중 필요한 레지스터들의 현재 값을 저장합니다.

* **메모리 관리 정보 (Memory Management Information)**: 프로세스의 주소 공간, 페이지 테이블, 세그먼트 테이블 등 메모리 관련 정보를 포함합니다.

* **계정 정보 (Accounting Information)**: 프로세스 실행 시간, 사용된 CPU 시간, 프로세스가 시작된 시간 등을 기록합니다.

* **I/O 상태 정보 (I/O Status Information)**: 프로세스에 할당된 I/O 장치 목록과 열린 파일 목록 등이 포함됩니다.  

> Register란?  
> 레지스터는 컴퓨터의 중앙 처리 장치(CPU) 내부에 있는 매우 빠른 메모리 단위입니다. 이들은 CPU가 수행하는 연산에 필요한 데이터나 연산 결과를 일시적으로 저장하는 역할을 합니다. 레지스터는 컴퓨터의 데이터 처리 속도에 큰 영향을 미치는 중요한 구성 요소입니다.  
>  
> PCB와 레지스터  
> PCB(Process Control Block) 내의 레지스터 세트는 특정 프로세스가 중단될 때 그 프로세스의 레지스터 상태를 저장합니다. 컨텍스트 스위칭 시, 이 정보는 해당 프로세스가 재개될 때 CPU에 다시 로드되어 프로세스가 중단된 지점부터 연산을 계속할 수 있도록 합니다. 이는 멀티태스킹 환경에서 각 프로세스의 실행 상태를 유지하는 데 필수적입니다.
  
## Context Switching 과정
![switching.png](src%2Fresources%2Fstatic%2Fimg%2Fswitching.png)  
해당 이미지는 두 개의 프로세스 P1과 P2가 CPU를 공유하며 실행되는 컨텍스트 스위칭 과정을 도식화한 것이다.  
1. **프로세스 P1 실행 중**: 초기 상태에서 프로세스 P1이 CPU를 사용하여 실행 중입니다.
2. **인터럽트 또는 시스템 콜 발생**: 프로세스 P1의 실행 중에 인터럽트 또는 시스템 콜이 발생합니다. 이는 CPU가 다른 작업을 수행해야 함을 의미하며, 이 때문에 프로세스 P1의 실행이 중단됩니다.
3. **프로세스 P1 상태 저장**: CPU는 프로세스 P1의 현재 상태(레지스터 값, 프로그램 카운터 등)를 프로세스 P1의 PCB(PCB1)에 저장합니다. 이로써 프로세스 P1은 중단된 지점에서 나중에 재개할 수 있습니다.
4. **프로세스 P2 상태 복원**: 이어서 CPU는 프로세스 P2의 이전 상태를 PCB(PCB2)에서 가져와 CPU에 로드합니다. 프로세스 P2는 이전에 중단됐던 지점부터 실행을 재개합니다.
5. **프로세스 P2 실행**: CPU는 이제 프로세스 P2를 실행 상태로 전환하고, 프로세스 P1은 대기 상태(Idle)로 전환됩니다.
6. **두 번째 인터럽트 또는 시스템 콜 발생**: 프로세스 P2가 실행 중일 때 또 다른 인터럽트 또는 시스템 콜이 발생합니다.
7. **프로세스 P2 상태 저장**: 프로세스 P2의 현재 상태는 PCB2에 저장됩니다.
8. **프로세스 P1 상태 복원**: 다시 프로세스 P1의 상태가 PCB1에서 가져와 CPU에 로드되어 프로세스 P1이 실행을 재개할 수 있도록 합니다.
  
## Context Switching Overhead
컨텍스트 스위칭 오버헤드(Context Switching Overhead)는 운영 체제가 하나의 프로세스에서 다른 프로세스로 전환할 때 발생하는 추가적인 시간 및 자원 소모를 말한다. 이때 전환되는 과정에서 프로세스의 상태, 레지스터 값등이 저장되고 불러오는 등의 작업이 수행되기 때문에 시스템에 많은 부담을 준다.  
  
컨텍스트 스위칭 과정에서 위의 그림에서 P1이 실행 중에 P2의 작업에 대한 실행요청이 왔을때 바로 실행되는 것이 아니라 **대기 상태**에 있다가 실행 되는 것을 확인할 수 있는데 이 **간극이 바로 컨텍스트 스위창 오버헤드 인 것**이다.  
  
즉,오버헤드는 프로세스가 실행 상태에서 대기 상태로 바뀌고, 다시 실행 상태로 돌아올 때 발생하는 일련의 작업들과 관련이 있습니다.  
  
### 오버헤드에 포함되는 주요 작업
1. 레지스터 상태 저장 및 복원
2. 메모리 관리자 업데이트
3. 캐시 초기화 또는 업데이트
4. 보안 및 접근성 업데이트
  
# 스레드 스케줄링
스레드 스케줄링은 프로세스 내의 개별 스레드에 CPU 시간을 할당하는 과정이다.즉, 스레드 스케줄링은 운영체제에서 다중 스레드를 관리하며, CPU를 사용할 수 있는 스레드를 선택하고, CPU를 할당하는 작업을 말한다.  

이는 프로세스 스케줄링과 유사하지만, 스레드는 프로세스보다 더 가벼운 실행 단위이며, 일반적으로 같은 프로세스 내의 스레드들은 일부 자원(예: 메모리)을 공유한다.이 스레드 스케줄링의 주요 목적은 CPU 사용률을 극대화하고, 프로그램의 응답 시간을 최소화하며, 시스템 전반의 처리량을 증가시키는 것이다.  

다만 스레드 스케줄링은 프로세스 스케줄링과 다르게, 하나의 프로세스 내에서 다수의 스레드가 동작하는 형태이기 때문에, 스레드 간의 상호작용과 동기화 문제를 고려해야 한다는 차이점이 존재한다.  
  
## 스레드 컨텍스트 스위치
스레드 컨텍스트 스위칭은 프로세스 컨텍스트 스위칭과 유사한 메커니즘을 가지고 있지만, 주로 같은 프로세스 내의 스레드들 사이에서 일어나며, 비교적 더 가볍다. 이는 같**은 프로세스 내의 스레드들이 코드, 데이터, 힙 영역과 같은 메모리 자원을 공유**하기 때문이다.  

### **스레드 컨텍스트 스위칭 과정**

1. **스레드 상태 저장**: 현재 실행 중인 스레드의 상태(레지스터 세트, 프로그램 카운터 등)를 저장합니다.
2. **CPU 레지스터 변경**: 다음 실행할 스레드의 상태 정보로 CPU의 레지스터를 업데이트합니다.
3. **스택 포인터 변경**: 다음 실행할 스레드의 스택 포인터로 변경하여, 해당 스레드의 스택 프레임에 접근할 수 있도록 합니다.
4. **프로그램 카운터 업데이트**: 프로그램 카운터를 다음 스레드가 계속해서 실행할 코드의 주소로 업데이트합니다.
5. **스레드 상태 복원**: 중단되었던 다른 스레드의 상태를 복원합니다.  

## TCB(Thread Control Block)
PCB 처럼, TCB (Thread Control Block)는 각 스레드마다 운영 체제에서 유지하는 스레드에 대한 정보를 담고 있는 자료 구조이다.TCB는 PCB 블록안에 들어 있다. 스레드가 프로세스 내에 위치한 것 처럼 말이다.  

프로세스의 정보를 저장하는 PCB(Process Control Block)와 유사하게, TCB는 스레드의 상태, 스레드 식별자, 레지스터 세트, 프로그램 카운터, 스택 포인터, 우선순위, 상태 정보 등 스레드 실행에 필요한 모든 정보를 포함하고 있다. TCB도 스레드가 생성될 때 운영 체제에 의해 생성되며, 스레드가 실행을 마치고 소멸될 때 함께 소멸된다.  

스레드 간의 자원 공유와 동기화도 TCB를 사용하여 관리된다. 예를 들어, 뮤텍스(mutual exclusion)나 세마포어(semaphore)와 같은 동기화 기법을 사용할 때, TCB에서 해당 스레드의 뮤텍스나 세마포어 정보를 관리하고, 스레드가 해당 자원에 대한 접근 권한을 획득하거나 반납할 때 TCB의 정보를 업데이트하게 된다.  
1. **뮤텍스 (Mutex)**:
   - 뮤텍스는 "Mutual Exclusion"의 줄임말로, 한 번에 하나의 스레드만 특정 자원에 접근할 수 있도록 합니다.
   - 뮤텍스는 임계 영역(critical section)에 대한 접근을 제어하여, 동시성 문제를 방지합니다.
   - 뮤텍스는 잠금(lock)과 해제(unlock) 메커니즘을 사용하여 자원을 보호합니다.
2. **세마포어 (Semaphore)**:
   - 세마포어는 뮤텍스와 유사하지만, 한 번에 여러 스레드가 자원에 접근할 수 있는 '카운트' 개념을 제공합니다.
   - 세마포어는 특정 자원이 여러 개 있을 때 유용하며, 자원의 사용 가능한 개수를 관리합니다.
   - 세마포어는 신호를 보내 자원을 획득하거나 반납하는 방식으로 작동합니다.
  
# 프로세스 컨텍스트 스위칭 vs 스레드 컨텍스트 스위칭
프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭은 둘 다 운영 체제가 실행 중인 작업 간에 CPU를 전환하는 데 사용하는 메커니즘입니다. 그러나 이 두 스위칭 방식 사이에는 중요한 차이점이 있다.  

1. TCB가 PCB 보다 가볍다
   - **프로세스 컨텍스트 스위칭**은 프로세스 간에 전환할 때 발생하며, 더 많은 시간과 자원을 소모합니다.
   - **스레드 컨텍스트 스위칭**은 같은 프로세스 내의 스레드들 간의 전환에 사용되며, 상대적으로 오버헤드가 적습니다.
2. 캐시 메모리 초기화
   1. 프로세스 컨텍스트 스위칭
      - 프로세스 간에 컨텍스트 스위칭을 할 때, 새로운 프로세스는 다른 메모리 공간을 사용합니다.
      - CPU 캐시에 로드된 데이터는 이전 프로세스의 메모리 주소 공간에 대응되므로, 새 프로세스에는 무효가 됩니다.
      - 결과적으로 캐시 메모리는 초기화되거나 새로운 프로세스의 데이터로 재충전되어야 합니다.
      - 이로 인해 캐시 미스가 증가하고 성능이 저하될 수 있습니다.
   2. 스레드 컨텍스 스위칭
      - 동일 프로세스 내의 스레드들은 메모리 공간을 공유하기 때문에, 캐시에 있는 데이터가 여전히 유효할 수 있습니다.
      - 스레드 간 스위칭 시에 캐시를 초기화할 필요가 없거나, 초기화가 필요한 범위가 매우 제한적입니다.
      - 따라서 스레드 스위칭은 캐시 메모리의 재사용도가 높고, 캐시 효율성이 유지되어 성능 저하가 적습니다.
3. 자원 동기화
   1. 프로세스 컨텍스트 스위칭
      - 프로세스들은 독립적인 메모리 공간을 가지고 있으며, 일반적으로 서로의 자원에 접근하지 않습니다.
      - 자원 동기화의 필요성이 상대적으로 낮고, 프로세스 간 통신을 위해서는 IPC(Inter-Process Communication) 메커니즘이 사용됩니다.
      - 프로세스 간의 자원 공유가 일어날 때는 주로 파일 시스템, 데이터베이스, 네트워크 소켓 등을 통해 관리됩니다.
   2. 스레드 컨텍스 스위칭
      - 스레드들은 같은 프로세스의 메모리 공간 내에서 코드, 데이터, 힙 등을 공유합니다.
      - 공유 자원에 대한 접근을 동기화하기 위해 뮤텍스, 세마포어, 모니터 등의 동기화 메커니즘이 필요합니다.
      - 스레드 간 동기화는 공유 자원에 대한 일관성을 유지하고 경쟁 상태(race condition)를 방지하기 위해 중요합니다.
      - 동기화는 오버헤드를 발생시킬 수 있으며, 잘못 관리될 경우 데드락(deadlock)이나 스타베이션(starvation) 같은 문제를 일으킬 수 있습니다.

## CPU Bound / IO Bound
프로세스는 CPU 작업과 I/O 작업의 연속된 흐름으로 진행된다. 프로세스는 CPU 명령어를 수행하다가 I/O를 만나면 대기하고 I/O 작업이 완료되면 다시 CPU 작업을 수행한다. 이러한 작업을 반복한다.  

이때 **CPU 바운드(CPU Bound) 와** **I/O 바운드(I/O Bound)는** 프로그램의 성능을 제한하는 요소에 대한 두 가지 다른 상황을 설명한다. 이 용어들은 프로그램이나 시스템이 어떤 자원에 의해 주로 성능이 제한되는지를 나타낸다.  

###  기본 용어

1. **Burst (버스트)**
   - 어떤 현상이 짧은 시간 안에 집중적으로 일어나는 것을 의미한다.
   - 한 작업을 짧은 시간동안 집중적으로 연속해서 처리하거나 실행하는 것
2. **Input/output (IO)**
   - 파일을 읽고 쓰거나, 네트워크 어딘가에 있는 다른 존재와 데이터를 주고받거나, 모니터/ 마우스 같은 입출력 장치와 데이터를 주고 받는 것을 IO라고 한다.
3. **CPU 버스트**
   - 프로세스가 CPU에서 한 번에 연속적으로 실행되는 시간을 의미한다. (CPU를 연속적으로 사용하면서 명령어를 실행하는 구간)
   - 메모리에 올라가 있는 프로세스가 자신의 차례가 되어서 CPU에서 실행됐을 때 자신의 명령어들이 CPU에서 연속적으로 실행되는 시간을 의미한다.
   - 프로세스가 CPU 명령어를 실행하는데 소비하는 시간 (프로세스의 RUNNING 상태를 처리)
4. **IO 버스트**
   - 프로세스가 IO 작업을 요청하고, 그 결과를 기다리는 시간을 의미한다.
   - 프로세스의 WAITING 상태를 처리

### ****CPU와 I/O 버스트의 교차****

대부분의 프로세스는 CPU 버스트와 I/O 버스트가 교대로 발생하는 패턴을 보인다. 예를 들어, 프로세스는 계산(CPU 버스트)을 수행한 후 결과를 파일에 저장(I/O 버스트)할 수 있습니다. 이러한 교차 패턴은 프로세스 스케줄링과 시스템 설계에 중요한 영향을 미칩니다. 예를 들어, CPU 바운드 프로세스는 짧고 빈번한 CPU 버스트를 보이는 반면, I/O 바운드 프로세스는 더 긴 I/O 버스트를 경험할 수 있습니다.

### 프로세스는 CPU 버스트 와 I/O 버스트의 연속된 흐름이다.

프로세스는 CPU 명령어를 수행하다가 I/O 를 만나면 대기하고 I/O 작업이 완료되면 다시 CPU 작업을 수행한다. 이 작업을 계속해서 반복하다 프로세스가 종료될땐 CPU 버스트로 마무리 된다.  

## CPU **Bounded Process**

CPU 바운드 프로세스는 주로 CPU의 처리 능력에 의해 성능이 제한되는 프로세스 이다. 이 유형의 프로세스는 계산 작업이 많으며(I/O Burst 가 거의 없는 경우), CPU의 사이클을 집중적으로 사용합니다.

예를 들어, 머신러닝, 블록체인, 동영상 편집 프로그램등 CPU 연산 위주의 작업을 하는경우를 의미한다 .CPU의 속도를 높이거나, 알고리즘을 최적화하거나, 멀티 쓰레딩 및 병렬 처리 기술을 적용하여 성능을 향상시킬 수 있다. 일반적으로 CPU 코어수와 스레드 수의 비율을 비슷하게 설정한다.

## **I/O Bounded Process**

I/O 바운드 프로세스는 입력/출력 작업에 의해 성능이 제한되는 프로세스 이다. 이 유형의 프로세스는 데이터를 읽고 쓰는 작업에 많은 시간을 소비합니다. 즉 I/O 버스트가 빈번하게 발생하는 프로세스로서 CPU 버스트가 매우 짧다.

예를 들어, 파일, 키보드, DB 네트워크 등 외부 연결이나 입출력 장치와의 통신 작업이 많은 경우에 해당된다. 더 빠른 스토리지 시스템(예: SSD), I/O 캐싱, 비동기 I/O 처리, 네트워크 대역폭 확장 등을 통해 성능을 개선할 수 있다. 이때 CPU 코어가 많을 경우 멀티 스레드의 동시성을 최대한 활용하여 CPU 가 Idle(대기상태)상태가 되지 않도록 하고 최적화 된 스레드 수를 운용해서 CPU의 효율적인 사용을 극대화 한다.  
  
## 사용자모드(User Mode) 와 커널 모드(Kernel Mode)
컴퓨터 시스템에서 "사용자 모드(User Mode)"와 "커널 모드(Kernel Mode)"는 운영 체제의 두 가지 주요 실행 모드를 나타낸다. 이들은 시스템 자원에 대한 접근 수준과 관련된 권한을 구분한다.  

## **커널(kernel)**

운영체제는 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어이고 여러 핵심 기능을 담당하는 부분을 **커널(kernel)** 이라고 한다.

![9914C3435D4024A324.png](src%2Fresources%2Fstatic%2Fimg%2F9914C3435D4024A324.png)

커널은 운영 체제의 핵심 구성 요소로, 시스템의 하드웨어와 소프트웨어 사이에서 **중개자 역할**을 합니다. 기본적으로 커널은 컴퓨터의 하드웨어 자원과 관련된 모든 저수준 작업을 관리한다. 이것은 컴퓨터가 제대로 기능할 수 있도록 여러 중요한 서비스를 제공한다.  

즉, 사용자가 운영체제 위에서 실행되는 프로그램을 편하고 효율적으로 사용할 수 있게 하드웨어와 소프트웨어 간 중개 자 역할을 하고 CPU, I/O 장치, 메모리, 저장소와 같은 하드웨어 자원을 프로그램에 잘 할당하는 데 있다.  


> **저수준 작업 이란?**
>
>
> "저수준 작업(Low-level operations)"이라는 용어는 컴퓨터 프로그래밍 및 시스템 설계에서 하드웨어에 가까운 작업을 가리킵니다. 이러한 작업은 하드웨어 자원과 밀접하게 상호작용하며, 보통 운영 체제의 커널이 담당합니다. 저수준 작업은 추상화 수준이 낮아서, 일반적으로 다음과 같은 활동을 포함합니다:
>
> 1. **메모리 관리**: 물리적 메모리 할당, 해제, 페이지 교체, 가상 메모리와 페이지 테이블 관리 등.
> 2. **프로세스 스케줄링**: CPU 시간 할당, 프로세스 상태 관리, 컨텍스트 스위칭 등 프로세스 실행을 조율하는 작업.
> 3. **디바이스 드라이버 인터페이스**: 하드웨어 장치와의 통신을 위한 인터페이스를 제공하며, 입출력 요청의 중재, 버퍼 관리 등을 수행합니다.
> 4. **시스템 호출 처리**: 사용자 모드 프로세스가 요청하는 다양한 시스템 서비스에 대한 접근과 실행을 관리합니다.
> 5. **인터럽트 처리**: 하드웨어나 소프트웨어 인터럽트를 받고 적절한 처리 루틴을 실행합니다.
> 6. **네트워크 스택 관리**: 데이터 패킷의 송수신, 네트워크 인터페이스 관리, 프로토콜 처리 등 네트워크 통신에 필요한 작업을 수행합니다.
> 7. **보안 기능**: 사용자 인증, 접근 권한 체크, 암호화 및 해독 등의 보안 관련 기능을 실행합니다.

운영체제는 응용 프로그램(Application)이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호한다.만약에 응용 프로그램이 하드웨어 자원에 직접 접근해서 조작 할 수 있다면 자원 관리가 되지 않고 프로세스 간 데이터가 훼손되어 컴퓨터 시스템 전체에 오류를 가져오게 된다. 따라서 **응용프로그램이 하드웨어 자원에 접근하려고 할때는 반드시 운영체제를 통해서만 접근**하도록 한다.  
  
즉, 응용 프로그램(Application)이 하드웨어에 접근을 하기위해서는 운영체제의 권한을 이용해서 접근을 해야한다.

## ****CPU Protection Ring****

운영체제는 프로세스들을 처리하기 위해 CPU의 기능과 시스템 자원에 접근할 수 있어야 한다. 하지만 컴퓨터의 주요한 자원에 무분별하게 접근할 수 있는 것은 아니다. 운영체제는 접근할 수 있는 권한이 부여된 요청만 CPU에 접근을 허락한다. 이 권한은 4가지로 분류되며, 접근 권한들을 분류하여 나눈 것을 CPU Protection Ring이라고 한다.

![cpuRing.png](src%2Fresources%2Fstatic%2Fimg%2FcpuRing.png)

CPU 보호 링(CPU Protection Rings)은 컴퓨터 시스템에서 보안 및 접근 제어를 제공하기 위해 사용되는 메커니즘이다. 이 개념은 주로 운영 체제와 하드웨어 아키텍처에서 사용되며, 다양한 권한 수준을 가진 여러 "링" 또는 "레벨"로 시스템을 분할하고 각 링은 서로 다른 권한과 책임을 가지며, 중심으로 갈수록 더 높은 권한을 가진다.  

CPU Protection Ring은 일반적으로 0부터 3까지의 숫자로 표현되며, 낮은 숫자일수록 더 높은 권한을 나타낸다. 주로 0부터 3까지의 권한 레벨이 사용된다.

- **레벨 0 (Level 0)**: 이것은 시스템의 **커널이 실행되는 가장 낮은 레벨**로, 시스템의 모든 자원에 대한 완전한 제어 권한을 가지고 있습니다. 여기에서 운영 체제의 핵심 부분들이 실행되며, 메모리 관리, 프로세스 스케줄링, 하드웨어와의 직접적인 상호작용 등을 담당합니다.
- **레벨 1 (Level 1)과 레벨 2 (Level 2)**: 이 레벨들은 일반적으로 **운영 체제의 특정 서브시스템**이나 **드라이버들에 의해 사용**됩니다. 이들은 커널 모드보다는 제한된 권한을 가지지만, 사용자 모드보다는 더 많은 시스템 자원에 접근할 수 있습니다. 대부분의 현대 운영 체제는 이 레벨들을 명시적으로 사용하지 않습니다.
- **레벨 3 (Level 3)**: **가장 바깥쪽 원이자 가장 낮은 권한을 가진 사용자 모드**입니다. 일반 애플리케이션들은 이 레벨에서 실행되며, 운영 체제로부터 제공받는 API를 통해 시스템 자원을 사용합니다. 이 레벨의 프로그램들은 직접적으로 하드웨어에 접근할 수 없으며, 모든 작업을 수행하기 위해 운영 체제에 요청을 보내야 합니다.

**0은 가장 높은 권한을 가진 커널 모드(Kernel Mode)이고**,**3은 가장 낮은 권한을 가진 사용자 모드(User Mode)이다.**

권한 레벨이 높은 커널 모드(Level 0)는 **운영체제와 시스템 자원에 대한 접근이 가능**하다. 반면에 **사용자 모드(Level 3)는** 프로세스가 제한된 자원에만 접근할 수 있으며, 시스템 자원에 직접 접근하는 것은 제한된다. 운영체제는 CPU Protection Ring을 사용하여 사용자 프로세스 간의 충돌, 잘못된 접근, 시스템 자원의 남용 등을 방지하고, 운영체제의 안정성을 유지할 수 있다. 그리고 시스템 보안을 강화하여 악성 코드나 해킹 시도로부터 시스템을 보호한다.  

## CPU 권한 모드

CPU의 권한 모드는 **운영 체제가 시스템의 자원과 작업을 관리하는 방법**을 정의합니다. 가장 일반적인 두 가지 모드는 사용자 모드(User Mode)와 커널 모드(Kernel Mode)입니다.  
  
![cpuMode.png](src%2Fresources%2Fstatic%2Fimg%2FcpuMode.png)

### 사용자 모드(Mode Bit =1)

사용자 모드는 응용 프로그램이 실행되는 일반적인 모드입니다. 이 모드에서는 제한된 시스템 자원과 메모리에만 접근할 수 있다.

사용자 응용프로그램의 코드가 실행 되는 모드로서 메모리의 유저영역만 접근 가능하다. 사용자 모드에서 실행되는 프로그램은 커널 모드에서 허용하지 않는 일부 작업을 수행할 수 없습니다.  예를 들어 디스크, 메모리, Printer 및 여러 I/O 장치들과 같은 특정 리소스들에 직접 접근할 수 없다. 이는 시스템의 보안과 안정성을 유지하는 데 도움이 됩니다.

대부분의 **응용프로그램은 입출력 장치나 파일로의 접근이 필요하기 때문에 이때는 유저모드에서 커널모드로 전환** 되어야 한다.

### 커널 모드 (Mode Bit =0)

커널 모드는 운영 체제의 핵심 부분이 실행되는 모드로, 시스템의 모든 자원에 대한 완전한 접근 권한이 있다. 이 모드에서 실행되는 코드는 하드웨어와 직접 상호작용할 수 있으며, 메모리 관리, 프로세스 관리, 하드웨어 장치 제어 등의 중요한 작업을 수행한다.

즉, 메모리의 유저영역, 커널영역 모두 접근 가능하다.

## 시스템 콜

시스템 콜(System Call)은 **응용 프로그램이 운영 체제의 커널 서비스를 요청할 때 사용하는 인터페이스**입니다. 간단히 말해, 시스템 콜은 사용자 모드에서 실행 중인 프로그램이 커널 모드의 기능을 이용하고자 할 때 커널에 접근하는 방법이다.  

### **시스템 콜의 역할**

1. **하드웨어 접근**: 직접적인 하드웨어 접근은 커널 모드에서만 가능하기 때문에, 응용 프로그램은 시스템 콜을 통해 하드웨어 자원을 안전하게 사용할 수 있습니다.
2. **자원 관리**: 파일 시스템 작업, 네트워크 통신, 프로세스 관리와 같은 시스템 자원을 효율적으로 관리합니다.
3. **보안과 안정성**: 시스템 콜은 사용자 모드와 커널 모드 간의 중요한 경계를 형성하여, 시스템의 안전과 안정성을 유지하는 데 기여합니다.

### **시스템 콜의 종류**

- **프로세스 관리**: 프로세스 생성 및 종료, 스케줄링 등을 관리합니다.
- **파일 조작**: 파일 열기, 읽기, 쓰기, 닫기 등의 파일 시스템 관련 작업을 수행합니다.
- **장치 관리**: 하드웨어 장치와의 통신과 관리를 담당합니다.
- **정보 유지**: 시스템 시간, 시스템 데이터 등에 대한 정보를 조회하거나 설정합니다.
- **통신**: 프로세스 간 통신(IPC)이나 네트워크 통신을 위한 시스템 콜입니다.

### **시스템 콜의 작동 방식**

1. **요청**: 응용 프로그램이 특정 작업을 수행하기 위해 시스템 콜을 요청합니다.
2. **모드 전환**: 시스템 콜이 실행되면 CPU는 사용자 모드에서 커널 모드로 전환됩니다.
3. **실행**: 커널은 요청된 작업을 수행합니다.
4. **복귀**: 작업이 완료되면 CPU는 다시 사용자 모드로 전환되고, 응용 프로그램으로 제어가 반환됩니다.

사용자 응용 프로그램은 작업 과정에서 커널의 기능을 사용하기 위해 매우 빈번하게 시스템 콜을 요청하고 이로 인해 사용자 모드와 커널 모드를 상호 전환하며 실행하게 된다. I/O 처리를 위해 사용자 모드와 커널 모드를 번갈아 오가는 것은 컨텍스트 스위칭과 관련이 있으며 이는 멀티 스레드 환경에서 참고해야 할 중요한 배경적 지식이다.

즉, 응용프로그램이 파일 입출력이나, 화면에 메시지를 출력하는 등의 기능은 커널 모드 일때 CPU가 실행하기 때문에 반드시 시스템 콜을 사용해서 커널 모드로 전환해야 한다.  
  
## 사용자 수준 스레드 , 커널 수준 스레드
**사용자 수준 스레드(User-Level Threads)와** **커널 수준 스레드(Kernel-Level Threads)는** 운영 체제에서 스레드를 관리하는 두 가지 기본적인 방식을 나타낸다. 이 두 방식은 스레드의 생성, 스케줄링, 관리 방법에 있어서 차이를 가진다. 즉 생성 주체가 누구냐에 따라 구분된다.

사용자 수준 스레드는 사용자 프로그램에서 관리하는 스레드며 커널 수준 스레드는 OS 에서 관리하는 스레드이다

## **사용자 수준 스레드** (User Level Thread)

사용자 수준 스레드란 사용자 영역에서 스레드 라이브러리(Pthreads, Windows Threads, Java Threads(JVM)) 에 의해 스레드의 생성과 종료, 스레드간 메시지 전달, 스레드의 스케쥴링 보관 등 모든 것을 관리한다. 커널에 대한 추가적인 시스템 호출이 필요 없기 때문에 스레드의 생성, 전환, 스케줄링이 빠르다는 장점이 있다.

단, **커널은 이러한 스레드의 존재를 인지하지 못하며 단일 스레드 프로세스인 것처럼 관리**한다. 한 스레드가 블록되면 프로세스 내의 모든 스레드가 블록될 수 있다. 또한, 멀티코어 활용에 제한이 있을 수 있다.

## **커널 수준 스레드** (Kernel Level Thread)

커널 수준 스레드는 운영 체제 커널에 의해 직접 관리됩니다(PCB와 TCB 관리 및 유지). 커널은 모든 스레드를 알고 있으며 각 스레드에 대한 정보를 가지고 있다.이때 커널은 커널 스레드의 모든 정보를 알고 있으며 커널 스레드는 OS 스케줄러에 의해서 스케줄링 된다. **CPU 는 커널에 의해 생성된 커널 스레드의 실행만을 담당한다.**

스레드 관리를 위한 시스템 호출이 필요하므로, 사용자 수준 스레드에 비해 오버헤드가 더 크다. 커널이 각 스레드를 개별적으로 관리할 수 있으므로, 멀티프로세서 시스템에서의 스레드 스케줄링과 병렬 처리가 용이하다.

# ****Multi Process 와 Multi Thread****

멀티 프로세스(Multi Process)와 멀티 스레드(Multi Thread)는 컴퓨터 프로그래밍에서 작업을 병렬로 처리하기 위한 두 가지 주요한 방식이다. 각각은 다른 메커니즘과 특성을 가지고 있으며, 특정 상황에 따라 적합한 방식을 선택하는 것이 중요합니다.

프로세스와 스레드가 단일이 아닌 다중으로 돌아감으로써 성능 향상 등 여러가지 효과를 얻을 수 있게 된다. 하지만 또한 이로 인해 발생되는 부가적인 문제점도 발생하게 된다. 따라서 각각의 장단점을 파악하여 적재적소에 사용하는 것이 요구된다.

## ****Multi Process****

멀티 프로세스는 운영체제에서 하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 실행할 수 있게 하는 기술을 말한다. 보통 하나의 프로그램 실행에 대해 하나의 프로세스가 메모리에 생성되지만, 부가적인 기능을 위해 여러개의 프로세스를 생성하는 것이다.

- 멀티 프로세스 와 멀티 프로세서
   - 프로세스(Process) 는 프로그램의 실행 상태를 말함
      - 멀티 프로세스: 하나의 프로그램에서 여러개의 프로세스를 실행하는 것
   - 프로세서(rocessor)는 CPU 코어를 말한다.
      - 멀티 프로세서: 여러개의 CPU 코어가 하나의 시스템에서 동시에 실행되는 것

멀티 프로세스 내부를 보면, **하나의 부모 프로세스가 여러개의 자식 프로세스를 생성**함으로서 다중 프로세스를 구성하는 구조이다.

한 프로세스는 실행되는 도중 프로세스 생성 시스템 콜을 통해 새로운 프로세스들을 생성 할 수 있는데 다른 프로세스를 생성하는 프로세스를 부모 프로세스(Parent Process)라 하고, 다른 프로세스에 의해 생성된 프로세스를 자식 프로세스(Child Process)라고 한다.

부모 프로세스와 자식 프로세스는 **고유한 PID(Process ID**)를 가지고 있다.

부모 프로세스는 자식 프로세스의 PID를 알고 있으므로, 이를 통해 자식 프로세스를 제어 할 수 있다.

자식 프로세스는 부모 프로세스의 PID 와 PPID(Parent Process ID)를 알고 있어, 이를 통해 부모 프로세스와 통신이 가능하다.

다만, 통신이 가능할 뿐이지, **부모 프로세스와 자식 프로세스는 엄연히 서로 다른 프로세스로 독립적으로 실행**되며, **독립적인 메모리 공간**을 가지고 있어서 **서로 다른 작업을 수행**한다.
예로는 웹 브라우저의 탭 이나 새창을 들 수 있다. 각 브라우저 탭은 같은 브라우저 프로그램 실행이지만, 각기 다른 사이트 실행을 행하기 때문이다.

서로 독립적이라는 것을 확인하기 위해서는 브라우저에서 갭라자 도구를 연다음 무한 루프 코드를 실행 시켜보면, 해당 탭에서는 클릭도 안되고 먹통이 되지만 다른 탭은 정상적으로 동작하는 것을 확인 할 수 있다.

- **장점**:
   - 안정성: 한 프로세스의 오류가 다른 프로세스에 영향을 미치지 않아 시스템 전체의 안정성이 유지됩니다.
   - 보안: 프로세스 간의 격리로 인해 보안이 강화됩니다.
- **단점**:
   - 오버헤드: 프로세스 간 커뮤니케이션(IPC)이 복잡하고, 자원 소모가 큽니다.
   - 리소스 사용: 각 프로세스가 별도의 메모리와 시스템 자원을 사용하기 때문에 리소스 사용이 비효율적일 수 있습니다.

## Multi Thread

스레드는 **하나의 프로세스 내에 있는 실행 흐름**이다. 그리고 멀티 스레드는 **하나의 프로세스 안에 여러개의 스레드가 있는 것**을 말한다. 따라서 하나의 **프로그램에서 두가지 이상의 동작을 동시에 처리하도록 하는 행위가 가능**해진다.

즉, 멀티 스레드는 하나의 프로세스 내에서 여러 개의 스레드가 동시에 실행되는 환경을 말합니다. 모든 스레드는 프로세스의 메모리 공간을 공유한다.

웹 서버는 대표적인 멀티 스레드 응용 프로그램이다. 사용자가 서버 데이터베이스에 자료를 요청하는 동안 브라우저의 다른 기능을 이용할 수 있는 이유도 바로 멀티 스레드 기능 덕분이니 것이다. 즉, 하나의 스레드가 지연되더라도, 다른 스레드는 작업을 지속할 수 있다

멀티 프로세스와 차이점을 부각시키기 위해, 멀티 프로세스를 설명할때 예시를 들었던 웹 브라우저를 다시 들어보면, **멀티 프로세스는 웹 브라우저에서의 여러 탭**이나 **여러창** 이라면, 멀티 스레드는 **웹 브라우저의 단일 탭 또는 창 내에서 브라우저 이벤트 루프, 네트워크 처리, I/O 및 기타 작업을 관리**하고 처리하는데 사용된다.

- **장점**:
   - 효율성: 스레드 간의 커뮤니케이션 비용이 낮고, 컨텍스트 스위칭이 빠릅니다.
   - 자원 공유: 메모리 및 자원을 공유하여 효율적인 리소스 사용이 가능합니다.
- **단점**:
   - 안정성과 보안 문제: 하나의 스레드에서 발생한 오류가 전체 프로세스에 영향을 줄 수 있으며, 스레드 간 데이터 공유로 인해 **동기화 문제**가 발생할 수 있습니다.

> **동기화란?**
> 스레드에서의 동기화는 **멀티스레딩 환경에서 여러 스레드가 공유 자원에 동시에 접근할 때 발생할 수 있는 문제들을 관리하고, 데이터의 일관성과 정확성을 유지하기 위한 방법**입니다.
>

> **동기화 적업
여러 스레드들이 자원에 대한 접근을 순차적으로 통제 하는 것**
> 동시 접근으로 인한 동시 수정과 같은 현상은 일어나지 않게 된다. 그러나 동기화 작업은 여러 스레드 접근을 제한하는 것이기 때문에 **병목 현상**이 일어나 성능이 저하될 가능성이 높다는 단점이 있다.
> 이를 해결하기 위해 임계 영역(Critical Section)에 대하여 뮤텍스(mutex), 또는 세마포어(Semaphore) 방식을 활용한다.
>
> - **임계 영역(Critical Section)**: 여러 스레드가 동시에 접근해서는 안 되는 코드 영역. 일반적으로 공유 자원을 처리할 때 사용됩니다.
> - **뮤텍스(Mutex)**: 임계 영역에 대한 접근을 제어하기 위한 잠금 메커니즘. 한 번에 하나의 스레드만 임계 영역에 접근할 수 있습니다.
> - **세마포어(Semaphore)**: 뮤텍스와 유사하지만, 동시에 여러 스레드가 임계 영역에 접근할 수 있도록 허용하는 카운터 기반의 메커니즘입니다.

> **동기화와 관련된 문제**
>
> - **데드락(Deadlock)**: 둘 이상의 스레드가 서로의 락 해제를 무한히 기다리는 상황으로, 프로그램이 정지하는 원인이 됩니다.
> - **라이브락(Livelock)**: 스레드들이 서로를 방해하지 않도록 반복적으로 상태를 변경하지만, 실제로는 어떤 작업도 진행되지 않는 상황입니다.
> - **스타베이션(Starvation)**: 특정 스레드가 공유 자원에 접근하지 못하고 무한히 대기하는 상황입니다.

## 멀티스레딩 모델

CPU는 OS 스케쥴러가 예약하는 커널 스레드만 할당 받아서 실행하기 때문에 사용자 수준 스레드는 커널 수준 스레드와의 매핑이 필요하다.  
  
멀티스레딩 모델은 운영 체제가 프로세스 내의 스레드를 어떻게 관리하고 스케줄링하는지에 대한 접근 방식을 말한다. 사용자 수준 스레드는 다음과 같은 방법으로 커널수준 스레드와 매핑한다. 주요 모델에는 대표적으로 "일대일(1:1)", "다대일(N:1)", "다대다(M:N)" 모델이 있고 각 모델은 스레드 생성, 관리, 스케줄링의 방법과 운영 체제와의 상호작용에서 차이를 보인다.  
  
![maxresdefault.jpg](src%2Fresources%2Fstatic%2Fimg%2Fmaxresdefault.jpg)

### 다대일 스레드 매핑 (many to one thread mapping)

다수의 사용자 수준 스레드가 커널 수준 스레드 한개에 매핑하는 유형으로 사용자 수준의 스레드 모델이라 볼 수 있다.  
 
이때 커널수준의 스레드는 사용자 수준의 스레드를 전혀 알지 못한다. 커널 수준의 스레드는 사용자 수준의 스레드의 TCB 정보를 가지고 있지 않기 때문이다. 이는 사용자 수준의 스레드가 몇개가 있고 현재 선점된 스레드는 무엇이며 어떤식으로 컨텍스트 스위칭할지를 알 수 없다. 두 개의 영역은 서로 매핑은 되어 있지만 서로의 정보를 알지는 못한다.  
  
**그러면 매핑은 왜** 시키는 것일까??  
그 이유는 CPU는 커널 수준의 스레드만 인식한다. 즉, CPU는 직접적으로 사용자 수준의 스레드를 인식할 수 없기 때문에 사용자 수준에서 실행되는 모든 코드들은 먼저 커널 스레드에게 전달된 후 CPU에게 할당 받는 목적으로만 매핑을 하는 것이다.

- **장점**:
   - 스레드 관리에 필요한 오버헤드가 낮습니다.
      - 커널 개입 없이 사용자 스레드끼리의 스위칭이 발생하기 때문에 오버헤드가 적다.
      - 스케쥴링이나 동기화를 하려고 커널을 호출하지 않으므로 커널 영역으로 전환하는 오버헤드가 줄어든다
   - 사용자 수준에서 스레드 스케줄링을 제어할 수 있습니다.
- **단점**:
   - 멀티코어 CPU를 효율적으로 사용하기 어렵습니다.
   - 하나의 스레드가 블록되면 모든 스레드가 블록될 수 있습니다.
- **예시**: 구형 UNIX 시스템, 자바에서 초기 버전의 Green Thread

### 일대일 스레드 매핑 (one to one thread mapping)

사용자 수준 스레드와 커널 수준 스레드가 일대일로 매핑하는 유형으로 커널 **수준의 스레드 모델**이라 볼 수 있다. 커널이 전체 프로세스와 스레드 정보를 유지해야 하기 때문에 컨텍스트 스위칭 시 사용자 모드에서 커널 모드로 전환해서 스케줄링 하는 등의 오버헤드가 발생한다. 
  
해당 매핑은 사용자 수준의 스레드는 생성만 해두고 모든 관리는 커널수준 스레드에서 관리하게된다.(TCB를 커널수준 스레드에서 관리)
- **장점**:
   - 멀티코어 CPU에서 효율적입니다. 각 스레드가 다른 CPU 코어에서 동시에 실행될 수 있습니다.
   - 하나의 스레드에 문제가 발생해도 다른 스레드에 영향을 덜 미칩니다.
- **단점**:
   - 스레드 생성과 관리에 더 많은 시스템 자원이 필요합니다.
   - 자원 한정으로 인해 스레드를 무한정 생성할 수 없다. 대안으로 스레드 풀을 활용하기도 한다.
- **예시**: Linux, Windows, MacOS.

### 다대다 스레드 매핑(many to many thread mapping)

여러 개의 사용자 수준 스레드를 같은 수 또는 그 보다 작은 수의 커널 수준 스레드로 매핑하는 유형이다. 각 커널 수준의 스레드가 사용자 수준의 스레드 한개 이상과 매핑된다.다대다 모델은 다대일, 일대일 모델의 단점을 어느 정도 해결하여, 개발자는 필요한 만큼 많은 사용자 수준 스레드를 생성할 수 있고 커널 수준 스레드가 멀티 프로세서에서 병렬로 수행될 수 있다

- **특징**: 여러 사용자 수준 스레드가 여러 커널 스레드와 대응됩니다.
- **장점**:
   - 스레드 관리의 유연성이 높고, 멀티코어 CPU 환경에서 효과적입니다.
   - 사용자 수준과 커널 수준에서 스레드를 동시에 관리할 수 있습니다.
- **단점**:
   - 구현의 복잡성이 높고, 오버헤드 관리가 어렵습니다.
- **예시**: Solaris, 구형 버전의 Windows.

사용자 수준 스레드가 I/O 시스템 콜을 발생시켰을 때, 커널이 다른 스레드의 수행을 스케줄 할 수 있다  
  
# 자바 스레드 구조
자바 스레드는 JVM 에서 사용자 수준 스레드를 생성할 때 시스템 콜을 통해서 커널에서 생성된 커널 스레드와 1:1 매핑이 되어 최종적으로 커널에서 관리 됩니다. JVM 에서 스레드를 생성할때 마다 커널에서 자바 스레드와 대응하는 커널 스레드를 생성한다. 자바에서는 Platform Thread 으로 정의되어있다. 즉 OS 플랫폼에 따라 JVM 이 사용자 스레드를 매핑하게된다

> **Platform threads**
"플랫폼 스레드(Platform Thread)"라는 용어는 일반적으로 **특정 운영 체제에서 네이티브로 제공하는 스레드**를 가리킵니다. 자바에서 스레드를 생성할 때, JVM(Java Virtual Machine)은 내부적으로 운영 체제의 스레드 시스템을 사용하여 이러한 스레드를 구현합니다. 즉, 자바 스레드는 운영 체제의 플랫폼 스레드에 매핑됩니다.

**네이티브 스레드**
"네이티브 스레드"는 **특정 운영 체제에서 지원하는 스레드**를 의미합니다. 이는 운영 체제의 API를 통해 생성되고 관리됩니다.
****주로 프로그래밍 언어나 애플리케이션 수준에서 운영 체제의 스레드를 사용할 때 쓰입니다. 자바 애플리케이션에서 생성된 스레드가 운영 체제의 API를 통해 생성되고 관리되는 스레드를 가리키는데 사용됩니다. 네이티브 스레드는 JVM과 같은 런타임 환경에 의해 추상화되어 관리되며, 이는 운영 체제의 커널 스레드에 매핑됩니다.

### **JVM에서의 스레드 처리**

JVM은 자바 애플리케이션을 실행하는 환경입니다. JVM 내부에서 스레드는 다음과 같이 처리됩니다:

- JVM은 각 스레드에 대한 메모리 할당(스택 등)을 관리합니다.
- 자바 스레드는 내부적으로 OS의 네이티브 스레드에 매핑됩니다. 이 매핑은 JVM의 스레드 모델과 OS에 따라 다를 수 있습니다.
- JVM은 스레드의 생명주기(생성, 시작, 실행, 종료)를 관리합니다.

### **OS 스레드 스케줄링과의 차이**

- **운영 체제 수준의 스레드**: 운영 체제는 자체 스레드 스케줄러를 가지고 있으며, 모든 스레드(시스템 스레드 및 사용자 애플리케이션 스레드)를 관리합니다. 이 스케줄러는 CPU 시간을 스레드에 할당하고, 스레드의 실행 순서를 결정합니다.
- **자바 스레드**: 자바에서 생성된 스레드는 결국 OS의 네이티브 스레드로 매핑됩니다. 즉, 실제 스레드의 스케줄링은 OS에 의해 이루어집니다. JVM은 스레드 생성, 관리, 종료 등의 과정을 추상화하고, 자바 프로그래머가 OS에 직접적으로 의존하지 않고 스레드를 사용할 수 있게 합니다.

## 스레드 생성

자바에서 스레드는 주로 두 가지 방법으로 생성됩니다:

1. **`Thread`** 클래스를 상속받아서 구현.
2. **`Runnable`** 인터페이스를 구현.

1. **`Thread` 클래스 상속**:

    ```java
    class MyThread extends Thread {
        public void run() {
            // 스레드가 수행할 작업
        }
    }
    
    Thread thread = new MyThread();
    thread.start(); // 스레드 시작
    
    ```

    - 작업 내용을 스레드 내부에 직접 재정의해서 실행
2. **`Runnable` 인터페이스 구현**:

    ```java
    class MyRunnable implements Runnable {
        public void run() {
            // 스레드가 수행할 작업
        }
    }
    
    Thread thread = new Thread(new MyRunnable());
    thread.start(); // 스레드 시작
    
    ```

    - 작업 내용을 Runnable 에 정의해서 스레드에 전달
3. **람다 표현식 사용 (Java 8 이상)**:

    ```java
    Runnable task = () -> {
        // 스레드가 수행할 작업
    };
    
    Thread thread = new Thread(task);
    thread.start(); // 스레드 시작
    
    ```


1. **Thread 익명 클래스**

    ```java
    Thread thread = new Thread() {
        public void run() {
            // 스레드가 실행할 코드
            System.out.println("Thread 익명 클래스 사용");
        }
    };
    
    thread.start(); // 스레드 시작
    ```

    - 일회용으로만 사용할때
2. **Runnable 익명 클래스**

    ```java
    Runnable runnable = new Runnable() {
        public void run() {
            // 스레드가 실행할 코드
            System.out.println("Runnable 익명 클래스 사용");
        }
    };
    
    Thread thread = new Thread(runnable);
    thread.start(); // 스레드 시작
    ```


### **스레드 상태 변경 메서드**

1. **`start()`**: 새로운 스레드를 시작하고, 스레드의 **`run()`** 메서드를 호출합니다.
2. **`run()`**: 스레드가 수행할 작업을 정의합니다.
3. **`sleep(long millis)`**: 현재 스레드를 지정된 시간(밀리초) 동안 일시 중지합니다.
4. **`join()`**: 스레드가 종료될 때까지 현재 스레드의 실행을 중지합니다.
5. **`interrupt()`**: 스레드에 인터럽트를 보냅니다. 인터럽트에 응답하는 방식은 스레드의 **`run()`** 메서드 구현에 달렸습니다.
6. **`yield()`**: 현재 스레드가 실행 중지를 하고 다른 스레드에 실행 기회를 제공합니다.

### **기타 메서드**

- **`setPriority(int newPriority)`**: 스레드의 우선순위를 설정합니다.
- **`getPriority()`**: 스레드의 현재 우선순위를 반환합니다.
- **`setName(String name)`**: 스레드의 이름을 설정합니다.
- **`getName()`**: 스레드의 이름을 반환합니다.
- **`isAlive()`**: 스레드가 살아 있는지(시작되었고 아직 종료되지 않았는지) 확인합니다.
- **`isInterrupted()`**: 스레드가 인터럽트 되었는지 확인합니다.
- **`static interrupted()`**: 현재 스레드의 인터럽트 상태를 확인하고, 인터럽트 상태를 초기화합다.  

# 스레드 실행

자바 스레드는 OS 스케줄러에 의해 실행 순서가 결정되며 스레드 실행 시점을 JVM 에서 제어할 수 없고 새로운 스레드는 현재 스레드 와 독립적으로 실행되고 최대 한번 시작할 수 있고 스레드가 종료된 후에는 다시 시작 할 수 없다.

자바에서 스레드 실행 과정을 설명하기 위해, 가장 기본적인 예로 **`main`** 스레드가 다른 스레드를 생성하고 시작하는 과정을 살펴보면 자바에서 스레드 실행 과정은 다음과 같은 단계를 거친다.

1. **스레드 클래스 정의**: 자바에서 스레드를 생성하기 위해서는 **`Thread`** 클래스를 확장하거나 **`Runnable`** 인터페이스를 구현하는 클래스를 정의해야 합니다.
2. **스레드 객체 생성**: 정의된 스레드 클래스 또는 **`Runnable`** 객체를 기반으로 **`Thread`** 객체를 생성합니다.
3. **스레드 시작 (`start()` 메서드 호출)**: 생성된 스레드 객체에 대해 **`start()`** 메서드를 호출합니다. 이 메서드는 스레드를 실행 가능한 상태로 만들고, 자바 가상 머신(JVM)에 이 스레드를 시작하도록 요청합니다.
4. **`private native void start0()` 메서드 호출**: 내부적으로 **`start()`** 메서드는 네이티브 메서드인 `private native void start0()`을 호출합니다. 이 메서드는 운영 체제 수준에서 새로운 스레드를 생성하고(커널 스레드가 생성되고 자바 스레드와 커널 스레드가 1대1 매핑이 이루어짐), 스레드에 할당된 **`run()`** 메서드를 실행합니다.
5. **실행 대기** : OS 스케줄러로 부터 CPU 할당을 받기까지 실행 대기 상태에 있는다.
6. **스레드 실행 (`run()` 메서드 실행)**: **`run()`** 메서드는 스레드가 수행해야 할 작업을 정의합니다. **`start0()`**에 의해 호출되면, 이 스레드는 **`run()`** 메서드에 정의된 작업을 수행하기 시작합니다.(커널 스레드가 스케줄러에 의해 실행상태가 되면 JVM 에서 매핑된 자바 스레드의 run() 메서드를 호출한다.)
7. **스레드 종료**: **`run()`** 메서드의 실행이 완료되면, 스레드는 자동적으로 종료됩니다.

> **네이티브 메서드(native method)**
> 네이티브 메서드(native method)는 자바에서 사용되는 **특별한 유형의 메서드**로, **자바 코드가 아닌 네이티브 프로그래밍 언어(보통 C나 C++)로 작성된 코드를 실행**합니다. 이러한 메서드들은 자바 네이티브 인터페이스(Java Native Interface, JNI)를 사용하여 구현됩니다.
>

예를 들어, **`main`** 스레드에서 새로운 스레드를 생성하고 시작하는 간단한 예제

```java
public class MyThread extends Thread {
    public void run() {
        System.out.println("새로운 스레드 실행 중");
    }

    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start(); // 여기에서 start0()가 내부적으로 호출되고, 스레드 실행이 시작됩니다.
    }
}

```

이 과정을 통해, 자바 프로그램에서는 멀티스레딩을 효과적으로 관리하고, 여러 작업을 동시에 수행할 수 있다.

즉, `start()` 는 스레드를 실행 시키는 메서드로 **시스템 콜을 통해서 커널에 스레드 생성을 요청 `run()`** 는 **스레드가 실행이 되면 해당 스레드에 의해 자동을 호출**되며 Thread 의 run() 이 자동으로 호출되고 여기서 Runnable 구현체가 존재할 경우 Runnable 의 run()을 실행한다. public static void main 가 메인 스레드에 의해 자동으로 호출되는 것과 비슷한 원리이다.

이때 start() 메서드가 아니라 바로 run() 메서드를 직접 호출하면 새로운 스레드가 생성되지 않고 직접 호출한 스레드의 실행 스택에서 run()이 실행된다.

1. **`start()` 메서드 호출**:
    - 새로운 스레드를 생성합니다. **`start()`** 메서드가 호출되면, 자바 가상 머신(JVM)은 새로운 스레드를 배치하고, 이 스레드에서 **`run()`** 메서드를 실행합니다.
    - **`start()`** 메서드는 내부적으로 네이티브 메서드를 호출하여 실제 운영 체제 스레드를 생성하고, 해당 스레드에서 **`run()`** 메서드를 별도의 실행 경로(execution path)에서 실행합니다.
    - 이렇게 하면 **`run()`** 메서드는 병렬로 실행되며, 다른 스레드와 동시에 실행될 수 있습니다.
2. **`run()` 메서드 직접 호출**:
    - **`run()`** 메서드를 직접 호출하는 것은 일반 메서드 호출과 같으며, 새로운 스레드를 생성하지 않습니다.
    - 이 경우, **`run()`** 메서드는 현재 스레드(예: **`main`** 스레드)에서 실행되며, 병렬 실행이 아니라 순차적으로 실행됩니다.
    - **`run()`**을 직접 호출하면 멀티스레딩의 이점을 활용할 수 없으며, 단순히 **`run()`** 메서드에 정의된 코드를 현재 스레드에서 실행하는 것과 같습니다.

결론적으로, 멀티스레딩을 활용하려면 반드시 **`start()`** 메서드를 호출해야 하며, **`run()`** 메서드를 직접 호출하는 것은 단순한 메서드 호출로서, 새로운 스레드를 생성하거나 병렬 실행을 하지 않는다.

### 스레드 스택

스레드가 생성되면 해당 스레드를 위한 스택이 같이 생성되면 이 스택은 각 스레드마다 독립적으로 할당되어 동작하기 때문에 서로간 접근이나 공유할 수 없다. 이 스택은 OS에 따라 크기가 주어지고 주어진 크기를 넘기게 되면 그 유명한 `StackOverFlowError` 가 발생하게 된다.

이 스택은 **스레드가 함수 호출을 수행할 때 필요한 데이터를 저장하는 데 사용**한다.

> **스택 프레임(Stack Frame)**
> 스택 프레임(Stack Frame)은 프로그램의 함수 호출과 실행에 필요한 정보를 저장하는 스택(Stack) 내의 데이터 구조입니다. 각 함수 호출 시에 하나의 스택 프레임이 생성되며, 이 프레임은 해당 함수가 실행되는 동안 필요한 다양한 정보를 포함합니다.
>

### 구성 정보

스레드 스택은 주로 로컬 변수(지역변수, 파라미터), 함수 호출 정보, 반환 주소 등을 저장하는 데 사용됩니다. 함수 호출이 발생할 때마다, 호출된 함수의 로컬 변수와 매개변수가 스택에 푸시(push)됩고 함수가 반환될 때, 해당 데이터는 스택에서 팝(pop)되어 제거된다.

**1. 스택 프레임(Stack Frame)**

- 스레드 스택은 여러 개의 스택 프레임으로 구성됩니다. 각 스택 프레임은 개별 함수 호출에 대한 정보를 담고 있습니다.
- 함수가 호출될 때마다 새로운 스택 프레임이 스택에 푸시되고, 함수가 반환될 때 해당 프레임은 스택에서 팝됩니다.

**2. 로컬 변수(Local Variables)**

- 각 스택 프레임은 해당 함수의 로컬 변수를 저장합니다. 이러한 변수는 함수 호출이 끝날 때까지 유효합니다.

**3. 매개변수(Parameters)**

- 함수로 전달되는 매개변수는 대부분 스택 프레임 내에 저장됩니다. 이를 통해 함수 내에서 매개변수에 접근할 수 있습니다.

**4. 반환 주소(Return Address)**

- 함수가 호출될 때, 함수가 반환될 때 다시 돌아갈 위치의 주소(반환 주소)가 스택에 저장됩니다. 함수 실행이 끝나면, 이 주소를 사용하여 호출자 함수로 돌아갑니다.

**5. 스택 포인터(Stack Pointer)**

- 스택 포인터는 스택의 현재 위치를 가리킵니다. 새로운 스택 프레임이 푸시되거나 팝될 때마다 스택 포인터가 업데이트됩니다.

**6. 프레임 포인터(Frame Pointer)**

- 프레임 포인터는 현재 활성화된 스택 프레임의 시작 부분을 가리키는데 사용됩니다. 이를 통해 현재 함수의 로컬 변수와 매개변수에 접근할 수 있습니다.

**7. 임시 저장 공간(Temporary Space)**

- 함수의 계산 중간 결과를 임시로 저장하는 공간입니다. 이 공간은 스택 프레임 내에서 필요에 따라 사용됩니다.

**8. 예외 처리 정보(Exception Handling Information)**

- 일부 프로그래밍 언어에서는 함수 내에서 발생할 수 있는 예외 처리를 위한 정보를 스택 프레임에 저장합니다.

### 스텍 메모리 상태 관리

스택은 제한된 크기를 갖으며, 일반적으로 운영 체제나 JVM 설정에 따라 결정된다. 스택 오버플로(stack overflow)는 스택이 할당된 메모리 크기를 초과할 때 발생하고 이는 무한 재귀 호출로 인해 발생할 수 있습니다. 스택 내부의 변수는 변수를 생성한 메서드가 실행되는 동안에만 존재하고 스택 메모리에 대한 접근은 Heap 메모리와 비교할때 상당히 빠르다.

### 스레드 종료

스레드는 run() 메서드가 모두 실행되면 자동으로 종료한다. 이때 예외가 발생할 경우 또한 종료되며 다른 스레드에 영향을 미치지 않는다.어플리케이션은 싱글스레드인 경우와 멀티스레드인 경우 종료 기준이 다르다.  

스레드들은 비동기적으로 실행한다. 즉 각 스레드들은 독립적으로 실행해서 본인의 스택에 있는 작업을 실행하고 종료한다.

### **싱글 스레드 어플리케이션**

- 싱글 스레드 어플리케이션에서는 주로 하나의 실행 흐름만 존재합니다.
- **종료 기준**: 주 스레드(main thread)의 실행이 종료되면, 어플리케이션의 실행도 종료됩니다. 이는 보통 주 스레드의 **`main`** 함수나 유사한 진입점(entry point)의 코드가 모두 실행 완료되었을 때 발생합니다.
- 특별한 예외 처리나 중단 요청이 없는 한, **`main`** 함수 내의 코드가 순차적으로 모두 실행된 후 어플리케이션이 종료됩니다.

### **멀티스레드 어플리케이션**

- 멀티스레드 어플리케이션에서는 여러 개의 동시 실행 흐름(스레드)이 존재합니다.
- **종료 기준**: 멀티스레드 환경에서 어플리케이션의 종료 기준은 프로그래밍 언어와 환경에 따라 다를 수 있습니다. 일반적으로는 다음 두 가지 방법 중 하나를 따릅니다:
    - **모든 스레드의 종료**: 주 스레드와 모든 백그라운드 스레드가 종료될 때까지 어플리케이션이 실행 상태를 유지합니다.
    - **주 스레드의 종료만으로 충분**: 일부 환경(예: 일부 자바 어플리케이션)에서는 주 스레드가 종료되면 어플리케이션이 종료되며, 이 때 모든 백그라운드 스레드도 강제 종료됩니다. 다만, 이 경우에도 대기 중인 '데몬 스레드(daemon threads)'가 있다면 이들은 주 스레드 종료와 함께 즉시 중단됩니다.  
  
단 스레드 유형이 데몬 스레드 일 경우 위 내용과 일부 다른점이 있다.

## 스레드의 상태

자바 스레드는 생성과 실행 그리고 종료에 따른 상태를 가지고 있으며 JVM 에서는 6가지의 스레드 상태가 존재한다. 이때 OS 스레드의 상태를 의미하지 않는다. 이 상태는 Thread의 `getState()` 메서드를 통해서 가져올 수 있으며 ENUM 상수를 정의하는 Tread.State 클래스를 제공한다. 이때 스레드의 상태는 6가지중 **단 하나의 상태만**을 가질 수 있다.

| 상태 | 설명 |
| --- | --- |
| 신규 (New) | 스레드 객체가 생성되었지만 start() 메서드가 아직 호출되지 않은 상태. |
| 실행 가능 (Runnable) | start() 메서드가 호출된 후, 실행을 위해 CPU 시간을 기다리는 상태. 실행 중과 실행 대기 상태를 포함. |
| 블록 (Blocked) | 다른 스레드가 사용 중인 객체의 잠금(락)을 얻지 못하고 대기하는 상태. |
| 대기 (Waiting) | 다른 스레드의 작업이 완료될 때까지 기다리는 상태. Object.wait(), Thread.join(), LockSupport.park()에 의해 발생. |
| 시간 대기 (Timed Waiting) | 지정된 시간 동안 대기하는 상태. Thread.sleep(), Object.wait(long timeout), Thread.join(long millis) 등에 의해 발생. |
| 종료 (Terminated) | 스레드의 실행이 완료된 상태. run() 메서드가 완료되거나 예외로 인해 종료됨. |

## 스레드 생명주기
스레드는 프로세스 내에서 실행되는 실행 단위이다. 스레드의 생명주기는 다음과 같다

1. 객체 생성 상태(New): 스레드가 생성되고 초기화됩니다. 객체는 생성 되었지만 아직 start() 메서드가 호출 되지 않은 상태로 JVM 에는 개체가 존재 하지만 아직 커널로의 실해은 안된 상태
2. 준비 (Ready or Runnable): 스레드가 실행을 위해 준비되며 CPU 할당을 기다립니다. start() 메서드를 실행 하면 내부적으로 커널로의 실행이 일어나 커널 스레드와 1:1 매핑이 된다. 바로 실행 상태가 아닌 실행 준비가 되어 있는 실행 가능한 상태로 스레드가 실행 상태로 전환하기 위해서는 현재 스레드가 어떤 상태로 존재하든지 반드시 실행 대기 상태를 거쳐야 한다.
3. 스케줄링 : 실행 가능한 스레드에게 실행할 시간을 제공(OS 스케줄러의 책임)한다. 스케줄러는 멀티 스레드 환경에서 각 스레드에게 고정된 시간을 할당해서 실행 상태와 실행 가능 상태를 오가도록 스케줄링 한다.
4. 실행 (Running:실제 생명 주기에는 Runnable 에 포함된 개념) : 스레드가 CPU를 할당받아 실행됩니다(run() 메서드를 호출). 스레드는 아주 짧은 시간동안 실행된 다음 다른 스레드가 실행될 수 있도록 CPU를 일시 중지하고 다른 스레드에게 양도한다(컨텍스트 스위칭). 
   - 실행 상태 -> 실행 대기 상태 : 실행 상태에서 스레드의 yield() 메서드를 호출하거나 운영체제 스케줄러에 의해 CPU 실행을 일시 중지하는 경우 실행 가능한 상태로 전환한다.
5. 대기 상태
   - 일시 정지 상태(Timed Waiting 지정된 시간이 있는 경우) : 스레드 sleep 및 time-out 매개 변수가 있는 메서드를 호출할때 시간이 지정된 대기 상태가 된다. 스레드의 대기 시간이 길어지고 CPU의 할당을 계속 받지 못하는 상황이 발생하면 기아 상태가 발생하게 되는데 이 상황을 피할 수 있다.
   - 블록 (Blocked): 스레드가 동기화 된 임계 영역에 접근을 시도하다가 Lock을 획득하지 못해서 대기하는 상태이다. 스레드는 Lock을 획득할때 까지 대기한다. 이때 스레드가 Lock을 획득하면 실행 대기 상태가 된다.
   - 대기 (Waiting) : 스레드가 실행 상태에서 다른 스레드가 특정 작업을 수행하기를 기다리는 상태, wait()은 다른 스레드에 의해 notify()받을때까지, join()은 스레드의 실행이 종료되거나 인터럽트가 발생할 때까지 대기한다.
     - 스레드 A,B가 실행 중일때 A 스레드에서 B.join()을 호출하면 A스레드는 B스레드가 종료될때까지(run() 메서드가 완료 될때 까지) 대기하게 된다. B 스레드의 작업이 끝난 후에 다시 A 스레드의 작업을 시작한다.
   - 대기 상태에서 깨어난다 : 지정한 시간이 지나거나 다른 스레드에 의해서 인터럽트(interrupt())가 발생하거나 대기가 해제되도록 통지(notify() or notifyAll())를 받게 되면 실행대기 상태가 된다.
6. 종료 (Terminated): 스레드가 작업을 완료하거나 오류 또는 처리되지 않은 예외와 같이 비정상적으로 종료된 상태
  
스레드의 실행 관점에서 보면 출발지가 스레드의 **start()** 메서드 실행 이라면 목적지는 **run()** 메서드 실행이 된다는 점이다.

> **스케줄러가 고정된 시간을 할당 하는 이유**  
> 이 과정은 "시간 할당(time slicing)" 또는 "시간 분할(time sharing)"이라고 합니다.
> 1. **자원 공정 분배:** 각 스레드에 고정된 시간을 할당함으로써, 모든 스레드가 CPU 시간을 공정하게 사용할 수 있습니다. 이는 한 스레드가 CPU를 독점하는 것을 방지하여 시스템의 반응성과 성능을 향상시킵니다.
> 2. **반응성 향상:** 시간 할당을 통해 여러 스레드가 거의 동시에 실행되는 것처럼 보이게 할 수 있습니다. 이는 특히 사용자 인터페이스와 같이 빠른 반응이 필요한 애플리케이션에서 중요합니다.
> 3. **교착 상태 방지:** 스레드들이 자원을 기다리면서 무한히 대기하는 교착 상태(deadlock)를 방지할 수 있습니다. 시간 할당을 통해 모든 스레드가 일정 시간 이후에는 자원을 사용할 기회를 가지게 됩니다.
> 4. **멀티태스킹:** 시간 할당은 멀티태스킹을 가능하게 하는 핵심 메커니즘입니다. 각 스레드가 동시에 실행되는 것처럼 보이게 하여, 여러 작업을 효율적으로 처리할 수 있습니다.
> 5. **자원 관리 최적화:** OS 스케줄러는 시스템의 전반적인 자원을 관리하고 최적화합니다. 시간 할당을 통해 CPU 사용, 메모리 접근 등을 효과적으로 조절할 수 있습니다.

## 스레드 기본 API
## 1. sleep()

Java에서 **`Thread.sleep()`** 메서드는 현재 실행중인 스레드를 지정된 시간 동안 일시 중지시키는 데 사용된다. 이 메서드는 스레드가 일정 시간 동안 작업을 하지 않도록 하여, 다른 스레드가 CPU 자원을 사용할 수 있도록 한다. **네이티브 메서드로 연결되며 시스템 콜을 통해 커널모드에서 수행 후 유저 모드로 전환**한다.

즉, **`Thread.sleep()`** 메서드를 호출할 때 스레드의 상태는 "**실행 중(Runnable)**"에서 "**일시 중지 상태(Timed Waiting)**"로 **변경**됩니다.

### 기본 코드

```java
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    e.printStackTrace();
    // 적절한 예외 처리
}
```

### API

### **1. Thread.sleep(long millis)**

이 형태의 **`sleep()`** 메서드는 스레드를 밀리초 단위로 일시 중지시킵니다.

- **파라미터**: **`millis`** - 스레드가 일시 중지될 밀리초 단위의 시간. 단 밀리초에 대한 인수 값은 음수가 될 수 없으며 음수 일 경우 IllegalArgumentException 이 발생
- **사용 예**: **`Thread.sleep(1000);`**은 스레드를 1초 동안 일시 중지시킵니다.

### **2. Thread.sleep(long millis, int nanos)**

이 형태의 **`sleep()`** 메서드는 스레드를 밀리초와 나노초를 결합한 형태로 일시 중지시킵니다.

- **파라미터**:
    - **`millis`** - 스레드가 일시 중지될 밀리초 단위의 시간.
    - **`nanos`** - 추가적으로 스레드가 일시 중지될 나노초 단위의 시간 (0에서 999999까지).
- **사용 예**: **`Thread.sleep(1000, 500000);`**은 스레드를 1초와 500,000나노초(0.5초) 동안 일시 중지시킵니다.

### 관련 예외

### **InterruptedException**

- **원인**: 현재 스레드가 sleep, wait, join 등의 중단 상태에 있을 때, 다른 스레드가 이 스레드를 깨우려고 **`interrupt()`** 메서드를 호출하면 발생합니다.
- **처리 방법**: 이 예외는 checked 예외로, 반드시 try-catch 블록을 사용하거나 메서드 선언에 예외를 명시해야 합니다.
- **일반적인 사용 예**: 스레드가 일정 시간 동안 대기한 후에 다시 작업을 수행해야 하는 경우, 또는 스레드를 안전하게 종료시키기 위해 사용됩니다.  

InterruptedException 예외가 발생하면 스레드는 대기상태에서 실행대기 상태로 전환되어 실행 상태를 기다린다.

### 예시

두 개의 스레드, 즉 스레드 1과 스레드 2가 있으며, 스레드 1이 **`sleep()`** 메서드를 사용하여 일시 중지 상태에 들어가고, 이후 스레드 2가 스레드 1에게 인터럽트를 보내는 상황을 가정해보자.

### **초기 상황**

1. **스레드 1 실행**: 스레드 1은 실행 상태에 있다. 이 때 스레드는 CPU 자원을 사용하고 있으며, 작업을 수행하고 있다.
2. **스레드 1 일시 중지**: 스레드 1이 **`Thread.sleep()`** 메서드를 호출한다. 이 호출로 인해 스레드 1은 일시 중지 상태인 "시간 대기 상태(Timed Waiting)"로 전환되고 이 상태에서는 스레드 1이 CPU 자원을 사용하지 않으며, 지정된 시간 동안 대기하게 된다.

### **컨텍스트 스위칭**

1. **스레드 2 실행**: 스레드 1이 대기 상태에 있기 때문에, **스레드 스케줄러**는 스레드 2에게 CPU 자원을 할당한다. 이로 인해 컨텍스트 스위칭이 발생하고, 스레드 2가 실행 상태가 된다. 스레드 2는 이제 작업을 수행할 수 있다.

### **인터럽트 발생**

1. **스레드 2에 의한 인터럽트**: 스레드 2가 어떤 이유로 스레드 1을 깨우기로 결정한다. 이를 위해 스레드 2는 스레드 1의 **`interrupt()`** 메서드를 호출한다. 이 호출은 스레드 1에 인터럽트 신호를 보낸다.

### **스레드 1의 응답**

1. **스레드 1의 상태 변화**: 스레드 1은 인터럽트 신호를 받는다. 이 신호는 스레드 1이 **`sleep()`** 상태에서 깨어나게 만듭니다. 이 때 스레드 1은 "실행 가능(Runnable)" 상태로 전환된다. 하지만 바로 실행 상태로 가는 것은 아니며, **실행을 위해 스레드 스케줄러의 결정을 기다립니다.**
2. **InterruptedException 발생**: 스레드 1은 **`InterruptedException`**을 발생시킵니다. 이 예외는 스레드 1이 **`sleep()`** 메서드에서 **깨어날 때 자동으로 발생**합니다.

### **예외 처리**

1. **스레드 1의 예외 처리**: 스레드 1은 `InterruptedException`을 처리해야 합니다. 이를 위해 스레드 1 내에서 이 예외를 처리하는 코드가 실행됩니다. 이 처리는 스레드가 이 인터럽트에 어떻게 반응할지 결정하는 로직을 포함할 수 있습니다. 예를 들어, 스레드를 안전하게 종료하거나 특정 작업을 재개하는 등의 동작을 수행할 수 있습니다.

### **실행 재개**

1. **스레드 1의 작업 재개**: 예외 처리가 완료된 후, 스레드 1은 다시 스레드 스케줄러에 의해 실행 상태로 전환될 수 있습니다. 이때 스레드 1은 중단되었던 작업을 계속하거나 새로운 작업을 시작할 수 있습니다.

이 과정에서 중요한 점은 스레드가 **`sleep()`** 상태에서 인터럽트될 경우, `InterruptedException`을 적절하게 처리해야 한다는 것이다. 이를 통해 스레드가 예상치 못한 상황에 안전하게 대처하고, 필요한 자원 정리와 상태 관리를 할 수 있다.

### sleep(0) 과 sleep(n)의 의미

sleep(millis) 메서드는 네이티브 메서드이기 때문에 sleep(millis) 을 실행하게 되면 시스템 콜을 호출하게 되어 유저모드에서 커널모드로 전환된다. 이때 다른 스레드에게 명확하게 실행을 양보하기 위함이라면 sleep(0) 보다는 sleep(1)을 사용하는 것이 좋다.

### **Thread.sleep(0)**

**`Thread.sleep(0)`** 호출은 스레드를 0 밀리초 동안 일시 중지시키라는 명령입니다. 이론적으로는 스레드가 대기 상태에 들어갔다가 바로 나오는 것을 의미한다. 실제 효과는 종종 운영체제의 스레드 스케줄러에 의존적인데 이는 스레드가 실행 큐의 끝으로 이동하고, 다른 스레드에게 실행 기회를 제공할 수 있음을 의미한다. 즉, 동일 우선순위를 가진 다른 스레드에게 실행 기회를 양보하는 효과가 있을 수 있습니다. 하지만 만약 우선순위가 동일한 실행대기 상태의 다른 스레드가 없으면 스케줄러는 현재 스레드에게 계속 CPU를 할당해서 컨텍스트 스위칭이 없고 모드 전환만 일어난다.

### **Thread.sleep(n)**

스레드가 커널 모드로 전환 후 스케줄러는 조건에 상관없이 현재 스레드를 대기 상태에 두고 다른 스레드에게 CPU를 할당함으로 모든 전환과 함께 컨텍스트 스위칭이 발생한다.

### 정리

- sleep() 이 되면 OS 스케줄러는 현재 스레드를 지정된 시간 동안 대기 상태로 전환하고 다른 스레드 혹은 프로세스에게 CPU 를 사용하도록 한다
- 대기 시간이 끝나면 스레드 상태는 바로 실행상태가 아닌 실행 대기 상태로 전환 되고 CPU 가 실행을 재개할 때 까지 기다린다.
- 실행 상태가 되면 스레드는 남은 지점부터 실행을 다시 시작한다
- 동기화 메서드 영역에서 **수면 중인 스레드는 획득한 모니터나 락을 잃지 않고 계속 유지**한다
- sleep() 중인 스레드에게 인터럽트가 발생할 경우 현재 스레드는 대기에서 해제되고 실행상태로 전환되어 예외를 처리하게 된다
- 스레드의 수면 시간은 OS 스케줄러 및 시스템 기능에 따라 제한되기 때문에 정확성이 보장되지 않으며 시스템의 부하가 많고 적음에 따라 지정한 수면 시간과 차이가 날 수 있다  

## 2. join()

Java에서 **`Thread`** 클래스의 **`join()`** 메서드는 한 스레드가 다른 스레드의 종료를 기다리는 데 사용된다. **`join()`** 메서드를 호출한 스레드는 지정된 스레드가 종료될 때까지 대기하게 됩니다. 이는 스레드 간의 동기화와 순서를 제어하는 데 유용합니다.즉 스레드의 순서를 제어하거나 다른 스레드의 작업을 기다려야 하거나 순차적인 흐름을 구성하고자 할때 사용한다. 이때 `Object` 클래스의 `wait()` 네이티브 메서드로 연결되며 시스템 콜을 통해 커널모드로 수행한다. 내부적으로는 wait() & notify() 흐름을 가지고 제어한다.  
  
2개의 스레드 T1과 T2가 있을때 T1이 T2의 모든 작업이 종료될때 까지 어떠 시점에 대기했다가 다음 작업을 수행하고 싶다. 이런 상황에서 T1기준으로 T2.join() 메서드를 호출하게 되면 해당 코드가 이후에 있는 코드들은 T2의 작업이 끝나기전 까지는 수행 되지 않는다.

```java
Thread thread = new Thread(() -> {
    // 스레드가 수행할 작업
});
thread.start();

try {
    thread.join();  // 현재 스레드가(메인 스레드) 'thread'의 종료를 기다림
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

### API

### 1. **void join()**

이 메서드는 현재 스레드가 다른 스레드(대상 스레드)의 **`run()`** 메서드가 완료될 때까지 기다리게 합니다. 다시 말해, 대상 스레드가 종료될 때까지 현재 스레드는 대기 상태에 머무릅니다.

### 2. **void join(long millis)**

이 메서드는 현재 스레드가 대상 스레드의 **`run()`** 메서드 완료 또는 지정된 시간(밀리초 단위)이 경과할 때까지 기다리게 합니다. 시간이 만료되면, 대기 중인 스레드는 자동으로 다시 실행 상태로 돌아갑니다.

### 3. **void join(long millis, int nanos)**

이 메서드는 현재 스레드가 대상 스레드의 **`run()`** 메서드 완료 또는 지정된 시간(밀리초와 나노초를 결합한 형태)이 경과할 때까지 기다리게 합니다. 이때 나노초의 범위는 0에서 999999 이다.

### 관련 예외

### **InterruptedException**

- **원인**: 현재 스레드가 **`join()`**, **`wait()`**, **`sleep()`** 등의 메서드로 인해 대기 상태에 있을 때, 다른 스레드가 이 스레드의 **`interrupt()`** 메서드를 호출하면 `InterruptedException`이 발생합니다. **`join()`** 메서드를 사용하는 경우, 해당 스레드가 다른 스레드의 종료를 기다리는 동안 인터럽트될 때 이 예외가 발생합니다.
- **처리 방법**: `InterruptedException`은 checked 예외로, 반드시 try-catch 블록을 사용하여 처리하거나, 메서드 선언에 예외를 명시해야 합니다.
- **일반적인 사용 예**: 두 스레드 간의 작업 순서를 조정하거나, 한 스레드가 다른 스레드의 작업 완료를 기다리는 경우에 **`join()`** 메서드와 함께 사용됩니다.

InterruptedException 예외가 발생하면 스레드는 대기상태에서 실행대기 상태로 전환되어 실행 상태를 기다린다.

### 실행흐름 예시

1. **메인 스레드 실행**: 메인 스레드가 실행되고, 특정 시점에서 **`스레드 1.join()`** 메서드를 호출합니다. 이 호출은 메인 스레드가 스레드 1의 종료를 기다리게 만듭니다.
2. **메인 스레드 일시 정지**: **`join()`** 메서드를 만나면, 메인 스레드는 일시적으로 실행을 멈추고 대기 상태로 전환됩니다. 내부적으로, 이는 **`wait()`** 메서드와 유사한 메커니즘을 사용하여 메인 스레드를 대기 상태로 만듭니다.
3. **스레드 1 실행**: 이 시점에서, 스레드 1은 실행 상태로 전환됩니다(컨텍스트 스위칭). 스레드 1은 할당된 작업을 수행합니다.
4. **스레드 1 종료와 메인 스레드 깨우기**: 스레드 1의 작업이 완료되면, 자동적으로 메인 스레드에게 '작업 완료' 신호를 보냅니다. 이는 내부적으로 **`notify()`** 메서드와 유사한 메커니즘으로 처리되며, 이 신호로 인해 메인 스레드의 대기 상태가 해제됩니다.
5. **메인 스레드 재개**: `notify()`와 유사한 신호를 받은 메인 스레드는 대기 상태에서 벗어나 다시 실행 상태로 전환됩니다. 메인 스레드는 **`join()`** 호출 이후의 코드를 계속해서 실행합니다.

이때 **`join()`** 메서드는 내부적으로 **`Object`** 클래스의 `wait()`와 **`notify()`** 메커니즘을 활용하여 스레드 간의 동기화를 수행한다. 이는 스레드가 다른 스레드의 종료를 기다리는 동안 CPU 자원을 낭비하지 않도록 한다. **`join()`** 메서드는 스레드 간의 동기화와 순서 제어에 매우 유용하지만, 데드락(Deadlock) 같은 상황을 방지하기 위해 신중하게 사용해야 한다. 데드락은 두 스레드 또는 그 이상이 서로의 작업 완료를 무한히 기다리는 상태를 말합니다.

### **인터럽트 발생 시키기**

1. **스레드 2에 의한 인터럽트**: 이 시점에서, 스레드 2가 실행되고, 어떤 이유로 메인 스레드를 인터럽트합니다. 이를 위해 스레드 2는 메인 스레드의 **`interrupt()`** 메서드를 호출합니다.

### **메인 스레드의 응답**

1. **메인 스레드의 인터럽트 처리**: 메인 스레드는 인터럽트 신호를 받습니다. **`join()`** 메서드가 인터럽트에 의해 중단되면, **`InterruptedException`** 예외가 발생합니다. 메인 스레드는 이 예외를 잡아서 처리합니다.

### **예외 처리와 실행 재개**

1. **예외 처리 및 실행 대기 상태로 전환**: 메인 스레드는 **`InterruptedException`**을 처리합니다. 일반적으로 이 예외 처리는 인터럽트 발생 사실을 로그로 기록하거나, 메인 스레드의 현재 상태에 따라 적절한 조치를 취하는 코드를 포함할 수 있습니다. 예외 처리가 완료되면, 메인 스레드는 대기 상태에서 벗어나 실행 대기 상태로 전환됩니다.
2. **메인 스레드의 작업 재개**: 예외 처리가 완료되고 나면, 메인 스레드는 다시 실행 가능한 상태가 되며, 스레드 스케줄러에 의해 실행될 준비가 됩니다. 스레드 스케줄러는 메인 스레드를 다시 실행 큐에 배치하여 작업을 재개할 수 있도록 합니다.

### 정리

- join() 을 실행하면 OS 스케줄러는 join() 을 호출한 스레드를 대기 상태로 전환하고 호출 대상 스레드에게 CPU 를 사용하도록 한다
- 호출 대상 스레드의 작업이 종료되면 join() 을 호출한 스레드는 실행 대기 상태로 전환 되고 CPU 가 실행을 재개할 때 까지 기다린다.
- join() 을 호출한 스레드가 실행 대기에서 실행 상태가 되면 그 스레드는 남은 지점부터 실행을 다시 시작한다
- 호출 대상 스레드가 여러 개일 경우 각 스레드의 작업이 종료될 때 까지 join() 을 호출한 스레드는 대기와 실행을 재개하는 흐름을 반복한다
- join() 을 호출한 스레드가 인터럽트 되면 해당 스레드는 대기에서 해제되고 실행상태로 전환되어 예외를 처리하게 된다  

## 3. **interrupt()** & **interrupted()** & **isInterrupted()**

Interrupt 의 사전적 의미는 ‘방해하다’ 라는 뜻으로 어떤 주체의 행동이나 실행흐름을 방해한다는 의미로 해석 할 수 있다. Java 에서 interrupt 는 특정한 스레드에게 인터럽트 신호를 알려 줌으로써 스레드의 실행을 중단 , 작업 취소, 강제 종료 등으로 사용할 수 있다. 스레드 인터럽트와 관련된 세 가지 중요한 메서드는 **`interrupt()`**, **`interrupted()`**, **`isInterrupted()`** 입니다. 이들은 스레드를 인터럽트하거나 인터럽트 상태를 확인하는 데 사용된다.

### **1. interrupt()**

- **용도**: 특정 스레드에 인터럽트(interrupt) 신호를 보냅니다. 이 메서드를 호출하면, 대상 스레드의 인터럽트 상태가 설정됩니다. 즉 interrupt() 는 스레드가 현재 실행 흐름을 멈추고 인터럽트 이벤트를 먼저 처리하도록 시그널을 보내는 장치라 할 수 있다
- **사용 방법**: 대상 스레드의 인스턴스에 대해 **`interrupt()`** 메서드를 호출합니다. 예를 들어, **`thread.interrupt();`**는 **`thread`**라는 스레드 인스턴스에 인터럽트를 발생시킵니다.
- **효과**: 대상 스레드가 **`sleep()`**, **`wait()`**, **`join()`** 등에 의해 대기 상태에 있을 때 **`InterruptedException`**이 발생하게 합니다. 대기 상태가 아닌 스레드에 대해서는 인터럽트 상태가 설정되고, 이후 해당 스레드의 코드에서 이 상태를 확인할 수 있습니다.
- **interrupted 속성**
    - 스레드는 인터럽트 상태(Interrupt State )로 알려진 **interrupted** 를 가지고 있으며 인터럽트 발생 여부를 확인할 수 있는 상태 값이다. 기본값은 fasle 이다
    - 인터럽트된 스레드가 처리해야 하는 특별한 규칙이나 정해진 기준은 없으나 일반적으로 인터럽트 상태를 사용해서 스레드를 중지하거나, 작업을 취소하거나, 스레드를 종료 하는 등의 기능을 구현할 수 있다
    - 한 스레드가 다른 스레드를 인터럽트 할 수 있고 자기 자신을 인터럽트 할 수도 있다
    - interrupt() 하는 횟수는 제한이 없으며 인터럽트 할 때 마다 스레드의 인터럽트 상태를 true 로 변경한다
  
스레드1 , 스레드2 두 스레드가 실행중에 있을때 1번스레드가 2번스레드에게 interrupt를 걸게되면(thread2.interrupt()) 그 즉시 스레드2번에게 interrupt signal을 전달하게되고 이 신호를 받은 스레드2번의 interrupted 속성은 true로 변경된다.(초기값은 false)  
  
인터럽트가 발생했다는 신호를 받으면 상태값이 변경되고 해당 상태값을 사용해서 우리는 취소, 종료 처리등을 할 수 있다.
  
### 인터럽트 상태 확인 하는 방법  

### **1. static boolean interrupted()**

- **용도**: 현재 스레드의 인터럽트 상태를 확인하고, **인터럽트 상태를 초기화**합니다. 즉 인터럽트를  해제하는 역할을 한다.
- **사용 방법**: `Thread.interrupted()`를 호출하여 현재 스레드의 인터럽트 상태를 확인합니다. 이 메서드는 static 메서드입니다.
- **반환 값과 효과**: 스레드가 인터럽트되었으면 `true`를 반환하고, 인터럽트 상태를 초기화합니다(`false`로 설정). 스레드가 인터럽트되지 않았으면 `false`를 반환합니다.

만약 인터럽트를 해제하는 경우 다른 곳에서 스레드에 대한 인터럽트 상태를 체크하는 곳이 있다면 별도의 처리가 필요할 수 있고 강제로 해제 했기 떄문에 다시 인터럽트를 걸어서 인터럽트 상태를 유지할 수 있다.

### **2. boolean isInterrupted()**

- **용도**: 특정 스레드의 인터럽트 상태를 확인하지만, **인터럽트 상태를 초기화하지 않습니다.**
- **사용 방법**: 대상 스레드 인스턴스에 대해 **`isInterrupted()`** 메서드를 호출합니다. 예를 들어, `thread.isInterrupted();`는 `thread`라는 스레드 인스턴스의 인터럽트 상태를 확인합니다.
- **반환 값과 효과**: 스레드가 인터럽트되었으면 `true`를 반환하고, 그렇지 않으면 `false`를 반환합니다. 인터럽트 상태는 변경되지 않습니다.

### **요약**

- **`interrupt()`**: 스레드에 인터럽트 신호를 보냅니다.
- **`interrupted()`**: 현재 스레드의 인터럽트 상태를 확인하고 초기화합니다.
- **`isInterrupted()`**: 특정 스레드의 인터럽트 상태를 확인하지만, 초기화하지 않습니다.

### interruptedException

- InterruptedException 은 interrupt() 메카니즘의 일부이며 **대기나 차단 등 블록킹 상태에 있거나 블록킹 상태를 만나는 시점**의 스레드에 **인터럽트 할 때 발생**하는 예외이다.
- InterruptedException 이 발생하면 인터럽트 **상태는 자동으로 초기화 된다**. 즉 Thread.interrupted() 한 것과 같은 상태로 된다( interrupted = false)
- 다른 곳에서 인터럽트 상태를 참조하고 있다면 예외 구문에서 대상 스레드에 다시 interrupt() 해야 할 수도 있다
- InterruptedException 이 발생하는 케이스는 다음과 같다
    - Thread.sleep(), Thread.join(), Object.wait()
    - Future.get(), BlockingQueue.take()


### 4. **name() &** **currentThread() &** **isAlive()**

### **1. name()**

멀티 스레드 환경에서 어떤 스레드가 실행중인지 알아야 할 경우 스레드에 사용자 이름을 지정하면 실행중인 스레드를 쉽게 찾을 수 있고 디버깅시 스레드가 무슨작업을 하고 있는지 정확하게 파악하는데 큰도움이 된다. 기본적으로 자바에서 스레드가 생성되면 스레드 이름이 자동으로 주어진다. 가장 먼저 생성되는 스레드의 이름을 main 그다음은 Thread-0,Trhead-1…. 이런 식으로 이름이 만들어지게 된다.

- **setName(String name)**: 스레드에 이름을 설정합니다. 이 이름은 디버깅 시 스레드를 식별하는 데 유용합니다.
- **getName()**: 현재 스레드의 이름을 반환합니다.
- **생성자 함수 인자로 전달** : Thread myThread = new Thread([TreadGroup],[Runnable],"myThread");

### **2. currentThread()**

- **용도**: 현재 실행 중인 스레드의 참조를 반환합니다.
- **사용 방법**: `Thread.currentThread()`를 호출합니다. 이 메서드는 현재 실행 중인 스레드의 **`Thread`** 객체를 반환합니다.
- **반환 값**: 현재 실행 중인 스레드의 **`Thread`** 객체입니다. 이를 통해 현재 스레드의 상태, 이름, 우선순위 등의 정보를 얻을 수 있습니다.

### **3. isAlive()**

- **용도**: 특정 스레드가 활성 상태인지(즉, 실행 중이거나 실행 준비가 되어 있는지) 확인합니다.
- **사용 방법**: 스레드 인스턴스에 대해 **`isAlive()`** 메서드를 호출합니다. 예를 들어, `thread.isAlive();`는 `thread`라는 스레드 인스턴스가 아직 활성 상태인지 확인합니다.
- **반환 값**: 스레드가 활성 상태면 **`true`**, 그렇지 않으면 `false`를 반환합니다.

## 스레드 우선순위

**단일 CPU에서 여러 스레드를 실행하는 것을 스케줄링**이라고 하며 스레드는 스케줄에 의해 선점되어 CPU를 할당 받는다. 자바는 자바 런타임에 고정 우선순위 선점형 스케줄링(**fixed-priority pre-emptive scheduling )** 으로 알려진 매우 단순하고 결정적인 스케줄링 알고리즘을 지원하고 이 알고림즘은 실행 대기 상태의 스레드 중에 상대적인 우선순위에 따라 스레드를 예약한다.

Java에서 스레드 우선순위는 스레드 스케줄링에서 각 스레드에 할당되는 처리 시간의 양을 결정하는 데 사용된다. 스레드 우선순위는 일반적으로 숫자로 표현되며, 높은 숫자가 높은 우선순위를 의미합니다.

### **스레드 우선순위의 범위**

- Java에서 스레드의 우선순위는 **`Thread.MIN_PRIORITY`** (1)부터 **`Thread.MAX_PRIORITY`** (10)까지의 값을 가질 수 있으며, 기본값은 **`Thread.NORM_PRIORITY`** (5)입니다.

### **우선순위 설정 및 조회**

- **설정**: 스레드의 우선순위는 **`setPriority(int newPriority)`** 메서드를 통해 설정할 수 있습니다. 예를 들어, `thread.setPriority(Thread.MAX_PRIORITY);`는 해당 스레드에 최대 우선순위를 설정합니다.
- **조회**: 스레드의 현재 우선순위는 **`getPriority()`** 메서드를 통해 조회할 수 있습니다. 예를 들어, `int priority = thread.getPriority();`는 해당 스레드의 우선순위를 반환합니다.

### **우선순위의 영향**

- 스레드 우선순위는 JVM과 운영 체제의 스레드 스케줄링 정책에 의해 영향을 받습니다. **따라서 높은 우선순위를 가진 스레드가 더 많은 실행 시간을 할당받을 가능성이 높지만, 이는 항상 보장되지는 않습니다.** 예를들어 스케줄러는 우선순위가 높은 스레드를 실행하다가 해당 스레드가 중지,양보 또는 실행 불가능이 되는 경우 우선 순위가 낮은 스레드를 실행한다.
- 특히, 다중 처리 시스템에서는 우선순위가 덜 중요할 수 있으며, 단일 처리 시스템에서는 우선순위가 스레드 간의 실행 순서에 더 큰 영향을 미칠 수 있습니다.
- 두 스레드의 우선순위가 같을 경우 라운드 로빈 순환 할당 스케줄링 방식에 의해 다음 스레드를 선택한다.

> **라운드 로빈(Round Robin) 순환 할당 스케줄링 방식**  
> 컴퓨팅에서 널리 사용되는 프로세스 혹은 스레드 스케줄링 알고리즘 중 하나입니다. 이 방식은 각 스레드에게 동일한 시간 할당량(타임 슬라이스 혹은 타임 퀀텀)을 순서대로 할당하여 실행을 허용합니다. 모든 스레드는 공평하게 CPU 시간을 할당받으며, 하나의 스레드가 자신에게 할당된 시간을 사용하면, 다음 스레드로 넘어갑니다.  
> 
>라운드 로빈 스케줄링은 각 스레드가 작업을 완료하기 위해 필요한 전체 시간을 미리 알 필요가 없으며, 모든 스레드에게 동등한 기회를 제공하기 때문에 공정한 스케줄링 방식으로 간주됩니다. 이 방식은 특히 시분할 시스템에서 효과적이며, 응답 시간을 개선하는 데 도움이 됩니다.
>   
> 자바에서 스레드의 우선순위를 설정할 수 있지만, 실제 스레드 스케줄링은 JVM이 실행되는 운영 체제의 스케줄링 정책에 크게 의존합니다. 따라서, 자바 스레드의 우선순위가 같을 경우 운영 체제의 스케줄러가 라운드 로빈 방식이나 다른 방식을 사용하여 스레드를 스케줄링할 수 있습니다. 그러나 모든 운영 체제가 정확히 라운드 로빈 방식을 사용하는 것은 아니며, 스레드 스케줄링은 운영 체제별로 다를 수 있습니다.


### **주의 사항**

- 우선순위에 의존하는 프로그램 설계는 일반적으로 권장되지 않습니다. 다양한 JVM과 운영 체제에서의 스레드 스케줄링 정책의 차이로 인해 예측하기 어려울 수 있기 때문이다.
- 우선순위를 사용하여 스레드 간의 경쟁 조건(race condition)을 해결하려고 시도하는 것은 좋지 않은 접근 방식입니다. 대신, 적절한 동기화 메커니즘을 사용하는 것이 바람직합니다.  

  
# 스레드 활용  

## 스레드 예외처리

Java에서 **`Thread.UncaughtExceptionHandler`** 인터페이스는 스레드에서 처리되지 않은 예외(uncaught exception)를 처리하기 위해 사용됩니다. 일반적으로 스레드 내에서 발생한 예외가 해당 스레드의 **`run()`** 메서드 내에서 적절히 처리되지 않으면, 이 인터페이스를 구현하는 핸들러를 통해 해당 예외를 잡아 처리할 수 있습니다. **기본적으로 스레드의 run() 은 예외를 던질 수 없기 때문에** 예외가 발생할 경우  run() 안에서만 예외를 처리해야한다. **이때 RuntimeException 타입의 예외가 발생할 지라도 스레드 밖에서 예외를 캐치할 수 없고 사라진다.**

### **UncaughtExceptionHandler 사용 방법**

캐치 되지 않는 예외에 의해 Thread가 갑자기 종료됬을때 호출되는 핸들러 인터페이스 이다. 이를 통해서 어떤 원인으로 인해 스레드가 종료되었는지 대상 스레드와 예외를 파악할 수 있다.

1. **인터페이스 구현**: **`Thread.UncaughtExceptionHandler`** 인터페이스를 구현하는 클래스를 정의합니다. 이 클래스는 **`uncaughtException(Thread t, Throwable e)`** 메서드를 구현해야 합니다. 이 메서드는 예외가 발생한 스레드와 해당 예외 객체를 인자로 받는다.
2. **핸들러 설정**: 스레드 또는 스레드 그룹에 이 핸들러를 설정합니다. 이를 위해 **`Thread`** 클래스의 **`setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)`** 메서드를 사용한다
- **static void setDefaultUncaughtExceptionHandler**
    - 모든 스레드에서 발생하는 uncaughtException 을 처리하는 정적 메서드
- **void setUncaughtExceptionHandler(UncaughtExceptionHandler ueh)**
    - 대상 스레드에서 발생하는 uncaughtException 을 처리하는 인스턴스 메서드
    - setDefaultUncaughtExceptionHandler 보다 우선순위가 높다

### **예제 코드**

```java
public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println("An exception has been captured in thread: " + t.getName());
        System.out.println("Exception: " + e.getClass().getName() + ": " + e.getMessage());
        e.printStackTrace(System.out);
    }
}

public class MyThread extends Thread {
    @Override
    public void run() {
        throw new RuntimeException("Intentional Exception");
    }

    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
        thread.start();
    }
}

```

이 예제에서 `MyUncaughtExceptionHandler`는 `Thread.UncaughtExceptionHandler`를 구현합니다. **`MyThread`** 클래스의 **`run()`** 메서드는 의도적으로 예외를 발생시키고, 이 예외는 `MyUncaughtExceptionHandler`에 의해 처리됩니다.
  
스레드를 생성해서 `UncaughtExceptionHandler`를 구현해서 `setUncaughtExceptionHandler`메서드를 통해서 핸들러를 설정하게 되면 스레드 내부에서는 `start()`메서드를 통해서 내부적으로 스레드의 `run()`메서드를 호출하는데 이때 `run()`메서드에서 예외가 발생하게 된다면(uncaughtException) 내부적으로 `dispatchUncaughtException` 메서드를 호출한다. 해당 메서드는 우리가 앞에서 전달한 `UncaughtExceptionHandler`를 가지고 와서 우리의 핸들러를 호출해준다.(getUncaughtExceptionHandler.uncaughtException(thread,exception) )
### **사용 시 주의사항**

- `UncaughtExceptionHandler`는 스레드가 예외로 인해 종료될 때 실행됩니다. 따라서 예외 처리 로직을 이 핸들러에 구현할 때는 스레드의 안전한 종료와 자원 해제에 주의해야 한다.
- 모든 스레드에 대해 동일한 **`UncaughtExceptionHandler`**를 사용할 수 있으며, 필요에 따라 각 스레드에 개별적으로 핸들러를 설정할 수도 있다.
- 기본적으로 스레드에서 발생하는 예외는 콘솔에 출력되지만, **`UncaughtExceptionHandler`**를 사용하면 예외 정보를 로깅하거나, 애플리케이션에 특정한 조치를 취하는 등 보다 세밀한 예외 처리가 가능하다.

## 스레드 중지

자바에서 무한 반복이나 지속적인 실행 중에 있는 스레드를 중지하거나 종료할 수 있는 API를 더이상 사용할 수 없다.(suspend(), stop()) 이때 스레드를 중지하는 데 사용되는 두 가지 일반적인 방법은 플래그 변수(flag variable) 사용과 **`interrupt()`** 메서드 호출이다. 이 두 방법은 스레드를 안전하게 중지시키기 위해 사용되며, 각각의 특징과 사용 사례가 다릅니다.

### **1. 플래그 변수 사용**

- **방법**: 스레드가 실행 중인 동안 계속 확인하는 boolean 플래그 변수를 사용합니다. 외부에서 이 변수를 변경함으로써 스레드에 중지 신호를 보낼 수 있습니다. 이때 이 플래그 변수는 동시성 문제로 가능한 atomic 변수나 volatile 키워드를 사용하도록 한다.
- **사용 사례**: 스레드가 특정 작업을 반복적으로 수행하고 있을 때, 플래그 변수의 상태를 확인하여 중지 여부를 결정합니다.
- **장점**: 구현이 간단하고, 스레드의 특정 지점에서만 중지를 확인할 수 있어 통제가 용이합니다.
- **단점**: 스레드가 바쁜 대기 상태(busy-waiting)에 있지 않고 블로킹 상태(blocking state)인 경우(예: **`sleep()`**, **`wait()`** 호출 시), 플래그 변수를 확인할 수 없어 중지가 지연될 수 있습니다.

```java
public class MyThread extends Thread {
    private volatile boolean running = true;

    public void run() {
        while (running) {
            // 스레드 작업 수행
        }
    }

    public void stopThread() {
        running = false;
    }
}

```

```java
import java.util.concurrent.atomic.AtomicBoolean;

public class MyThread extends Thread {
    private AtomicBoolean running = new AtomicBoolean(true);

    public void run() {
        while (running.get()) {
            // 스레드 작업 수행
            System.out.println("스레드 실행 중");
            try {
                Thread.sleep(1000); // 1초 대기
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // 인터럽트 상태 복원
            }
        }
        System.out.println("스레드 종료");
    }

    public void stopThread() {
        running.set(false);
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        myThread.start();
        Thread.sleep(3000); // 메인 스레드는 3초 동안 대기
        myThread.stopThread(); // 스레드 중지 요청
    }
}
```
  
### 일반변수 사용
```java
public class FlagThreadInterrupt {
    private static boolean running = true;
    
    public static void main(String[] args) {
        new Thread(() -> {
            int count = 0;
            while (running) {
                count ++;
            }
            System.out.println("Thread 1 is Done.. : "+ count);
        }).start();

        new Thread(() -> {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Thread 2 is Done.. : ");
            running = false;
        }).start();

    }
}

```
해당 코드에서 정상적으로 스레드1이 종료되지 않는 경우가 발생한다.이유는 캐시 메모리 값은 변경되었으나 실제 메모리 값은 변경되지 않아서 스레드 1이 계속 작업을 수행하게된다. 이떄  밑에 코드를 추가하니까 정상적으로 종료됨  
```java
 while (running) {
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                count ++;
            }
```
왜? 정상적으로 동작하는 것일까??   
각각의 CPU 마다 캐시 메모리 라는 것을 가지고 있다.(성능을 좀더 좋게하기 위해서 메모리보다 성능이 좋은 저장소) 이때 각 스레드는 메모리에서 값을 가져오는 것보다 캐시 메모리에서 가져오는 것이 연산 속도가 더 빠르기 때문이다.  

예를 들어 우리 예제에서 스레드2먼에서 running의 값을 false로 변경하면 바로 메모리에 해당 값을 변경하는 것이 아니라 변경된 값이 캐시 메모리에 저장이 된다.  이때 각각 스레드들이 가지고 있는 TCB가 다르기 때문에 CPU가 다른 스레드로 작업이 할당될때마다 이 컨텍스트 문맥정보가 달라진다.  

스레드2번이 가지고 있는 running의 값은 false 이지만 스레드1번이 가지고 있는 스레드1번에 값은 true이다. 즉 두 스레드가 동일한 장소에 있는 공유 데이터를 참조하는 것이 아니라 스레드 마다 가지고 있는 캐시값을 활용하기 때문에 이런 현상이 발생한다. 이 **volatile 이라는 키워드가 동일한 메모리에 접근해서 읽고 쓰고 하는 것을 보장해주는 키워드** 이다.  

그러면 왜 스레드1에 Thread.sleep(1) 코드를 추가하면 정상작동하는 이유는 아주 짧은 시간이여도 컨텍스트 스위칭이 발생한다.(스레드간 가지고 있는 문맥정보를 전환한다) 컨텍스트 스위칭이 발생하게 되면 해당 스레드에 있는 캐시값을 비워줘야 되기때문이다 왜냐하면 전환된 스레드의 문맥정보를 캐시로 사용해야 되기 때문이다. 스레드가 대기 상태에서 다시 running 상태로 변경되었을때는 기존에 가지고 있던 문맥정보가 없어졌기 때문에 새롭게 메모리에서부터 정보를 가지고 오게된다.

### **2. interrupt() 메서드 사용**

- **방법**: **`Thread`** 클래스의 **`interrupt()`** 메서드를 호출하여 스레드에 인터럽트를 발생시킵니다. 스레드 내에서 **`InterruptedException`**이 발생하거나, 스레드의 **`interrupted()`** 상태를 확인하여 중지 여부를 결정할 수 있습니다.
- **사용 사례**: 스레드가 블로킹 상태(예: **`sleep()`**, **`wait()`**, **`join()`** 호출 시)에 있을 때 유용합니다.
- **장점**: 블로킹 상태에 있는 스레드도 즉시 인터럽트될 수 있으며, **`InterruptedException`**을 통해 스레드를 안전하게 중지시킬 수 있습니다.
- **단점**: 인터럽트 메커니즘을 정확히 이해하고 사용해야 하며, 스레드가 블로킹 상태가 아닌 경우 별도로 인터럽트 상태를 확인하는 로직을 추가해야 합니다.

```java

public class MyThread extends Thread {
    public void run() {
        try {
            while (!Thread.interrupted()) {
                // 스레드 작업 수행
            }
        } catch (InterruptedException e) {
            // 스레드 중지 처리
        }
    }
}

```

- 스레드가 실행되면 Thread.interrupted() 가 false 이므로 반복문을 계속 실행한다
- 인터럽트가 발생하면 Thread.interrupted() 은 true 이고 반복문을 빠져 나오면서 스레드는 종료된다
- 인터럽트 상태는 해제 된다

```java
public class MyRunnable extends Runnable{
    public void run() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                // 스레드 작업 수행
            }
        } catch (InterruptedException e) {
            // 스레드 중지 처리
        }
    }
}
```

- 스레드가 실행되면 Thread.currentThread().isInterrupted() 가 false 이므로 반복문을 계속 실행한다
- 인터럽트가 발생하면 Thread.currentThread().isInterrupted() 은 true 이고 반복문을 빠져 나오면서 스레드는 종료된다
- 인터럽트 상태는 계속 유지 된다

### **3. Interrupted Exception**
대기중인 스레드에 interrupt() 하게 되면 InterruptedException 예외가 발생한다.

```java
    public static class MyRunnable implements Runnable {

    @SuppressWarnings("BusyWait")
    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(1000);
                System.out.println("Thread is Running");
            } catch (InterruptedException e) {
                System.out.println(e.getMessage());
                break;
            }
        }
        System.out.println("Thread is Done!");
    }
}

```
인터럽트가 발생하면(thread.interrupt() ) InterruptedException 예외가 발생하고 예외 구문에서 반복문을 빠져나오면서 스레드가 종료된다.(인터럽트 상태는 해제 된다.)
  
```java
    public static class MyRunnable implements Runnable {

    @SuppressWarnings("BusyWait")
    @Override
    public void run() {
        while (true) {
            try {
                if(Thread.interrupted()) throw new InterruptedException("interrupt occurred!");
                
                System.out.println("Thread is Running");
            } catch (InterruptedException e) {
                System.out.println(e.getMessage());
                Thread.currentThread().interrupt(); // 필요한 경우 인터럽트 상태를 원복
                break;
            }
        }
        System.out.println("Thread is Done!");
    }
}

```

## **사용자 스레드** vs **데몬 스레드**

Java에서 스레드는 크게 두 가지 유형으로 분류됩니다: 사용자 스레드(User Threads)와 데몬 스레드(Daemon Threads). 이 두 유형의 스레드는 용도와 JVM에서의 동작 방식이 다릅니다. 사용자 스레드는 사용자 스레드를 낳고 데몬 스레드는 데몬 스레드를 낳는다. 즉 자식 스레드는 부모 스레드의 상태를 상속 받는다. 자바가 실행되면 JVM은 사용자 스레드인 메인스레드와 나머지 데몬 스레드를 동시에 생성하고 시작한다.

### **메인 스레드 (Main Thread)**

- **정의**: 메인 스레드는 Java 애플리케이션의 진입점인 **`main()`** 메서드를 실행하는 스레드입니다.
- **특징**: 메인 스레드는 모든 Java 애플리케이션의 시작점이며, 기본적으로 사용자 스레드입니다.
- **용도**: 애플리케이션의 시작과 초기화, 다른 사용자 스레드의 생성 및 관리 등을 담당합니다.

메인 스레드는 어플리케이션을 실행하는최초의 스레드이자 실행을 완료하는 마지막 스레드의 역할을 한다. 메인 스레드에서 여러 하위 스레드를 추가로 시작할 수 있고 하위 스레드는 또 여러 하위 스레드를 시작할 수 있다 메인 스레드가 사용자 스레드이기 때문에 하위 스레드는 모두 사용자 스레드가 된다.

### **사용자 스레드 (User Threads)**

- **정의**: 사용자 스레드는 애플리케이션의 주 작업을 수행하는 스레드입니다. 이들은 애플리케이션의 핵심 기능을 담당합니다.
- **특징**: 사용자 스레드가 실행 중인 경우 JVM은 종료되지 않습니다. JVM은 모든 사용자 스레드가 작업을 완료할 때까지 계속 실행 상태를 유지합니다.
- **용도**: 일반적인 작업 수행, 계산 작업, I/O 작업 등 애플리케이션의 주된 기능을 수행하는 데 사용됩니다.

사용자 스레드는 메인 스레드에서 직접 생성한 스레드를 의미한다. 이 각각의 스레드는 독립적인 생명주기를 가지고 실행하게 된다.추가적으로 자바가 제공하는 스레드 풀인 ThreadPoolExecutor 은 사용자 스레드를 생성한다.

### **데몬 스레드 (Daemon Threads)**

- **정의**: 데몬 스레드는 백그라운드에서 보조적인 역할을 수행하는 스레드입니다. **사용자 스레드의 작업을 보조**하거나, **긴 시간 동안 실행되는 낮은 우선순위의 작업**을 수행합니다.
- **특징**: **모든 사용자 스레드가 종료되면, 데몬 스레드는 강제적으로 종료**됩니다. 즉, 데몬 스레드가 실행 중이더라도 JVM은 사용자 스레드가 모두 종료되면 종료됩니다.
- **용도**: 로그 기록, 시스템 모니터링, 가비지 컬렉션 등의 백그라운드 작업에 주로 사용됩니다.
- **설정 방법**: **`setDaemon(true)`** 메서드를 호출하여 스레드를 데몬 스레드로 설정할 수 있습니다. 이 설정은 **스레드가 시작되기 전에 수행**해야 합니다.
- **확인방법**: `isDaemon()` 메서드를 통해 이 스레드가 데몬인지 아닌지 확인합니다.

데몬 스레드는 JVM 에서 생성한 스레드이거나 직접 데몬 스레드로 생성한 경우를 말한다. 데몬 스레드의 생명주기는 사용자 스레드에 따라 다르며 낮은 우선순위를 가지고 background 에서 실행된다. 데몬 스레드는 사용자 스레드를 보조 및 지원하는 성격을 가진 스레드로서 보통 사용자 작업을 방해하지 않으면서 백그라운드에서 자동으로 작동되는 기능을 가진 스레드이다. 자바가 제공하는 스레드 풀인 ForkJoinPool 은 데몬 스레드를 생성한다.

## 스레드 그룹

Java에서 `ThreadGroup`은 여러 스레드를 하나의 객체로 묶어 관리할 수 있게 해주는 메커니즘입니다. 스레드 그룹을 사용하면 스레드들을 그룹 단위로 쉽게 제어하고 정보를 얻을 수 있으며, 스레드들을 계층적으로 관리할 수도 있다. 이때 한 스레드 그룹 안에 다른 스레드 그룹도 포함될 수 있고 그룹 내의 모든 스레드는 한번에 종료하거나 중단할 수 있다.

스레드는 **반드시 하나의 스레드 그룹에 포함되어야 하며** 명시적으로 스레드 그룹에 포함시키지 않으면 **기본적으로 자신을 생성한 스레드가 속해 있는 스레드 그룹에 포함**되어 진다.(일반적으로 main 스레드에서 생성하는 모든 세레드는 main 스레드의 그룹에서 속함)

### **ThreadGroup의 주요 기능**

1. **스레드 관리**: `ThreadGroup`은 그 안에 속한 모든 스레드를 추적하고 관리할 수 있게 해줍니다. 예를 들어, 그룹 내 모든 스레드에 대해 인터럽트를 호출하거나 스레드의 우선순위를 변경할 수 있습니다.
2. **보안 및 접근 제어**: `ThreadGroup`을 사용하면 보안상의 이유로 특정 그룹의 스레드에만 작업을 제한할 수 있습니다.
3. **에러 처리**: `ThreadGroup`은 그룹 내 스레드에서 발생하는 예외를 캡처하고 처리하는 데 사용될 수 있습니다.
4. **스레드 계층 구조**: 스레드 그룹은 다른 스레드 그룹을 포함할 수 있어, 스레드 계층 구조를 형성할 수 있습니다. 이는 스레드 관리를 계층적으로 수행할 수 있게 해줍니다.

### **JVM 스레드 그룹 생성 과정**

1. **시스템 스레드 그룹 생성**: JVM이 시작될 때, 가장 먼저 "system"이라는 최상위 스레드 그룹이 생성됩니다. 이 그룹은 JVM의 모든 스레드 그룹의 루트입니다.
2. **메인 스레드 그룹 생성**: "system" 스레드 그룹 내에 "main" 스레드 그룹이 생성됩니다. 사용자가 작성한 메인 애플리케이션의 스레드들, 즉 **`public static void main(String[] args)`** 메서드를 실행하는 스레드는 이 "main" 그룹에 속하게 됩니다.
3. **기타 시스템 스레드 그룹**: JVM은 내부적으로 여러 가지 서비스를 수행하기 위해 데몬 스레드 그룹(예: "Finalizer", "Reference Handler" 등)을 생성합니다. 이들 스레드 그룹은 주로 가비지 컬렉션, 객체 최종화, JVM 내부 참조 처리 등의 작업을 담당합니다.

### **스레드 그룹의 계층 구조**

- **계층적 구조**: 스레드 그룹은 계층적인 구조를 가지고 있습니다. 모든 스레드 그룹은 최상위 "system" 그룹의 하위 그룹이거나, 다른 스레드 그룹의 하위 그룹일 수 있습니다.
- **스레드 할당**: 각 스레드 그룹은 하나 이상의 스레드를 포함할 수 있으며, 스레드는 생성 시 할당된 스레드 그룹에 속하게 됩니다.
- **자식 스레드 그룹**: 스레드 그룹은 다른 스레드 그룹을 포함할 수도 있으며, 이를 통해 더 세분화된 스레드 관리가 가능합니다.

### **ThreadGroup Class**

### **생성자**

1. **ThreadGroup(String name)**
    - **설명**: 지정된 이름으로 새 스레드 그룹을 생성합니다. 이 그룹의 부모는 현재 스레드가 속한 스레드 그룹이 됩니다.
    - **매개변수**: **`name`** - 스레드 그룹의 이름입니다.
2. **ThreadGroup(ThreadGroup parent, String name)**
    - **설명**: 지정된 부모 스레드 그룹에 속하는 새 스레드 그룹을 생성합니다.
    - **매개변수**:
        - **`parent`** - 이 스레드 그룹의 부모 그룹입니다.
        - **`name`** - 스레드 그룹의 이름입니다.

### **주요 메서드**

1. **void activeCount()**
    - **설명**: 현재 스레드 그룹과 하위 그룹에서 활성화된 스레드의 추정 수를 반환합니다.
2. **void activeGroupCount()**
    - **설명**: 스레드 그룹에서 활성화된 하위 스레드 그룹의 추정 수를 반환합니다.
3. **void checkAccess()**
    - **설명**: 현재 스레드가 이 스레드 그룹에 대한 수정 권한을 가지고 있는지 확인합니다.
4. **void destroy()**
    - **설명**: 스레드 그룹을 파괴하고, 모든 하위 그룹을 파괴합니다. 스레드 그룹이 비어 있어야 합니다.
5. **int enumerate(Thread[] list)**
    - **설명**: 스레드 그룹과 그 하위 그룹에서 활성화된 스레드를 주어진 배열에 복사합니다.
6. **int enumerate(ThreadGroup[] list)**
    - **설명**: 이 스레드 그룹의 하위 그룹을 주어진 배열에 복사합니다.
7. **int getMaxPriority()**
    - **설명**: 이 스레드 그룹의 최대 우선순위를 반환합니다.
8. **String getName()**
    - **설명**: 이 스레드 그룹의 이름을 반환합니다.
9. **ThreadGroup getParent()**
    - **설명**: 이 스레드 그룹의 부모 그룹을 반환합니다.
10. **void interrupt()**
    - **설명**: 이 스레드 그룹에 속한 모든 스레드에 **`interrupt()`**를 호출합니다.
11. **boolean isDaemon()**
    - **설명**: 이 스레드 그룹이 데몬 그룹인지 여부를 반환합니다.
12. **void setDaemon(boolean daemon)**
    - **설명**: 스레드 그룹을 데몬 그룹으로 설정하거나 해제합니다.
13. **void setMaxPriority(int pri)**
    - **설명**: 이 스레드 그룹의 최대 우선순위를 설정합니다. 이때 그룹에 포함된 스레드들은 그룹에서 지정한 우선순위 보다 높은 우선순위를 설정할 수 없다.
14. **void uncaughtException(Thread t, Throwable e)**
    - **설명**: 이 스레드 그룹에서 처리되지 않은 예외가 발생했을 때 호출됩니다.
15. **void list**
    - **설명** : 현재 그룹에 포함된 스레드와 하위 그룹에 대한 정보를 출력합니다.

### **ThreadGroup 사용 예시**

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " is running");
    }

    public static void main(String[] args) {
        ThreadGroup threadGroup = new ThreadGroup("MyThreadGroup");

        Thread t1 = new Thread(threadGroup, new MyRunnable(), "Thread 1");
        Thread t2 = new Thread(threadGroup, new MyRunnable(), "Thread 2");

        t1.start();
        t2.start();

        System.out.println("Thread Group Name: " + threadGroup.getName());
    }
}

```

이 예제에서는 "MyThreadGroup"이라는 이름의 `ThreadGroup`을 생성하고, 이 그룹에 두 개의 스레드를 할당합니다. 이 그룹에 속한 스레드들은 **`run()`** 메서드에서 간단한 메시지를 출력합니다.


## ThreadLocal

`ThreadLocal`은 자바에서 스레드별로 변수를 분리하여 저장할 수 있게 해주는 유틸리티이다. 즉 자바에서는 **오직 자시만이 접근해서 읽고 쓸수 있는 로컬 변수 저장소**를 제공하는데 이를 `ThreadLocal` 이라고 한다. 각 스레드가 독립적인 변수의 인스턴스를 갖도록 하여, 스레드 간의 데이터 충돌을 방지하고 이는 멀티 스레드 환경에서 자주 사용되며, 특히 서버 사이드 애플리케이션 개발에서 유용하다.  
  
각 스레드는 고유한 ThreadLocal 객체를 속성으로 가지고 있으며 ThreadLocal은 스레드 간 격리되어 있다. 스레드는 ThradLocal 에 저장된 값을 특정한 위치나 시점에 상관없이 어디에서나 전역변수처럼 사용할 수 있다. 변수 값을 전달하지 않아도 된다. **모든 스레드가 공통적으로 처리해야하는 기능**이나 객체를 제어해야 하는 사황에서 스레드마다 다른 값을 적용해야 하는 경우 사용한다.(인증 주체 보관, 트랜잭션전파,로그 추적기등)
  
클라이언트에서 요청1,요청2,요청3을 서버로 요청했을대 WAS는 해당 요청마다 스레드를 생성하게된다. 이 생성된 스레드들은 ThreadLocal이라는 속성을 가지고 있고 이 속성은 개별적으로 ThreadLocalMap이라는 객체를 만들어서 스레드 마다 할당한다.

### **ThreadLocal의 사용 방법**

1. **ThreadLocal 인스턴스 생성**: `ThreadLocal`은 보통 **`private static`** 필드로 선언된다.

    ```java
    private static final ThreadLocal<MyObject> threadLocalInstance = new ThreadLocal<>();
    
    ```

2. **값 설정하기**: 각 스레드에서 **`ThreadLocal`** 인스턴스의 **`set()`** 메서드를 사용하여 값을 설정할 수 있습니다.

    ```java
    threadLocalInstance.set(new MyObject());
    
    ```

3. **값 가져오기**: 스레드 내에서 **`get()`** 메서드를 사용하여 저장된 값을 검색합니다.

    ```java
    MyObject obj = threadLocalInstance.get();
    
    ```

4. **값 제거하기**: 스레드가 더 이상 사용하지 않는 경우, **`remove()`** 메서드를 호출하여 리소스를 해제합니다.

    ```java
    threadLocalInstance.remove();
    
    ```
5. **withInitial(Supplier <? extends S> supplier)**: 스레드 로컬을 생성하면서 특정 값으로 초기화한다.   
    ```java
    ThreadLocal<String> threadLocal = ThreadLocal.withInitial(()->"defaultName");
    ```
    
### Thread & ThreadLocal

### **Thread**

   - `Thread`는 자바에서 독립적인 실행 흐름을 나타내는 기본 단위입니다.
   - 멀티스레딩 환경에서 여러 스레드가 동시에 실행되면서 각각의 작업을 병렬적으로 처리할 수 있습니다.
   - 각 스레드는 공유 자원에 접근할 수 있으며, 이로 인해 데이터의 일관성과 동기화 문제가 발생할 수 있습니다.
   - 스레드 생성시 threadLocals 의 기본값은 null이며 threadLocal에 값을 지정할 때 ThreadLocalMap 이 생성되고 threadLocals 과 연결된다.
   - 스레드가 전역적으로 값을 참조할 수 있는 원리는 스레드 ThreadLocal의 TreadLocalMap 에 접근해서 여기에 저장된 값을 바로 꺼내어 쓸수 있기 때문이다.

### **ThreadLocal**

- `ThreadLocal`은 각 스레드에게 고유한 데이터 저장소를 제공합니다.
- 스레드 내부에서만 접근 가능한 데이터를 저장하는데 사용되며, 다른 스레드와의 데이터 격리를 보장합니다.
- `ThreadLocal`을 사용하면 각 스레드는 동일한 변수에 대해 서로 다른 값을 유지할 수 있습니다. 이는 멀티스레딩 환경에서 데이터 충돌이나 동기화 문제를 방지하는 데 도움이 됩니다.

### **ThreadLocalMap**

  - `ThreadLocalMap`은 **`ThreadLocal`** 객체와 연관된 값을 저장하는 내부 클래스입니다. 이는 해시맵과 유사하지만, 키로 **`ThreadLocal`** 객체를 사용합니다.
  - `ThreadLocal`의 각 인스턴스가 스레드별로 다른 값을 가질 수 있도록, 해당 스레드에 대한 고유한 값들을 저장합니다.
  - ThreadLocalMap 은 항상 새롭게 생성되어 스레드 스택에 저장되기때문에 근본적으로 스레드간 데이터 공유가 될 수 없고 따라서 동시성 문제가 발생하지 않는다.

   ### **Thread의 threadLocals 필드**

  1. **정의**: **`Thread`** 클래스 내에는 `threadLocals`라는 필드가 있습니다. 이 필드는 해당 스레드에 속한 **`ThreadLocal`** 변수들의 값을 저장하는 `ThreadLocalMap`의 인스턴스를 참조합니다.
  2. **작동 방식**:
      - `ThreadLocal`의 **`set`** 또는 **`get`** 메서드가 호출될 때, 현재 스레드의 **`threadLocals`** 필드에 접근합니다.
      - 해당 `ThreadLocalMap`에 **`ThreadLocal`** 객체를 키로 사용하여 값을 저장하거나 조회합니다.
      - 각 스레드는 자신만의 **`threadLocals`** 필드를 가지므로, 다른 스레드의 **`ThreadLocal`** 값에 영향을 받지 않습니다.

### **상호작용 흐름**

  1. **값 설정**: 스레드에서 `ThreadLocal`의 **`set`** 메서드를 호출하면, 현재 스레드의 **`threadLocals`** 필드에 접근하여 `ThreadLocalMap`에 값을 저장합니다.(스레드 생성 시 threadLocals 기본값은 null)
  2. **값 조회**: **`get`** 메서드를 호출할 때, 같은 방식으로 현재 스레드의 **`threadLocals`** 필드에 저장된 `ThreadLocalMap`에서 해당 **`ThreadLocal`** 객체에 연관된 값을 조회합니다.
  3. **값 제거**: **`remove`** 메서드를 호출하면, `ThreadLocalMap`에서 해당 **`ThreadLocal`** 객체와 연관된 값을 제거합니다.


### **ThreadLocal의 주의점**

- **메모리 누수**: `ThreadLocal`을 사용할 때는 메모리 누수에 주의해야 합니다. 각 스레드가 끝나더라도 `ThreadLocal`에 저장된 객체가 GC(가비지 컬렉션)에 의해 회수되지 않을 수 있기 때문에, 필요 없어진 **`ThreadLocal`** 변수는 **`remove()`** 메서드를 호출하여 명시적으로 제거해야 합니다.
- **스레드 풀 사용 시 주의**: 스레드 풀을 사용하는 환경에서 `ThreadLocal`을 사용할 때는 각 작업이 끝날 때마다 **`ThreadLocal`** 값을 제거해야 합니다. 그렇지 않으면 다음에 그 스레드가 재사용될 때 이전 작업의 데이터가 남아있을 수 있습니다.
  
### ThreadLocal 작동원리
- ThreadLocal은 Thread와 ThreadLocalMap을 연결하여 스레드 전용 저장소를 구현하고 있는데 이것이 가능한 이유는 바로 Thread.currentThread()를 참조할 수 있기때문이다.
- Thread.currentThread()는 현재 실행중인 스레드의 객체를 참조하는 것으로 **CPU 는 오직 하나의 스레드만 할당받아 처리하기 때문에** ThreadLocal 에서 Thread.currentThread()를 참조하면 **지금 실행중인 스레드의 로컬 변수를 저장하거나 참조할 수 있게된다.**
- ThreadLocal 에서 현재 스레드를 참조할 수 있는 방법 없다면 값을 저장하거나 요청하는 스레드를 식별할 수 없기 때문에 **Thread.currentThread() 는 ThreadLocal의 중요한 데이터 식별 기준**이 된다.

   ### **사용 예제**

  ```java
  public class MyRunnable implements Runnable {
      private static final ThreadLocal<Integer> threadId = new ThreadLocal<Integer>() {
          @Override
          protected Integer initialValue() {
              return nextId.getAndIncrement();
          }
      };
    
      private static final AtomicInteger nextId = new AtomicInteger(0);
    
      public void run() {
          System.out.println("스레드 ID: " + threadId.get());
      }
  }
    
  ```

   이 예제에서 **`MyRunnable`** 클래스는 스레드마다 고유한 ID를 생성하고 출력합니다. `ThreadLocal`의 **`initialValue()`** 메서드를 오버라이드하여 초기 값을 설정할 수 있다.

### ThreadLocal 작동원리

   `ThreadLocal`의 작동 원리를 이해하기 위해서는 먼저, 자바 멀티스레딩 환경에서 스레드가 어떻게 작동하는지, 그리고 `ThreadLocal`이 이 환경에서 어떻게 스레드별로 데이터를 격리하는지를 살펴봐야 한다.

### **기본 개념**

  1. **스레드**: 자바에서 스레드는 프로세스 내에서 실행되는 독립적인 실행 흐름입니다. 각 스레드는 자신만의 스택을 갖지만, 힙과 메서드 영역 같은 메모리 영역은 다른 스레드와 공유합니다.
  2. **스레드별 데이터 격리**: 멀티스레딩 환경에서 데이터의 일관성과 안전성을 유지하기 위해, 각 스레드가 서로 독립적인 데이터를 유지하거나 접근할 필요가 있습니다. 이를 위해 **`ThreadLocal`**을 사용합니다.

### 예제 동작 과정
  1. **ThreadLocal 인스턴스**: **`ThreadLocal`** 객체는 스레드별로 고유한 값을 유지합니다. 각 스레드는 이 **`ThreadLocal`** 객체를 통해 자신만의 값을 저장하고 조회할 수 있습니다.
  2. **ThreadLocalMap**: 내부적으로, **`ThreadLocal`**은 **`ThreadLocalMap`**이라는 특수한 맵을 사용합니다. 이 맵은 키로 **`ThreadLocal`** 객체를 사용하고, 값으로 스레드별 데이터를 저장합니다. 중요한 점은 이 맵이 각 스레드에 대해 독립적으로 존재한다는 것입니다.
  3. **Thread 객체와의 관계**: 자바의 **`Thread`** 클래스에는 **`ThreadLocal.ThreadLocalMap`** 타입의 **`threadLocals`**라는 필드가 있습니다. **`ThreadLocal`**이 **`get()`** 또는 **`set()`** 메서드를 호출할 때, 현재 스레드의 **`threadLocals`** 맵에 접근하여 해당 스레드의 **`ThreadLocal`** 변수에 값을 저장하거나 조회합니다.
  4. **값의 저장과 조회**:
      - **`set()`** 메서드를 호출하면, 현재 스레드의 **`ThreadLocalMap`**에 값이 저장됩니다.
      - **`get()`** 메서드를 호출하면, 현재 스레드의 **`ThreadLocalMap`**에서 해당 **`ThreadLocal`** 변수의 값을 조회합니다.
      - **`remove()`** 메서드를 사용하여 특정 **`ThreadLocal`** 인스턴스에 저장된 값을 제거할 수 있습니다.
  5. **스레드별 격리**: 이 메커니즘 덕분에, 각 스레드는 **`ThreadLocal`** 변수에 대해 독립적인 값을 유지할 수 있으며, 다른 스레드의 **`ThreadLocal`** 변수 값에 영향을 받지 않습니다.

  ```java
  public class MyRunnable implements Runnable {
      private ThreadLocal<Integer> threadLocal = new ThreadLocal<>();
    
      @Override
      public void run() {
          threadLocal.set((int) (Math.random() * 100D));
          try {
              Thread.sleep(2000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println(threadLocal.get());
      }
  }
  ```

   ### **InheritableThreadLocal**

  - InheritableThreadLocal은 ThreadLocal의 확장 버전으로서 부모 스레드로부터 자식 스레드로 값을 전달하고 싶을 경우 InheritableThreadLocal을 사용할 수 있다
  - **값의 상속:**
      - 부모 스레드가 InheritableThreadLocal 변수에 값을 설정하면, 해당 부모 스레드로부터 생성된 자식 스레드들은 부모의 값을 상속받게 된다
  - **독립성**
      - **자식 스레드가 상속받은 값을 변경하더라도 부모 스레드의 값에는 영향을 주지 않는다.**

  ```java
  public class MyRunnable implements Runnable {
      private static final InheritableThreadLocal<Integer> inheritableThreadLocal = new InheritableThreadLocal<>();
    
      @Override
      public void run() {
          System.out.println("상속받은 값: " + inheritableThreadLocal.get());
      }
    
      public static void main(String[] args) {
          inheritableThreadLocal.set(100);
    
          Thread childThread = new Thread(new MyRunnable());
          childThread.start();
      }
  }
  ```
   
  
## 동기화 개념
  
### 싱글 스레드 와 멀티 스레드
프로세스는 오직 한개의 스레드로만 구성하는 싱글 스레드 프로세스와 하나 이상의 스레드로 구성하는 멀티 스레드 프로세스로 구분할 수 있다. 작업 처리에 있어서 단일 스레드와 멀티 스레드의 선택 기준은 어떤 방식이 자원을 효율적으로 사용하고 성능처리에 유리한가 하는 점이다.

### 단일 스레드
순차 실행  

| 장점 | 단점 |
| --- | --- |
| 문맥교환이 없다 | CPU 멀티코어 활용 못함 |
| 동기화 이슈가 없다 | 순차적 실행으로 응답성 및 전체 처리량이 낮다 |
| 자원 비용이 적다 | I/O 처리 시 CPU 가 낭비된다 |
| 프로그래밍 난이도가 낮다 | 스레드에 오류가 발생하면 프로그램이 종료된다 |

### 멀티 스레드
동시적, 병렬적 실행  

| 장점 | 단점 |
| --- | --- |
| 동시성으로 사용자의 응답성 향상 | 빈번한 문맥교환으로 성능이 저하 된다 |
| CPU 멀티코어의 병렬성으로 성능 향상 | 스레드 간 동기화 이슈가 발생한다 |
| CPU 낭비 없는 자원의 효율적인 사용 | 스레드 생성 비용이 작지 않다 |
| 한 스레드 오류는 다른 스레드에 영향이 없다 | 프로그래밍 난이도가 높다 |

현대 CPU는 대부분 멀티코어를 지원하기 때문에 병렬적 성능 및 동시적 자원 사용 관점에서는 싱글 스레드보다 멀티 스레드 기반 프로그래밍이 유리한 점이 많다. 간혹 **싱글 스레드에서 비동기 프로그래밍**은 많은 수의 멀티 스레드 기반 프로그래밍 보다 더 좋은 성능과 응답성을 보여줄 수 있다.

## 멀티 스레딩 과 동시성

CPU 의 동시적 작업 처리는 CPU 코어 개수보다 스레드의 개수가 많을 때 즉 , 멀티스레딩 환경에서 자원을 효율적으로 배분하고 사용하기 위해 설계된 방식이다. 같은 프로그램 안에서 실행되는 여러 스레드가 읽기 및 쓰기 **작업을 같은 메모리 영역에서 동시에 실행할 경우** `동시성 문제`가 대두된다.  
  
동시성 문제라 함은 하나의 스레드가 어떤 메모리 영역의 데이터를 쓰고 있는데 또 다른 스레드가 같은 메모리 영역의 데이터를 읽거나 쓸 경우 발생할 수 있는 문제이다.**동시성 문제는 싱글스레드에서는 절대 발생하지 않으며 멀티 스레드를 운용하는 어플리케이션에서 나타나는 현상**이다.

> **멀티 스레딩 (Multithreading)**
>
> 1. **정의**: 멀티 스레딩은 프로세스 내에서 여러 스레드가 동시에 실행되는 것을 말합니다. 스레드는 프로세스의 가장 작은 실행 단위로, 프로세스의 자원을 공유하면서 독립적인 작업을 수행할 수 있습니다.
> 2. **목적**: 멀티 스레딩은 CPU의 사용률을 극대화하고, 응답 시간을 단축시키며, 자원의 효율적인 사용을 가능하게 합니다. 특히, I/O 바운드 작업이 많은 애플리케이션에서 성능 향상을 가져올 수 있습니다.

이 멀티 스레딩 환경에서 `공유 작원을 선점`하기 위해 발생하는 스레드간의 동시성 문제는 자바 프로그램 개발에 있어서 반드시 이해해야 할 중요한주제이고 복잡하며 난해하다.

### **멀티 스레딩과 동시성 프로그래밍의 주요 포인트**

- **동기화**: 공유 자원에 대한 접근을 제어하여 데이터의 일관성을 유지합니다.
- **데드락 방지**: 여러 자원을 요청하는 스레드 간의 무한 대기 상태를 방지합니다.
- **스레드 관리**: 스레드 생명주기를 관리하고, 자원을 효율적으로 할당합니다.
- **성능 최적화**: 스레드 풀, 비동기 I/O와 같은 기술을 활용하여 시스템 자원을 최적화합니다.
- **오류 처리**: 멀티 스레딩 환경에서 발생할 수 있는 예외와 오류를 효과적으로 처리합니다.

이 밖에 확인해야 되고 알아야 할 주제가 방대하다.

## 동기화 와 CPU 관계

## 동기화(Synchronization) 란

여러 스레드가 동시에 같은 데이터나 자원에 접근할 때, 데이터의 일관성과 정확성을 유지하기 위해 사용된다. 멀티스레딩 환경에서 여러 스레드가 동시에 같은 메모리(변수, 객체 등)에 접근하게 되면, 예상치 못한 결과나 데이터 불일치가 발생할 수 있다. 이러한 문제를 **동시성 문제**라고 한다. `동기화`는 이러한 문제를 방지하기 위해 필하다.

## CPU 연산처리 이해

모든 기계어 명령(machine instruction) 은 **원자성(atimicity)** 을 갖는데 이는 **하나의 기계어 명령어가 실행을 시작할 경우 그 명령의 수행 종료시 까지는 인터럽트(interrupt)를 받지 않는다.** 분리 불가능(indivisible) 이라고도 한다.  
  
**CPU 가 두 개 이상의 명령어를 처리할 경우에은 원자성이 보장되지 않는데** 이는 각 명령을 수행하는 중에 OS 가 다른 스케줄링으로 CPU 에게 다른 명령을 수행하게 함으로써 현재 수행중인 명령을 인터럽트 즉 중단하게 된다는 의미이다. **두 개 이상의 명령어를 원자성으로 묶기 위해서는 스레드 간 동기화 메카니즘이 필요**하다. 즉 한 스레드가 모든 명령을 다 수행될 때까지 도중에 중단되지 않도록 해야 한다.

> **원자성(Atomicity)이란**
> 컴퓨터 프로그래밍과 CPU 연산에서 사용되는 중요한 개념으로, **하나의 작업이나 명령이 중간 단계 없이 완전히 수행되거나** **전혀 수행되지 않는 성질을 의미**합니다. 원자적인 작업은 분할할 수 없으며, 실행 중에는 어떠한 다른 프로세스나 스레드에 의해 방해받지 않습니다.
>

### **원자성의 예**

- **원자적 연산**: 예를 들어, 변수에 대한 증가 연산(**`x++`**)은 원자적이지 않습니다.  이 연산은 실제로 '값 읽기', '값 증가', '값 쓰기'의 세 단계로 구성됩니다. 멀티스레딩 환경에서 두 스레드가 동시에 **`x++`** 연산을 수행하면, 동시성 문제로 인해 예상치 못한 결과가 발생할 수 있습니다.
- **원자성 보장 메커니즘**: 이를 해결하기 위해, 자바에서는 **`synchronized`** 블록이나 메서드를 사용하여 연산 전체를 원자적으로 만들 수 있습니다. 또한, **`java.util.concurrent.atomic`** 패키지의 클래스들은 원자적 연산을 지원합니다.
  
여기서 하나의 기계 명령어에 한해서 원자성을 보장해준다고 했을때 하나의 기계 명령어란 **값 읽기**, **값 증가**, **값 쓰기**   이 3개중 1개의 명령어에 한해서 원자성을 보장해서 동시성 문제가 발생하지 않는다는 말이다.  
  
즉, 특정 변수에 대한 증가 중에서 오직 값 읽기, 오직 값 증가, 오직 값 쓰기 각각의 명령어만 원자성을 보장해주고 이 모든것을 합친 변수에 대한 증가에 대해서는 원자성을 보장하지 않는다.(2개 이상의 기계어 명령어는 원자성을 보장하지 않음)  
따라서 동시성문제가 발생하고 이를 해결하기 위해서 동기화 작업이 필요하다.
### **원자성 구현 방법**

1. **Synchronized 키워드**: **`synchronized`** 블록이나 메서드는 한 번에 하나의 스레드만 해당 코드 블록을 실행할 수 있도록 합니다. 이는 여러 스레드에 의한 동시 접근을 방지하여 원자성을 보장합니다.
2. **Lock 인터페이스**: **`java.util.concurrent.locks.Lock`** 인터페이스를 사용하여 명시적인 락을 제공하고, 락을 획득하고 해제하는 방식으로 원자성을 보장할 수 있습니다.
3. **Atomic 클래스**: **`java.util.concurrent.atomic`** 패키지는 원자적 연산을 지원하는 클래스들을 제공합니다. 예를 들어, `AtomicInteger`는 원자적으로 정수 값을 증가시키거나 감소시킬 수 있는 메서드를 제공합니다.

즉, 결론적으로 CPU 에서 원자성을 보장하지 않는 모든 연산 처리는 스레드 간 동시적 접근에 의해 데이터 불일치가 발생할 수 있다.  

### **동기화의 방법**

1. **Synchronized 메서드**:
    - 메서드 전체를 동기화합니다.
    - 해당 메서드는 한 시점에 하나의 스레드만 실행할 수 있습니다.
    - 예: **`public synchronized void method() { /* ... */ }`**
2. **Synchronized 블록**:
    - 코드의 특정 부분만을 동기화합니다.
    - 동기화할 객체를 명시할 수 있습니다.
    - 예:

        ```java
        synchronized(this) {
            // 동기화 블록
        }
        
        ```


### **동기화의 특징**

- **락(Lock)**: 동기화를 사용하면, 해당 부분의 코드(블록 또는 메서드)에 락이 걸립니다. 이 락은 동기화된 블록이나 메서드를 실행하는 스레드에 의해서만 해제될 수 있습니다.
- **스레드 안전(Thread Safety)**: 동기화는 스레드 안전을 보장합니다. 즉, 여러 스레드가 동시에 같은 객체의 동기화된 메서드나 블록에 접근하더라도 데이터의 일관성과 정확성이 유지됩니다.
- **성능 저하**: 동기화는 필요한 경우에만 사용해야 합니다. 불필요한 동기화는 성능 저하를 초래할 수 있습니다.

### **동기화의 예시**

Java에서 동기화를 사용하는 간단한 예시는 다음과 같습니다.

```java
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

```

이 예제에서 **`increment`** 메서드와 **`getCount`** 메서드는 **`synchronized`** 키워드를 사용하여 동기화되어 있습니다. 이는 한 번에 하나의 스레드만이 이 메서드들을 실행할 수 있음을 의미하며, **`count`** 변수에 대한 동시 접근을 방지합니다.



### 스레드 불일치 예시
```java
class Counter {
    private int count = 0;

    // 원자적이지 않은 증가 메서드
    public void increment() {
        count++;  // '읽기', '증가', '쓰기'의 세 단계로 구성됨
    }

    public int getCount() {
        return count;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        final Counter counter = new Counter();

        // 스레드 1
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        // 스레드 2
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Expected count: 2000");
        System.out.println("Actual count: " + counter.getCount());
    }
}
```

## Critical Section(임계영역, 공유 변수 영역)

임계 영역(Critical Section)은 멀티스레딩 프로그램에서 **두 개 이상의 스레드가 동시에 접근하면 안 되는 코드 영역**을 말한다. 이 영역은 공유 자원(예: 변수, 파일)을 사용하는 코드를 포함하고 있으며, 여러 스레드에 의해 동시에 접근되면 데이터 불일치나 예상치 못한 결과를 초래할 수 있다.

이 임계 영역은 entry section, critical section, exit section, remainder section 으로 구성 된다.

- entry section(입장영역) : critical section 에 진입하기 위해 진입허가를 요청하는 영역입니다.
- **critical section(임계영역)** : 하나의 스레드만 접근할 수 있는 영역이다
- exit section(퇴장영역) : critical section 에서 빠져나올 때 신호를 알리는 영역이다
- remainder section (나머지영역) : entry section, critical section, exit section 을 제외한 나머지 영역이다


### Critical Section Problem
한 스레드가 임계 영역을 실행하고 일을 때 다른 스레드가 같은 임계영역을 상용함으로서 발생한다.  
이 문제의 해결책을 위해서 3가지 충족조건이 있다.
* **Mutual Exclusion (상호 배제)**
    * 어떤 스레드가 임계 영역을 실행중이면 다른 스레드는 동일한 임계영역을 실행할 수 없다.
* **Progress(진행)**
    * 임계 구역에서 실행 중인 스레드가 없고 임계 구역에 진입하련느 스레드가 있을때 어떤 스레드가 들어갈 것인지 적절히 선택해 줘야 하며 이러한 결정은 무한정 미뤄져선 안된다.
* **Bounded Waiting(한정 대기)**
    * 다른 스레드가 임계 영역에 들어가도록 요청한 후 해당 요청이 수락되기 전에 기존 스레드가 임계영역에서 실행할 수 있는 횟수에 제한이 있어야한다.
    * Starvation(기아상태) 이 발생하지 않도록 한다.

### 동기화 도구
뮤텍스, 세마포어, 모니터, CAS(Compare and Swap) 와 같은 동기화 도구를 통해 임계영역에서 문제가 발생하지 않도록 할 수 있으며 자바에서는 synchronized 키워드를 포함한 여러 동기화 도구들을 제공하고 있다.

### **자바에서의 임계 영역 처리 방법**

1. **Synchronized 메서드**
    - 메서드 전체를 임계 영역으로 지정합니다.
    - **`synchronized`** 키워드를 메서드 선언에 추가하여 사용합니다.
    - 이 메서드는 한 번에 하나의 스레드만이 접근할 수 있습니다.
    - 예:

        ```java
        
        public synchronized void increment() {
            // 임계 영역
        }
        
        ```

2. **Synchronized 블록**
    - 특정 객체에 대한 동기화된 블록을 생성합니다.
    - 임계 영역 내에서 필요한 최소한의 코드만을 포함시킵니다.
    - 예:

        ```java
        
        public void increment() {
            synchronized(this) {
                // 임계 영역
            }
        }
        
        ```

3. **Lock 인터페이스**
    - **`java.util.concurrent.locks`** 패키지의 **`Lock`** 인터페이스를 사용합니다.
    - 명시적으로 락을 획득하고 해제합니다.
    - **`ReentrantLock`** 클래스가 일반적으로 사용됩니다.
    - 예:

        ```java
        
        Lock lock = new ReentrantLock();
        
        public void increment() {
            lock.lock();
            try {
                // 임계 영역
            } finally {
                lock.unlock();
            }
        }
        
        ```

4. **Atomic 변수**
    - **`java.util.concurrent.atomic`** 패키지에 있는 클래스들을 사용합니다.
    - 원자적 연산을 통해 락 없이도 스레드 안전을 보장할 수 있습니다.
    - 예: **`AtomicInteger`**, **`AtomicLong`** 등

   ### 예시

    ```java
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    class CriticalSectionExample {
        private final Lock lock = new ReentrantLock();
        private int sharedResource = 0;
    
        public void criticalSection() {
            // 진입 구역 (Entry Section)
            lock.lock(); // 임계 영역 진입 전 락을 획득
    
            try {
                // 임계 구역 (Critical Section)
                sharedResource++; // 공유 자원에 대한 연산 수행
    
                // 퇴장 구역 (Exit Section)
                // 이 경우 특별한 퇴장 작업은 없음
    
            } finally {
                // 락 해제
                lock.unlock();
            }
    
            // 나머지 구역 (Remainder Section)
            // 임계 영역과 무관한 나머지 작업 수행
            nonCriticalSection();
        }
    
        public void nonCriticalSection() {
            // 임계 영역 외의 작업 수행
        }
    }
    ```

    - **진입 구역**: **`lock.lock()`** 호출로 시작합니다. 이 부분에서 현재 스레드는 임계 구역에 진입하기 위해 락을 획득하려고 시도합니다.
    - **임계 구역**: `sharedResource++`는 실제 공유 자원을 수정하는 임계 구역입니다. 이 부분은 한 번에 하나의 스레드만 접근할 수 있어야 합니다.
    - **퇴장 구역**: **`finally`** 블록 내부에서 `lock.unlock()`을 호출하여 임계 구역을 빠져나옵니다. 이는 다른 스레드가 이제 임계 구역에 진입할 수 있음을 의미합니다.
    - **나머지 구역**: **`nonCriticalSection()`** 메서드는 임계 구역과 무관한 다른 작업을 수행하는 부분으로, 락과 관련이 없습니다.

### Race Condition(경쟁상태, 경쟁조건, 경합 상태)
여러 스레드가 동시에 **공유 자원에 접근하고 조작할때 스레드간 접근하는 순서나 시점에 따라 실행 결과가 달라질** 수 있는데 이것을 경쟁상태 라고 한다. 경쟁 상태는 임계영역에서 발생하는 문제들이 해결 되지 않는 상태에서 여러 스레드가 동시에 임계 영역에 접근해서 공유 데이터를 조작함으로써 발생하는 상태라 할 수 있다.


## 안전한 스레드 구성

여러 스레드에서 클래스나 객체에 동시에 접근해서 계속 실행하더라도 **지속적인 정확성이 보장**되는 코드를 **스레드 세이프(thread-safe)** 즉 스레드에 안전하다고 한다. 기본적으로 클래스 명세에 스레드 안정성을 헤치는 코드나 상태를 가지고 있지 않으면 스레드에 안전하다라고 정의할 수 있다. 스레드에 안전한 코드에는 경쟁상태가 없으며 경쟁 상태는 다수의 스레드가 공유 자원에 쓰기 작업을 시도할 때 발생하기 때문에 스레드가 실행될 때 어떤 자원을 공유하게 되는지 아는 것이 중요하다.

### **스레드 세이프의 중요성**

- **데이터 일관성**: 멀티스레딩 환경에서 공유 자원에 대한 동시 접근은 데이터의 불일치를 초래할 수 있습니다. 스레드 세이프한 구현은 이러한 문제를 방지한다.
- **오류 방지**: 잘못된 동기화는 데드락, 레이스 컨디션 등의 오류를 발생시킬 수 있습니다. 스레드 세이프한 코드는 이러한 오류를 최소화한다.

### 스레드에 안전한 구조

- **임계영역을 동기화 한다**
    - 동시에 여러개의 스레드가 임계영역을 접근하지 못하도록 락(Lock) 메카니즘을 사용한다
- **동기화 도구를 사용한다**
    - 세마포어, CAS, Atomic 변수, 동시성 자료구조 등의 동기화 도구들을 사용해서 스레드 안전성을 구현한다
      - 만약에 여러 스레드가 Reader라는 개체를 통해서 DB에서 특정 데이터를 조회하려고 한다. 이때 이 조회데는 데이터는 여러스레드가 동시에 중복해서 읽어오면 안되는 상황일때 `synchronized` 키워드를 통해 한번에 하나의 스레드만 접근해서 데이터를 읽어 올 수 있게 처리할 수 있다.
- **스레드의** **스택에 한정해서 상태를 관리한다**
    - 스레드마다 할당된 스택 메모리 내에서 상태를 관리함으로서 다른 스레드와 상태를 공유할 수 없도록 한다’
    - **지역변수 활용:** 스레드마다 독립적으로 스택에 저장되기 떄문에 스레드간에 공유될 수 없다.
    - **지역객체 참조 :** 변수와 다르게 객체는 스택에 저장되지 않고 힙 영역에 저장된다. 하지만 **지역적으로 생성된 객체가 해당 메서드에서 벗어나지 않고 사용 된다면 스레드는 자신만의 객체를 참조할 수 있게 되어 스레드에 안전하다.**
    - **멤버 변수 참조:** 멤버 변수 참조 역시 스레드 마다 객체를 생성하는 원리는 동일하다. 즉 스레드의 스택별로 객체가 생성되어 참조되도록 구현하면 된다.
- **ThreadLocal** **을 사용한다**
    - 스레드마다 가지고 있는 전용 저장소인 ThreadLocal 을 사용해서 상태를 관리함으로서 다른 스레드와 상태를 공유할 수 없도록 한다
- **불변 객체를 사용한다**
    - 객체의 상태를 변경할 수 없는 클래스를 사용하거나 클래스를 설계할 때 상태를 변경할 수 없도록(final 키워드) 만들어서 스레드에 안전하도록 한다
- **고립(Isolation)**
    - 스레드들이 서로 영향을 주지 않도록 데이터를 고립시킵니다.

# 동기화 기법

## Mutual Exclusion (상호 배제)

상호 배제(Mutual Exclusion)는 멀티스레딩 환경에서 중요한 동시성 제어 개념이다. 이는 **한 시점에 단 하나의 스레드만이 특정한 자원이나 중요한 코드 섹션(임계 구역)에 접근**할 수 있도록 보장하는 것을 말한다.  

상호 배제의 목적은 여러 스레드가 동시에 데이터를 변경하려 할 때 발생하는 레이스 컨디션과 같은 문제를 방지하는 데 있다.

스레드가 임계영역에서 Mutex 객체의 **플래그를 소유하고 있으면(락 획득) 다른 스레드가 액세스할 수 없으며**해당 임계영역에 액세스하려고 시도하는 모든 스레드는 차단되고 **Mutex 객체 플래그가 해제된 경우(락 해제)에만 액세스**할 수 있다.   
  
이 메커니즘은 Mutex 락을 가진 오직 한개의 스레드만이 임계영역에 진입할 수 있으며 **락을 획득한 스레드만이 락을 해제 할 수 있다.**
  
### 즉, 뮤텍스는 락과 락해제를 통해 자원을 보호하는 락체계 동기화 도구이다.
### **상호 배제 구현 방법**

1. **Synchronized 키워드**
    - 자바에서 **`synchronized`** 키워드를 사용하여 메서드나 코드 블록을 동기화합니다.
    - **`synchronized`** 블록이나 메서드에 들어가는 스레드는 락(lock)을 획득하고, 블록을 빠져나올 때 락을 해제합니다.
2. **Lock 인터페이스**
    - **`java.util.concurrent.locks`** 패키지의 **`Lock`** 인터페이스를 사용하여 더 세밀한 제어가 가능합니다.
    - **`ReentrantLock`** 클래스는 재진입 가능한 락을 제공합니다.
3. **Semaphore**
    - 세마포어(Semaphore)는 상호 배제를 위한 또 다른 방법입니다.
    - 세마포어는 제한된 수의 허가(permit)를 가지며, 스레드는 허가를 획득해야만 임계 구역에 진입할 수 있습니다.

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SharedResource {
    private final Lock lock = new ReentrantLock();

    public void criticalSection() {
        lock.lock(); // 상호 배제 시작

        try {
            // 임계 구역: 공유 자원에 대한 연산 수행
        } finally {
            lock.unlock(); // 상호 배제 종료
        }
    }
}
```

### **상호 배제의 특징**

1. **임계 구역 보호**: 상호 배제는 임계 구역(공유 자원을 사용하는 코드 영역)을 보호 한다. 한 스레드가 임계 구역에 진입하면, 다른 스레드는 그 임계 구역에 진입할 수 없다.
2. **스레드 동기화**: 상호 배제는 스레드 간의 동기화를 제공한다. 이를 통해 데이터의 일관성과 무결성을 유지할 수 있다.

### 문제점

### **1. 데드락 (Deadlock)**

- **정의**: 두 개 이상의 스레드가 서로 다른 스레드가 보유한 뮤텍스의 해제를 기다리는 상태에 빠지면서, 모든 스레드가 영원히 대기 상태에 빠지는 현상입니다.
- **발생 조건**: 상호 배제, 점유 대기, 비선점, 순환 대기의 네 가지 조건이 모두 충족될 때 발생합니다.
- **예방**: 데드락을 예방하기 위해 자원 할당 순서를 고정하거나, 자원 요청 시 다른 모든 락을 해제하는 등의 방법을 사용할 수 있습니다.

### **2. 라이브락 (Livelock)**

- **정의**: 두 개 이상의 스레드가 서로의 작업을 완료하기 위해 반복적으로 상대방에게 자원을 양보하는 상태에 빠져, 실제로는 아무런 진행도 이루어지지 않는 상황입니다.
- **해결**: 라이브락을 해결하기 위해서는 스레드 간의 자원 양보 메커니즘을 잘 설계하여, 스레드가 무한히 자원을 양보하지 않도록 해야 합니다.

### **3. 스타베이션 (Starvation)**

- **정의**: 한 스레드가 뮤텍스를 획득하는 데 너무 오랜 시간을 기다려야 하는 상황입니다. 이는 우선순위가 낮은 스레드가 항상 우선순위가 높은 스레드에 의해 밀려나는 경우 발생할 수 있습니다.
- **해결**: 우선순위를 조정하거나, 라운드 로빈 스케줄링 같은 공평한 자원 할당 방식을 사용하여 스타베이션을 방지할 수 있습니다.

### **4. 우선순위 역전**
- **정의**: 우선순위 역전은 높은 우선순위를 가진 스레드가 낮은 우선 순위를 가진 스레드가 보유한 락을 기다리는 동안 블록되는 현상으로, 높은 우선 순위를 가진 스레드의 작업이 지연될 수 있다.
- **해결**: 우선 순위 상속으로 해결

### **5. 성능 저하**

- **문제**: 뮤텍스를 사용한 동기화는 종종 성능 저하를 초래할 수 있습니다. 특히, 임계 구역이 긴 경우나 높은 동시성을 요구하는 애플리케이션에서 이 문제가 두드러집니다.
- **해결**: 락의 범위를 최소화하거나, 락이 필요 없는 영역에서는 락을 사용하지 않는 방식으로 성능을 최적화할 수 있습니다.

### **6. 복잡성 증가**

- **문제**: 뮤텍스를 사용한 동기화는 코드의 복잡성을 증가시킵니다. 올바른 락 관리는 프로그램의 로직을 이해하기 어렵게 만들 수 있습니다.
- **해결**: 코드를 단순하게 유지하고, 락을 사용할 때는 명확한 규칙과 패턴을 따르도록 합니다.

## **Semaphore** (세마포어)

세마포어(Semaphore)는 멀티스레딩 프로그래밍에서 동시성을 제어하는 데 사용되는 중요한 동기화 메커니즘이다. 세마포어는 공유 자원에 대한 접근을 제한하는 데 사용되며, 특히 여러 자원에 대한 접근을 제어할 때 유용하다.  
  
특정 신호에 의해 공유자원의 접근을 제어하고 보호하는 `신호체계 동기화 도구`이다.

### **세마포어의 기본 개념**

세마포어는 기본적으로 카운터로, 이 카운터는 동시에 자원에 접근할 수 있는 스레드의 수를 나타낸다.

- **카운터 값**:
    - 카운터 값이 0보다 크면, 스레드는 자원을 사용할 수 있으며, 카운터는 감소합니다.
    - 카운터 값이 0이면, 모든 자원이 사용 중이며, 추가적인 스레드는 자원이 해제될 때까지 대기해야 합니다.
- **정수형 변수 S**
- **P 연산(Acquire, Wait)**: 자원을 요청할 때 수행되며, 세마포어의 카운터를 감소시킵니다.
  - 진입 여부를 결정하는 연산(Wait 연산)
- **V 연산(Release, Signal)**: 자원을 해제할 때 수행되며, 세마포어의 카운터를 증가시킵니다.
  - 대기중인 프로세스를 깨우는 연산으로 시그널 연산


```jsx
class Semaphore {
    constructor(max) {
        this.queue = [];
        this.count = max;
    }

    async acquire() {
        if (this.count > 0) {
            this.count--;
        } else {
            // 카운트가 0이면, 큐에 프로미스 추가
            await new Promise(resolve => this.queue.push(resolve));
        }
    }

    release() {
        this.count++;
        if (this.queue.length > 0) {
            // 큐에서 대기 중인 작업을 깨움
            const resolve = this.queue.shift();
            resolve();
        }
    }
}

// 사용 예제
const semaphore = new Semaphore(2); // 동시에 2개의 작업만 허용

async function runTask(taskName) {
    await semaphore.acquire();

    console.log(`Running task: ${taskName}`);
    // 여기에 작업 수행 코드를 넣습니다.

    semaphore.release();
}

// 여러 작업 실행
runTask("Task 1");
runTask("Task 2");
runTask("Task 3");
```

이 코드에서 **`Semaphore`** 클래스는 **`acquire`** 메서드를 통해 세마포어를 획득하고, **`release`** 메서드를 통해 세마포어를 해제한다. **`acquire`** 메서드는 세마포어의 카운트가 0이 될 때까지 작업을 대기시키고, **`release`** 메서드는 카운트를 증가시키고 대기 중인 작업을 깨웁니다.  

세마포어는 정수형 변수 **S** 와 **P**(Proberen: try), **V**(Verhogen: increment)의 두 가지 원자적 함수로 구성된 신호전달 메커니즘 동기화 도구이다. P 는 임계 영역을 사용하려는 스레드의 진입 여부를 결정하는 연산으로 Wait 연산이라고도 하고 V 는 대기 중인 프로세스를 깨우는 신호(Wake-up)로 Signal 연산이라고 한다.  
  
스레드가 임계영역에 진입하지 못할 경우 자발적으로 '대기(BLOCK)'상태에 들어가고 임계영역을 빠져나오는 스레드가 대기상태의 스레드를 실행대기상태로 깨워준다. 자바에서는 java.util.concurrent 패키지에 세마포어 구현체를 포함하고 있기 때문에 직접 세마포어를 구현할 필요는 없다.

![Untitled.png](src%2Fresources%2Fstatic%2Fimg%2FUntitled.png)

- *신호기 팔이 경사각이 수평이면 정지한다*
- *신호기 팔의 경사각이 아래로 내려오면 통과한다*
- *기차는 신호에 따라 임계영역(공유자원)인 철도를 통과할 수 있다*  

### **자바에서의 세마포어 사용 예제**

자바 **`java.util.concurrent`** 패키지에는 **`Semaphore`** 클래스가 포함되어 있으며, 다음과 같이 사용할 수 있다.

```java

import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    private final Semaphore semaphore = new Semaphore(5); // 5개의 자원에 대한 세마포어

    public void accessResource() {
        try {
            semaphore.acquire(); // 자원 접근을 위해 세마포어 획득
            // 자원을 사용하는 코드
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release(); // 자원 사용 완료 후 세마포어 해제
        }
    }
}

```

이 예제에서 **`Semaphore`** 객체는 5개의 허가(permit)를 가지며, 동시에 최대 5개의 스레드가 **`accessResource`** 메서드에 접근할 수 있습니다. 스레드가 자원 사용을 완료하면 **`release`** 메서드를 호출하여 세마포어를 해제합니다.

### **정리**  
| 구분 | S 연산 | P 연산 (Wait 연산) | V 연산 (Signal 연산) |
|------|---------|---------------------|----------------------|
| 의미 | 정수형 변수 | S가 1 감소 (S--) | S가 1 증가 (S++) |
| 설명 | 공유 자원의 개수를 표시하거나 개수 만큼 스레드들의 접근이 허용된다 | 스택이가 비어 구역에 진입하려고 할 때 사용되며 어떤 스레드들의 접근을 1 감소시킨다 | 스택이가 영역 구역에서 빠져나올 때 사용되며 어떤 스레드들의 접근을 1 증가시킨다 |
| 특기사항 | - S가 0보다 크면 공유자원의 접근이 허용되며 S가 0 이면 공유자원의 접근이 거부된다 | - 커널 세마포어의 P, V 함수의 S 연산은 언제 스테드 간에 상호배제 되지 않는 일관성 실형이 보장되어야 한다 |


### **세마포어의 종류**

1. **바이너리 세마포어 (Binary Semaphore)**:
    - 카운터 값이 0 또는 1만을 가집니다.
    - 뮤텍스와 유사하게 동작하여, 한 번에 하나의 스레드만이 임계 영역에 진입할 수 있습니다.
    - 한 스레드만이 세마포어를 획득할 수 있기 때문에 그 외 다른 모든 스레드가 acquired()를 호출하게 되면 해당 스레드가 세마포어를 해제하기 전까지 블록된다
    - 뮤텍스와 세마포어는 기능적으로 유사하지만, 주요 차이점이 있다. 뮤텍스는 락을 획득하고 해제할 때 같은 스레드가 작업을 수행해야 한다. 반면, 세마포어는 한 스레드가 락을 획득하고 다른 스레드가 락을 해제할 수 있어, 공유 자원에 대한 접근 제어가 좀 더 유연하다.
2. **카운팅 세마포어 (Counting Semaphore)**:
    - 카운터 값이 양의 정수를 가질 수 있습니다.
    - 여러 자원에 대한 접근을 제어하는 데 사용됩니다.
    - 카운팅 세마 포어는 카운트 변수를 설정해서 스레드가 공유할 수 있는 자원의 최대치를 한정해서 운용하는 방식으로 자원 풀(pool)이나 컬렉션의 크기에 제한을 두고자 할 때 유용하다
        - DB Connection 개수 제한, 파일 다운로드 동시 실행 제한 등..
    - 락을 획득한 스레드와 락을 해제하는 스레드는 다를 수 있으며 스레드 간 락과 락해제를 위한 신호를 전달함으로 동기화를 구현한다
  
### 사용하는 곳
스레드 풀이나 DB 커넥션과 같이 특정 자원에 대한 동시 접근 횟수를 제한할 때 사용한다.

### Semaphore 구조

1. **Semaphore(int permits)**
    - 지정된 수의 허가(permits)를 가진 세마포어를 생성합니다.
    - 예: `new Semaphore(5);`는 동시에 5개의 허가를 가진 세마포어를 생성합니다.
2. **Semaphore(int permits, boolean fair)**
    - 지정된 수의 허가와 공정성 설정을 가진 세마포어를 생성합니다.
    - `fair`**가 `true`일 경우, 세마포어는 대기 중인 스레드들에게 공정하게 허가를 부여합니다.
    > 공정성 비공정성  
    > 공정성(fairness)과 비공정성(unfairness)은 컴퓨팅에서 자원에 대한 접근을 제어할 때 사용되는 개념입니다. 여기서 '자원'이란 CPU 시간, 메모리 공간, 데이터베이스 연결 등이 될 수 있습니다.  
    >   
    > **공정성이란** 모든 요청, 프로세스 또는 스레드가 자원에 대한 접근을 공평하게 받는다는 원칙을 말합니다. 즉, 어떤 프로세스도 무기한으로 기다리게 되지 않으며, 결국은 자원에 접근할 기회를 얻게 됩니다. 예를 들어, 운영체제가 CPU 접근을 관리할 때 각 프로세스가 동일한 시간 동안 CPU를 사용할 수 있도록 스케줄링을 하는 것이 공정성에 해당합니다  
    >   
    > **비공정성**은 특정 프로세스 또는 스레드가 다른 것들보다 자원에 더 자주 또는 더 오래 접근할 수 있게 되어, 다른 프로세스가 공정한 기회를 받지 못하는 상황을 말합니다. 이는 '기아 상태(starvation)'로 이어질 수 있으며, 어떤 프로세스가 자원을 필요로 하더라도 영원히 대기 상태에 머물게 되는 경우를 의미합니다.

3. **void acquire()**
    - 하나의 허가를 획득합니다.
    - 사용 가능한 허가가 없으면, 현재 스레드는 사용 가능해질 때까지 대기합니다.
4. **void acquire(int permits)**
    - 지정된 수의 허가를 획득합니다.
    - 필요한 만큼의 허가가 사용 가능할 때까지 대기합니다.
5. **void release()**
    - 하나의 허가를 해제합니다.
    - 대기 중인 스레드들 중 하나가 허가를 획득할 수 있게 됩니다.
6. **void release(int permits)**
    - 지정된 수의 허가를 해제합니다.
    - 대기 중인 스레드들이 허가를 획득할 수 있게 됩니다.
7. **int availablePermits()**
    - 현재 사용 가능한 허가의 수를 반환합니다.
8. **boolean tryAcquire()**
    - 사용 가능한 허가가 있으면 즉시 허가를 획득하고 `true`를 반환합니다.
    - 사용 가능한 허가가 없으면 즉시 `false`를 반환합니다.
9. **boolean tryAcquire(long timeout, TimeUnit unit)**
    - 지정된 시간 동안 허가를 획득하려고 시도합니다.
    - 허가를 획득하면 `true`를, 시간이 초과되면 `false`를 반환합니다.
10. **boolean tryAcquire(int permits)**
    - 지정된 수의 허가를 즉시 획득하려고 시도합니다.
    - 즉시 획득할 수 있으면 **`true`**, 그렇지 않으면 `false`를 반환합니다.
11. **boolean tryAcquire(int permits, long timeout, TimeUnit unit)**
    - 지정된 시간 동안 지정된 수의 허가를 획득하려고 시도합니다.
    - 허가를 획득하면 **`true`**, 시간 초과 시 `false`를 반환합니다.
12. **void drainPermits()**
    - 현재 사용 가능한 모든 허가를 제거합니다.
    - 이 메서드는 모든 사용 가능한 허가를 제거하고 그 수를 반환합니다.
13. **void acquireUninterruptibly()**
    - 세마포어로부터 허가를 얻는 동안 인터럽트에 걸리지 않는다.
  
## 뮤텍스 와 세마포어

- **동작방식**
  - 뮤텍스는 공유 자원에 대한 접근을 동시에 하나의 스레드만 가능하도록 보장한다. 즉, 뮤텍스는 상호 배제를 위한 동기화 기법이다
  - 세마포어는 카운딩 기법으로, 특정 개수의 스레드가 동시에 공유 자원에 접근할 수 있도록 제어한다.
  - 0 또는 1 의 값을 가진 이진 세마포어는 뮤텍스와 유사한 역할을 하며 계수 세마포어는 양수 값을 가지며, 해당 개수 만큼 스레드가 동시에 접근 허용한다.
- **소유권**
  - 뮤텍스는 소유권이 있어서 락을 획득한 스레드만 락을 해제할 수 있다. 즉, 락을 획득한 스레드가 락을 해제하지 않도록 다른 스레드는 해당 뮤텍스에 접근할 수 없다.
  - 세마포어는 소유권이 없으며, 특정 개수의 스레드가 동시에 접근을 허용하는 카운팅 기법으로 작동한다. 따라서 세마포어를 사용하는 스레드들이 모두 세마포어를 해제할 수 있다.
- **초기값**
  - 뮤텍스는 기본적으로 잠겨있는 상태로 시작한다. 한 스레드가 뮤텍스를 획득하여 자원에 접근하면 다른 스레드들은 해당 뮤텍스를 획득하기위해 블로킹된다.
- **사용 목적**
  - 뮤텍스는 주로 상호 배제를 위해 사용되며 하나의 자원에 하나의 스레드만 접근하도록 보장해야 하는 경우에 사용한다.
  - 세마포어는 주로 리소스의 한정적인 사용을 제어하는데 사용되며 특정 개수의 스레드만이 동시에 자원에 접근하도록 제한하고자 할때 사용한다.

## Monitor(모니터)

자바가 동기화를 지원하기 위해 사용하는 메커니즘은 모니터(Monitor)이며 **뮤텍스나 세마포어보다 더 고수준의 동기화 기법**이다. **모든 자바 객체는 기본적으로 모니터를 가지며** 여러 스레드가 객체의 임계 영역(critical section)에 진입하려고 할 때 JVM 은 모니터를 사용하여 스레드 간 동기화를 제공한다.  
  
자바의 모니터는 `상호 배제(Mutual Exclusion)`및 `협력(Cooperation)`이라는 두 가지 동기화 기능을 제공하고 있으며 이를 위해 `뮤텍스와 조건변수(Condition Variable)`를 사용한다.

즉, 모니터는 공유 자원에 대한 접근을 동기화하고, 스레드 간의 상호작용을 제어하는 데 된다. 모니터는 객체와 관련된 락(lock)과 조건 변수(condition variable)를 사용하여 구현된다.

### **모니터의 기본 구성 요소**

### 1. 상호 배제(Mutual Exclusion)

**락(Lock)**:
- 모든 자바 객체는 내장된 락을 갖고 있습니다.
- 이 락은 **`synchronized`** 메서드나 블록에 진입할 때 획득하고, 메서드나 블록을 빠져나올 때 자동으로 해제됩니다.

객체가 가지고 있는 모니터 Lock 을 통해 여러 스레드가 동시에 공유 자원에 접근하는 것을 막아 데이터의 일관성과 안전성을 보장하는 메커니즘이다. JVM 은 `'synchronized'` 키워드를 이용하여 뮤텍스 동기화를 `암묵적(내부적으로 처리)`으로 처리해 주고 있으며 synchronized 는 메서드나 코드 블록에 적용할 수 있다.

- **synchronized** (동기화)
    - synchronized 블록은 해당 객체의 모니터를 획득 할 수 있으며(상호 배제 기능을 사용할 수 있으며) 모니터를 획득한 스레드만이 임계영역에 접근 가능하고 그 외 다른 스레드들은 차단되어 대기 상태가 된다
    - synchronized 블록을 빠져 나오면 모니터 Lock 이 해제되고 대기 중인 다른 스레드 중 하나가 락을 얻고 임계 영역에 진입하여 작업을 수행하는 식으로 상호배제가 보장된다

### 2. 협력(Cooperation)

**조건 변수(Condition Variable)**:

- 자바에서는 객체의 내장된 락과 관련된 **`wait()`**, **`notify()`**, **`notifyAll()`** 메서드를 통해 조건 변수를 구현합니다.
- **`wait()`** 메서드는 `현재 스레드`를 `대기` 상태로 만들고 락을 해제합니다. 다른 스레드가 `notify()` 나 `notifyAll()`을 호출할 때까지 대기합니다.
  - 스레드가 특정 조건에 부합하지 않을 때 wait() 메서드를 호출하면 조건변수의 대기 셋(Wait Set)에 들어가 대기한다.
- **`notify()`** 메서드는 대기 중인 스레드 중 하나를 깨웁니다.
- **`notifyAll()`** 메서드는 모든 대기 중인 스레드를 깨웁니다.
  - 다른 스레드가 특정 조건을 만족해서 notify() 또는 notifyAll() 메서드를 호출하면 조건변수의 대기셋으로부터 스레드를 깨워 실행 시킨다.

협력은 모니터의 `Condition Variable (조건 변수)` 를 통해 **`스레드 간` 공동의 목표를 위해 상호협력**으로 데이터의 일관성과 안전성을 보장하는 동기화 메커니즘이다.  
  
조건변수를 통해 **스레드 간 대기와 통지**를 서로 조절하면서 **경쟁 조건(race condition)과 같은 문제를 방지**할 수 있다. 모니터 내부에는 여러개의 조건 변수를 가질 수 있지만 **자바의 모니터에는 오직 한 개의 조건 변수만 가질 수 있다.**

### 예시

```java
public class SharedResource {
    public synchronized void accessResource() {
        // 임계 구역: 공유 자원에 접근
    }

    public synchronized void modifyResource() {
        // 임계 구역: 공유 자원을 수정
        notifyAll(); // 대기 중인 스레드들에게 알림
    }

    public synchronized void waitForCondition() throws InterruptedException {
        while (/* 조건이 만족되지 않았을 경우 */) {
            wait(); // 조건이 만족될 때까지 대기
        }
        // 조건 만족 후의 작업 수행
    }
}
```

이 예제에서 **`synchronized`** 키워드는 메서드가 모니터 락을 획득하고 해제하는 것을 의미한다. **`wait()`**, **`notify()`**, **`notifyAll()`** 메서드는 해당 객체의 조건 변수를 사용하여 스레드 간의 상호작용을 관리한다.

### 모니터 대기 세트 구조

모니터는 상호배제와 협력을 통해 임계영역에 접근을 관리할 수 있다. 이때 **상호배제**에서 synchronized 키워드를 통해 모니터락을 획득하여 스레드를 대기하게 만들거나 **협력**의 조건변수를 통해서도 스레드를 대기 시킬 수 있다. 이렇듯 2가지 방법을 통해서 스레드를 대기 시킬 수 있으므로 이 대기하는 공간 역시 2가지가 존재한다.
  
모니터 대기 세트는 객체의 내장 락(lock)과 밀접하게 관련되어 있으며, 자바의 모니터 내부에는 `EntrySet(진입셋)` 과 `WaitSet(대기셋)` 이라는 **대기 자료 구조**가 있으며 이들은 멀티스레드 환경에서 스레드들 간의 상호작용을 조절하는 데 사용된다.

- **Entry** **Set**
    - Entry Set 은 **모니터의 Lock 을 획득하기 위해 대기 중인 스레드들을 모아 놓은 자료 구조**로서 스레드가 Lock 을 사용 중인 경우 그외 다른 스레드는 Entry Set 에 들어가게 된다
      - 즉 임계영역에 접근하기 위해서(락 획득) 대기하는 곳
    - Entry Set 에 있는 스레드들은 Lock 이 반납될 때까지 기다리며 락이 반납되면 Entry Set 중 하나의 스레드가 락을 획득하고 임계 영역으로 진입하게 된다.
- **Wait** **Set**
    - Wait Set 은 **모니터의 조건 변수(Condition variable)와 함께 사용하는 자료구조**이며 **스레드들이 특정한 조건이 만족할 때 까지 대기**하고 있는 장소이다
    - 스레드는 Wait Set 에 들어가 대기할 때 Lock 을 해제한다. 그리고 다른 스레드에 의해 깨어나게 되면 Entry Set 으로 이동해서 다시 Lock 을 획득 할 수 있다
    > 스레드는 Wait Set 에 들어가 대기할 때 Lock 을 해제?  
    > 만약 어떠한 스레드가 락을 가지고 Wait Set에 들어가게 되면 다른 스레드들은 영원히 락을 획득할 수가 없게 된다.  
    > 그렇기 때문에 Wait Set에 들어가는 스레드는 락을 반납하여 다른 스레드들이 임계영역에 접근할 수 있도록 한다.

### 조건 변수 종류

조건변수를 통해 상호 협력하고 있는 두 스레드가 `wait()` 과 `notify()` 메서드 실행 후에 하나의모니터를 두고 두 스레드 모두 소유가 가능한 상황이 발생 했을때 하나의 대기중인 스레드, 하나는 깨우는 스레드로서 어떤 스레드가 모니터를 먼저소유할 것인가에 따라 두 종류의 조건변수로 나눌 수 있다.  하나는 **Signal and Wait** , 다른 하나는 **Signal and Continue** 이다.

### **Signal and Wait**

현재 모니터를 소유하고 있는 스레드가 `wait()`을 실행하면 모니터 내부에서 자신을 일시 중단하고 Lock을 해제한 후 Wait Set에 들어간다.깨우는 스레드 notify() 또는 notifyAll() 메서드를 호출하면 Wait Set에 대기 스레드 중 하나 또는 모든 스레드를 깨우고 **깨우는 스레드는 Lock을 해제하고 대기**한다. 이때 대기에서 깨어난 스레드가 Lock 을 획득한 후 모든 작업을 마치고 Lock 을 해제하면 깨운 스레드가 Lock을 획득한 후 계속 작업을 진행한다.

대기 스레드와 깨운 스레드 사이에 다른 스레드가 모니터를 소유할 수 없도록 원시적 실행이 보장되어야 한다.

### **Signal and Continue(자바 에서 사용하는 방식)**

현재 모니터를 소유하고 있는 스레드가 `wait()`을 실행하면 모니터 내부에서 자신을 일시 중단하고 Lock을 해제한 후 Wait Set에 들어간다. 깨우는 스레드가 `notify()` or `notifyAll()` 명령을 실행하면 Wait Set 에 있는 대기 스레드 중 하나 또는 모든 스레드를 깨우고 이때 일어난 스레드들은 Entry Set 으로 이동한다. **깨우는 스레드는 Lock을 계속 유지**하면서 모든 작업을 완료하고 **Lock을 해제하면 Eentry Set에 대기하고 있는 모든 스레드가 Lock을 획득하기 위해 경쟁**한다. 자바에서는 이 조건 변수 형식을 취하고 있다.

### 작동 구조

### **1. 스레드가 동기화된 메서드나 블록에 접근**

- **동기화 시도**: 스레드가 **`synchronized`** 메서드나 블록에 접근을 시도합니다. 이 동기화된 영역은 특정 객체(모니터)에 연결되어 있으며, 모든 자바 객체는 내장된 락을 가지고 있습니다.
- **락 획득**: 스레드는 해당 객체의 락을 획득하려고 시도합니다. 락이 이미 다른 스레드에 의해 보유되고 있다면, 해당 스레드는 Entry Set에 들어가 대기합니다.

### **2. Entry Set**

- **락 대기**: Entry Set은 해당 객체의 락을 기다리는 스레드들의 집합입니다. 락이 해제되면, Entry Set에 있는 스레드들 중 하나가 락을 획득하고 동기화된 영역에 진입합니다.

### **3. 동기화된 영역에서의 작업**

- **임계 구역 실행**: 락을 획득한 스레드는 동기화된 영역(임계 구역)에서 작업을 수행합니다. 여기서 공유 자원에 대한 접근이 이루어집니다.

### **4. 조건 대기(Wait Set)**

- **조건 확인**: 스레드가 특정 조건이 만족되지 않았다고 판단하면, **`wait()`** 메서드를 호출하여 대기 상태로 전환됩니다.
- **Wait Set으로 이동**: **`wait()`** 메서드 호출 시, 스레드는 해당 객체의 락을 해제하고 Wait Set으로 이동합니다. Wait Set은 **`wait()`** 메서드를 호출하여 대기하는 스레드들의 집합입니다.

### **5. 조건의 충족 및 알림**

- **조건 변경**: 다른 스레드가 조건을 변경할 수 있으며, 이후 **`notify()`** 또는 **`notifyAll()`** 메서드를 호출하여 Wait Set의 스레드들을 깨울 수 있습니다.
- **스레드 깨우기**: **`notify()`** 메서드는 Wait Set에서 대기 중인 스레드 중 하나를 임의로 깨우고, **`notifyAll()`** 메서드는 모든 대기 중인 스레드를 깨웁니다.

### **6. 락 재획득 및 작업 재개**

- **락 경쟁**: **`notify()`**/`notifyAll()`에 의해 깨어난 스레드들은 다시 객체의 락을 획득하기 위해 경쟁합니다(Entry Set으로 이동). 락을 획득한 스레드는 **`wait()`** 호출 이후의 코드부터 실행을 계속합니다.

### **7. 동기화된 영역 탈출 및 락 해제**

- **작업 완료**: 스레드가 동기화된 영역의 작업을 완료하면, 락을 자동으로 해제하고 동기화된 영역을 빠져나옵니다.
- **다음 스레드의 진입**: 락이 해제되면, 다른 스레드가 락을 획득하여 동기화된 영역에 진입할 수 있습니다.

```java
public class Example {
    public synchronized void synchronizedMethod() {
        while (/* 조건이 만족되지 않음 */) {
            wait(); // 현재 스레드는 Wait Set으로 이동
        }
        // 조건이 만족되면 작업 수행
    }

    public synchronized void changeCondition() {
        // 조건 변경
        notifyAll(); // Wait Set에 있는 모든 스레드를 깨움
    }
}
```

# SpinLock & Busy Waiting

## SpinLock

스핀락(SpinLock)은 뮤텍스나 세마포어와 같은 동기화 기법의 일종으로 스레드가 잠금을 얻기 위해 **반복적으로 잠금 상태를 확인하면서 기다리는 방식이**다. SpinLock을 사용하는 스레드는 잠금을 획득할 수 있을 때까지 계속해서 잠금 상태를 확인합니다.  
  
이는 CPU 사이클을 사용하는 비효율적인 방법일 수 있지만, 잠금을 기다리는 시간이 매우 짧을 경우에는 컨텍스트 스위칭을 피하기 위한 효율적인 방법이 될 수 있다.

### 작동 방식

SpinLock은 스레드가 잠금을 획득할 수 있을 때까지 반복적으로 잠금 상태를 확인하고 기다리는 동기화 메커니즘이다.

1. **잠금 검사**: 스레드는 잠금 상태를 반복적으로 검사합니다.
2. **잠금 획득 시도**: 잠금이 해제된 것을 확인하면, 잠금을 획득하려고 시도합니다.
3. **임계 영역 진입**: 잠금을 획득하면 임계 영역(공유 자원에 대한 작업)에 진입합니다.
4. **잠금 해제**: 작업을 마치면 잠금을 해제합니다.

```java
import java.util.concurrent.atomic.AtomicBoolean;

class SpinLock {
    private final AtomicBoolean lock = new AtomicBoolean(false);

    public void lock() {
        while (true) {
            if (!lock.getAndSet(true)) {
                return;
            }
            // 잠금을 획득할 때까지 계속 반복
        }
    }

    public void unlock() {
        lock.set(false);
    }
}
```

### **Busy Waiting**

Busy Waiting은 **프로세스 또는 스레드가 특정 조건이 충족될 때까지 계속해서 조건을 평가**하는 것을 말합니다. SpinLock은 Busy Waiting의 한 형태이다.  
  
조건이 만족될 때까지 프로세스 또는 스레드는 계속해서 조건을 확인합니다. 이 과정에서 CPU는 유용한 작업을 수행하지 않고,무한 반복 루프를 돌면서 조건을 체크하는 데에만 리소스를 사용합니다.

### 동작방식

Busy Waiting은 스레드가 특정 조건이 만족될 때까지 기다리는 동작이다.

1. **조건 검사**: 스레드는 특정 조건을 반복적으로 검사합니다.
2. **조건 충족 대기**: 조건이 만족될 때까지 계속해서 검사합니다.
3. **작업 수행**: 조건이 충족되면 필요한 작업을 수행합니다.

```java
class BusyWaitingExample {
    private volatile boolean conditionMet = false;

    public void waitForCondition() {
        while (!conditionMet) {
            // 조건이 만족될 때까지 계속 기다림
        }
        // 조건이 만족되면 필요한 작업 수행
    }

    public void setConditionMet() {
        conditionMet = true;
    }
}
```

### 스핀락의 장단점

### **장점**

1. **컨텍스트 스위칭 감소**: 스핀락은 스레드가 잠금을 획득할 때까지 대기 상태로 들어가지 않고, 대신 CPU 사이클을 사용하며 계속해서 잠금 상태를 확인합니다. 이로 인해 잠금을 얻기 위한 컨텍스트 스위칭(context switching)이 발생하지 않아 오버헤드가 줄어듭니다.
2. **짧은 대기 시간에 유리**: 잠금 대기 시간이 매우 짧은 경우, 스핀락은 컨텍스트 스위칭으로 인한 오버헤드보다 더 효율적일 수 있습니다.
3. **반응 시간 개선**: 스핀락은 잠금을 획득하자마자 즉시 실행을 계속할 수 있어, 다른 동기화 메커니즘에 비해 더 빠른 반응 시간을 제공합니다.
  
블로킹 대기 없이 바로 공휴 자원에 접근하려고 시도하기 때문에, 컨텍스트 스위칭 하는 시간 보다 임계영역의 대기 시간이 더 짧을 떄 유리하다.

### **단점**

1. **CPU 자원 낭비**: 스핀락은 잠금을 획득할 때까지 계속 CPU 시간을 사용하여 잠금 상태를 확인합니다. 이는 잠금이 빨리 풀리지 않는 경우에 CPU 자원을 낭비할 수 있습니다.
2. **기아 상태(starvation) 발생 가능**: 하나의 스레드가 잠금을 오래 동안 보유하고 있으면, 다른 스레드들은 잠금을 획득하기 위해 무한정 대기하는 기아 상태에 빠질 수 있습니다.
3. **멀티프로세서 시스템에서만 효과적**: 스핀락은 멀티프로세서 또는 멀티코어 시스템에서만 효과적입니다. 단일 프로세서 시스템에서는 한 스레드가 CPU를 점유하고 있으면 다른 스레드는 실행될 수 없기 때문에 효율적이지 않습니다.
4. **우선순위 역전 문제**: 높은 우선순위의 스레드가 낮은 우선순위의 스레드가 보유한 잠금을 기다리는 경우, 우선순위 역전 문제가 발생할 수 있습니다.
  
공유자원에 대한 경쟁이 많은 경우, 또는 대기 시간이 긴 경우에는 비효율적이며 스레드들이 공유 자원에 대한 경쟁이 강하게 발생할 경우 스핀락을 사용하면 대기 시간이 더 길어질 수 있다.  

### 싱글코어 & 멀티코어

싱글코어에서 스핀락을 사용하면, 해당 스레드가 무한 루프를 돌면서 다른 스레드가 CPU를 점유할 기회를 주지 않기 때문에 싱글코어 환경에서는 일반적으로 busy waiting으로 인해 성능이 저하될 수 있으므로 멀티코어 환경에서 사용하는 것이 더 효율적이다.

스핀락은 멀티 코어 환경에 상관없이 대기 시간이 긴 경우나 공유 자원에 대한 경쟁이 많은 경우에는 다른 동기화 기법을 고려하는 것이 좋다 대부분의 경우, 스핀락보다는 뮤텍스(Mutex)나 세마포어(Semaphore) 등의 블로킹 기반의 동기화 기법을 사용하는 것이 더 적합할 수 있다.
  
## 자바 synchronized
자바에서 **`synchronized`** 키워드는 멀티스레딩 환경에서 동기화를 달성하기 위해 사용된다. 이 키워드는 한 시점에 하나의 스레드만이 특정 섹션의 코드에 접근하도록 보장하여, 데이터의 일관성과 스레드 안전성을 유지하는 데 도움이 된다.

자바는 단일 연산(임계 영역) 특성을 보장하기 위해 `synchronized` 키워드를 제공하고 있으며 synchronized 구문을 통해 모니터 영역을 동기화 할수 있다. synchronized 는 명시적으로 락을 구현하는 것이 아닌 **자바에 내장된 락**으로서 이를 **암묵적인 락(Intrinsic Lock)** 혹은 **모니터락 (Monitor Lock)** 이라고 한다.  
  
`synchronized` 은 동일한 모니터를 가진 객체에 대해 **오직 하나의 스레드만 임계영역에 접근할 수 있도록 보장**하며 모니터의 조건 변수를 통해 스레드간 협력으로 동기화를 보장해 준다. 우리가 앞서 확인했던 모니터의 두가지 기능을 `synchronized`라는 키워드 안에 포함 시켜버린 것이다.

synchronized 가 적용된 한 개의 메서드만 호출해도 **같은 모니터의 모든 synchronized 메서드까지 락에 잠기게 되어 락이 해제될 때 까지는 접근이 안되는 특징**을 가지고 있다. 락은스레드가 synchronized 블록에 들어가기 전에 자동 확보되며 **정상적이든 비정상적이든 예외가 발생해서든 해당 블록을 벗어날 때 자동으로 해제**된다.

> **명시적 락 과 암묵적 락
명시적 락**
> 명시적 락은 개발자가 명시적으로 락을 관리하는 방식입니다. 자바의 **`java.util.concurrent.locks`** 패키지에서 제공하는 `ReentrantLock`과 같은 클래스를 사용하여 구현합니다. 이러한 락을 사용할 때는 락을 획득하고 반드시 해제하는 책임이 개발자에게 있습니다.

> **암묵적 락 (Intrinsic Lock 또는 Monitor Lock)**
> 암묵적 락은 자바 객체에 내장된 락으로, **`synchronized`** 키워드를 사용하여 동기화를 구현합니다. **`synchronized`** 메서드나 블록을 사용할 때, 자바는 자동으로 관련 객체에 대한 락을 획득하고 해제합니다.
>

> **같은 모니터 라는 표현**
>
>
> **모니터란?**
>
> 모니터는 동시성 프로그래밍에서 사용되는 개념으로, 공유 리소스에 대한 안전한 접근을 제공하기 위한 메커니즘입니다. 자바에서 객체의 모니터는 다음 두 가지 주요 기능을 가집니다:
>
> 1. **상호 배제(Mutual Exclusion)**: 한 시점에 하나의 스레드만이 **`synchronized`** 블록이나 메서드에 접근할 수 있습니다.
> 2. **협력(Cooperation)**: **`wait()`**, **`notify()`**, **`notifyAll()`** 메서드를 통해 스레드 간 협력을 할 수 있습니다.
>
> ### **같은 모니터의 의미**
>
> "같은 모니터"라는 표현은 특정 객체의 모니터 락을 참조합니다. 예를 들어, 하나의 객체에 대해 여러 개의 **`synchronized`** 메서드가 있다면, 이 메서드들은 모두 "같은 모니터"를 사용합니다. 즉, 한 스레드가 해당 객체의 한 **`synchronized`** 메서드를 실행하고 있으면, 다른 스레드는 동일한 객체의 다른 **`synchronized`** 메서드에 접근할 수 없습니다.
>

### 동작 방식
모든 객체는 모니터를 가진다.  
예를 들어 `Myclass my = new Myclass();`
1. Myclass 클레스
2. Myclass 를 통해서 생성한 객체

위의 2가지는 서로 다른 모니터 객체를 가진다. 즉 클레스 자체에 대해서 또는 특정 클레스를 통해서 생성된 객체 이 2가지를 이용해서 모니터 역할을 할 수 있다.

- **객체 락(Object Lock)**: `synchronized`는 객체에 대한 락을 사용한다. 메서드 또는 블록이 `synchronized`로 표시되면, 해당 코드 섹션에 접근하기 위해서는 먼저 해당 객체의 락을 획득해야 한다.
- **메서드 동기화(Method Synchronization)**: 전체 메서드를 **`synchronized`**로 선언할 수 있습니다. 이 경우, 해당 메서드는 해당 객체의 락을 사용한다.
  동시성 문제를 한번에 편리하게 제어할 수 있는 장점이 있지만 메서드 내 코드의 세부적인 동기화 구조를 가지기 어렵고 메서드 영역 전체를 동기화 하기때문에 이 영역이 클 수록 성능 저하를 가져온다.

    ```java
    
    public synchronized void synchronizedMethod() {
        // 동기화된 메서드의 코드
    }

    ```
  
위의 메서드는 객체의 메서드이다. 자바에서 해당 객체를 가리키는 키워드는 `this`이다. 즉 이 메서드는 `this` 라는 모니터 객체를 가지고 있다.(`this` (생성된 객체)가 모니터의 역할을 한다.)
  
```java

      
    public static synchronized void staticSynchronizedMethod() {
        // 동기화된 메서드의 코드
    }
```  
static 의 키워드는 객체의 영역이 아닌 클레스에 속한 영역이다. 따리서 해당 메서드의 모니터 역할은 해당 클레스 그자체이다.


- **블록 동기화(Block Synchronization)**: 특정 코드 블록을 **`synchronized`** 블록으로 만들 수 있습니다. 이 경우, 블록에 지정된 객체의 락을 사용한다.
  메서드 동기화 방식에 비해 좀더 세부적으로 임계영역을 정해서 필요한 블록만 동기화 구조를 가질 수 있다. 영역이 메서드 동기화 방식보다 작고 효율적인 구성이 가능하기 때문에 성능 저하가 덜하다.

    ```java
    
    public void method() {
        synchronized (this) { // 객체 락
            // 동기화된 블록의 코드
        }
    }
    ```
    
```java
       public static void staticMethod() {
        synchronized (Myclass.class) { // 클레스 락
            // 동기화된 블록의 코드
        }
    }
```
  
이렇게 총 4개의 메서드가 있을때 첫번째와 세번째 메서드의 모니터가 동일하고 두번재와 네번째 메서드의 모니터가 같다.  
따라서 스레드1과 스레드2가 있을때 스레드1이 `synchronizedMethod` 첫번째 메서드에 스레드2번이 `staticSynchronizedMethod` 두번째 메서드에 접근했을때 과연 동시에 두 메서드에 접근이 가능할까??  

우리는 앞에서 배웠던 뮤텍스는 동시에 접근이 불가능하다. 이미 락을 획득한 스레드가 있으면 다른 스레드들은 대기해야 한다. 이때 그 기준은 동일한 뮤텍스 일때이다. 동일하게 모니터안에 뮤텍스가 있기때문에 두 메서드는 서로 다른 모니터를 가지고 있기때문에 동시에 서로다른 스레드가 접근이 가능하다.  
  
따라서 1번과 3번, 2번과 4번은 동시에 접근이 불가능하다.(동일한 모니터)
### **사용 시 고려 사항**

1. **데이터 일관성**: `synchronized`는 여러 스레드가 동시에 공유 데이터에 접근하는 것을 방지하여 데이터의 일관성을 유지
2. **성능 저하**: 동기화는 성능에 영향을 줄 수 있다. **`synchronized`** 블록이나 메서드에 스레드가 동시에 접근할 수 없기 때문에, 스레드들은 락을 기다리는 동안 대기해야 할 수 있다.
3. **데드락(Deadlock)**: 잘못된 **`synchronized`** 사용은 데드락을 일으킬 수 있다. 예를 들어, 두 스레드가 서로 다른 두 객체의 락을 기다리고 있을 경우, 무한 대기 상태에 빠질 수 있다.
4. **객체 레벨 락**: **`synchronized`** 메서드는 **객체 레벨의 락을 사용**합니다. 따라서, **다른 스레드가 동일한 객체**의 다른 **`synchronized`** 메서드에 접근할 수 없습니다.  
  
### 정리
* 메서드 동기화 방식 - synchronized method
  * 메소드 전체가 임계 영역(critical section)이 된다. 즉, 메소드 내의 모든 코드가 동기화 된다
  *  동시성 문제를 한번에 편리하게 제어할 수 있는 장점은 있으나 메서드 내 코드의 세부적인 동기화 구조를 가지기 어렵다
  *  메서드 전체를 동기화하기 때문에 동기화 영역이 클 경우 성능저하를 가져온다
  *  인스턴스 메서드 동기화 와 정적 메서드 동기화 방식이 있다  
* 블록 동기화 방식 - synchronized block
  * 특정 블록을 정해서 임계 영역(critical section)을 구성한다. 즉 블록 내의 코드만 동기화 된다
  *  메서드 동기화 방식에 비해 좀 더 세부적으로 임계영역을 정해서 필요한 블록만 동기화 구조를 가질 수 있다
  *  메서드 전체를 동기화 하는 것보다 동기화 영역이 작고 효율적인 구성이 가능하기 때문에 성능 저하가 덜하다
  *  인스턴스 블록 동기화 와 정적 블록 동기화 방식이 있다  
  
#### 스레드 간 객체의 메서드를 동기화하기 위해서는 스레드는 같은 객체의 모니터를 참조하고 있어야한다.
  
# 메소드 동기화

## synchronized method , static synchronized method
### **Synchronized Method**

**인스턴스 단위로 모니터가 동작**하며 동일한 인스턴스 안에서 **synchronized 가 적용된 곳은 하나의 락을 공유**한다. 인스턴스가 여러개일 경우 인스턴스별로 모니터 객체를 가지므로 스레드는 모니터 별로 락을 획득해서 동기화 영역에 진입하고 빠져 나올 때 락을 해제 할 수 있다.

- **락 객체**: 인스턴스 메서드에 **`synchronized`** 키워드를 사용하면, 메서드는 해당 객체의 인스턴스 락을 사용합니다.
- **동작 방식**: 스레드가 이 **`synchronized`** 인스턴스 메서드를 호출할 때마다 **해당 객체의 락**을 획득해야 합니다. 동시에 하나의 스레드만이 같은 객체의 다른 **`synchronized`** 인스턴스 메서드에 접근할 수 있습니다.
- **사용 예시**:

    ```java
    public class MyClass {
        public synchronized void syncMethod() {
            // 임계 영역
        }
    }
    
    ```

  이 경우, `MyClass`의 인스턴스마다 각각의 락이 존재합니다.


## **Static Synchronized Method**

클래스 단위로 모니터가 동작하며 synchronized 가 적용된 곳은 하나의 락을 공유한다. `인스턴스와는 별개의 모니터를 가지고` **임계 영역을 동기화** 하기 때문에 인스턴스 단위로 메서드를 호출할지라도 락은 클래스 단위로 스레드간 공유된다. **클래스는 메모리에 오직 하나만 존재**하므로 하나의 모니터를 공유해서 동기화 하고자 할 때 사용 할 수 있다.

- **락 객체**: 클래스 메서드에 **`synchronized`** 키워드를 사용하면, 메서드는 해당 클래스의 Class 객체의 락을 사용합니다.
- **동작 방식**: 클래스의 모든 **`static synchronized`** 메서드는 동일한 Class 객체의 락을 공유합니다. 따라서, 한 스레드가 어떤 클래스의 **`static synchronized`** 메서드를 실행하고 있으면, 다른 스레드는 같은 클래스의 다른 **`static synchronized`** 메서드에 접근할 수 없습니다.
- **사용 예시**:

    ```java
    
    public class MyClass {
        public static synchronized void staticSyncMethod() {
            // 임계 영역
        }
    }
    
    ```

### **주요 차이점**

- **락의 범위**: **`Synchronized`** 메서드는 객체 인스턴스 레벨의 락을 사용하는 반면, **`Static synchronized`** 메서드는 클래스 레벨의 락을 사용합니다.
- **영향 범위**: 인스턴스 메서드의 동기화는 동일 객체 인스턴스 내에서만 영향을 미치지만, **`Static synchronized`** 메서드의 동기화는 해당 클래스의 모든 인스턴스에 영향을 미칩니다.

### **동시 사용 시의 동작:** **인스턴스** **메소드 동기화 (synchronized method)  + 정적** **메소드 동기화 (static synchronized method)**

**`Synchronized`** 인스턴스 메소드와 **`static synchronized`** 메소드가 동시에 존재할 때, 이들은 **서로 다른 락**을 사용합니다. 이는 중요한 점으로, 인스턴스 메소드와 정적 메소드 사이의 동기화는 서로 독립적이다. **따라서 모니터가 섞여 있기 때문에 동기화가 의도한대로 정확하게 동작하는지 주의가 필요**하다.

1. **인스턴스 메소드 동기화**: **`synchronized`** 인스턴스 메소드는 해당 객체의 인트린직 락(intrinsic lock)을 사용합니다. 이 락은 객체 인스턴스마다 고유합니다.
2. **정적 메소드 동기화**: **`static synchronized`** 메소드는 클래스의 Class 객체의 락을 사용합니다. 이 락은 클래스 전체에 대한 락으로, 모든 인스턴스에 공통적입니다.
3. **독립적인 락**: 인스턴스 메소드와 정적 메소드의 락은 서로 다르기 때문에, 한 스레드가 인스턴스 메소드에 있는 락을 획득한 상태에서도 다른 스레드는 해당 클래스의 정적 메소드에 있는 락을 획득할 수 있습니다.

### **예시**

```java

public class Example {
    // 인스턴스 메소드 동기화
    public synchronized void instanceMethod() {
        // 임계 영역 코드
    }

    // 정적 메소드 동기화
    public static synchronized void staticMethod() {
        // 임계 영역 코드
    }

    // 사용 예시
    public static void main(String[] args) {
        Example ex = new Example();
        ex.instanceMethod(); // 이 메소드는 객체 ex의 락을 사용합니다.
    
        Example.staticMethod(); // 이 메소드는 Example 클래스의 Class 객체의 락을 사용합니다
    }
}

```

- 한 스레드가 `instanceMethod()`를 실행하고 있는 동안, 다른 스레드는 여전히 `staticMethod()`를 실행할 수 있습니다. 이는 두 메소드가 서로 다른 락을 사용하기 때문이다.
- 이러한 독립성은 동시성을 증가시킬 수 있지만, 동기화할 자원이 인스턴스와 클래스 레벨에서 서로 영향을 미칠 수 있다면 주의가 필요하다. 예를 들어, 인스턴스 메소드와 정적 메소드가 동일한 외부 자원에 접근한다면, 별도의 동기화 메커니즘이 필요할 수 있다.

# 블록 동기화

## synchronized block , static synchronized block

### synchronized block

**인스턴스 단위로 모니터가 동작**하며 synchronized 가 적용된 곳은 하나의 락을 공유한다. 모든 인스턴스가 모니터를 가지기 때문에 모니터를 여러 인스턴스로 구분해서 동기화를 구성할 수 있다. 클래스의 인스턴스가 여러개일 경우 인스턴스별로 모니터 객체를 가지며 스레드는 모니터 별로 락을 획득해서 synchronized 영역을 진입하고 빠져 나올 때 락을 해제 할 수 있다.

- **특정 객체의 락 사용**: **`synchronized`** 블록은 괄호 안에 지정된 객체의 락을 사용합니다.
- **유연성**: 메소드 전체를 동기화하는 것이 아니라 필요한 부분만 동기화할 수 있어 유연합니다.
- **예시**:

    ```java
    
    public class Example {
        private Object lock = new Object();
    
        public void method() {
            synchronized (lock) {
                // 동기화된 블록
            }
        }
          public void method2() {
            synchronized (this) {
                // 동기화된 블록
            }
        }
    }
    
    ```


### static synchronized block

클래스 단위로 모니터가 동작하며 synchronized 가 적용된 곳은 하나의 락을 공유한다. 모든 클래스가 모니터를 가지기 때문에 모니터를 여러 클래스로 구분해서 동기화를 구성할 수 있다. 클래스 모니터가 여러개일 경우 스레드는 모니터 별로 락을 획득해서 synchronized 영역을 진입하고 빠져 나올 때 락을 해제 할 수 있다.

- **클래스의 Class 객체의 락 사용**: **`synchronized`** 블록은 **`ClassName.class`**를 이용하여 클래스 레벨의 락을 사용합니다.
- **클래스 레벨 동기화**: 클래스의 모든 인스턴스에 걸쳐 동기화를 제공합니다.
- **예시**:

    ```java
    public class Example {
        public static void staticMethod() {
            synchronized (Example.class) {
                // 동기화된 정적 블록
            }
        }
  
          public static void staticMethod2() {
            synchronized (YourClass.class) {
                // 동기화된 정적 블록
            }
        }
    }
    
    ```


### **주요 차이점**

- **락의 범위**: **`Synchronized block`**은 지정된 객체의 락을 사용하는 반면, **`Static synchronized block`**은 클래스의 Class 객체의 락을 사용한다.
- **적용 범위**: 인스턴스 블록은 해당 객체의 인스턴스에만 영향을 미치는 반면, 정적 블록은 클래스 레벨에서 동기화를 수행한다.

### 인스턴스 블록 동기화 (synchronized block) + 정적 블록 동기화 (static synchronized block)
```java
public class Myclass {
    private Object lock = new Object();
    
    public synchronized void synMethod1() { //this
        // 동기화 영역
    }

    public static synchronized void synMethod2() {//Myclass
        // 동기화 영역
    }

    public void synMethod3() { //lock
        synchronized (lock) {
            // 동기화 영역    
        }
        
    }

    public void synMethod4() {// Myclass
        synchronized (this) {
            // 동기화 영역    
        }

    }


    public void synMethod5() {
        synchronized (Myclass.class) {// Myclass
            // 동기화 영역    
        }

    }

    public void synMethod() {
        synchronized (DifferentClass.class) {// DifferentClass
            // 동기화 영역    
        }

    }
}  

```
총 4개의 모니터가 존재
- Object lock
- this
- Myclass
- DifferentClass
  


- **독립적인 락 메커니즘**: 인스턴스 블록 동기화와 정적 블록 동기화는 서로 다른 락을 사용합니다. 인스턴스 메소드는 특정 객체의 락을, 정적 메소드는 클래스의 Class 객체 락을 사용한다.
- **병렬 실행 가능성**: 한 스레드가 인스턴스 동기화 블록에 있어도, 다른 스레드는 정적 동기화 블록을 동시에 실행할 수 있다. 이는 두 동기화 블록이 서로 다른 락을 사용하기 때문이다.
- **자원 공유 주의**: 두 동기화 블록이 동일한 자원을 다루는 경우, 개별 락에도 불구하고 여전히 동기화 문제가 발생할 수 있다. 이런 경우에는 추가적인 동기화 전략이 필요할 수 있다.

## synchronized 특성

### 재 진입성
- 모니터 내에서 이미 synchronized 영역에 들어간 스레드가 다시 같은 모니터 영역으로 들어갈 수 있는데, 이를 모니터의 재진입이라고 한다.
- 이미 락을 보유한 스레드가 다른 **`synchronized`** 블록에 진입할 때, 이 스레드는 락을 재획득할 수 있습니다. 이는 재진입 가능 락(Reentrant Lock)의 개념으로, 데드락을 방지하는 데 도움이 됩니다.
- 재 진입이 가능하다는 것은 락의 획득이 호출단위가 아닌 스레드 단위로 일어난다는 것을 의미하며 이미 락을 획득한 스레드는 같은 락을 얻기 위해 대기할 필요 없이 synchronized 블록을 만났을때 같은 락을 확보하고 진입한다.

```java
class Parent {
    public synchronized void method() {
        System.out.println("Parent Method");
    }

}

class Children extends Parent {
    @Override
    public synchronized void method() {
        System.out.println("Children Method : Before Call Parent");
        super.method();
        System.out.println("Children Method : After Call Parent");
    }
}


```
간단하게 특정 클레스에 `synchronized` 메서드 1번이 있고 이안에서 다른 `synchronized` 메서드2번을 호출했을때 이는 특정 스레드 1번이 메서드1번에 락을 획득하고 이를 해제하지 않고 바로 메소드2번의 락을 획득하고 있는 상황이다.  
  
이는 스레드가 하나의 `synchronized` 영역 진입한 다음에 다른 `synchronized` 영역에 진입할때 그 해당 스레드가 같은 모니터를 가지고 있다면 2번째 `synchronized` 영역에 다시 재 진입하는 메소드는 다시 락을 획득하기위에 경쟁하는 것이 아니라 바로 진입하게 된다.
  
- 클레스를 상속하게 되면 부**모의 락과 동일한 락을 자식이 가지게 된다.**
- **동기화 된 메서드**에서 **다른 동기화 된 메서드를 호출**하는 경우 이미 락을 가지고 있는 스레드가 **같은 락을 확보하고 재진입**시 데드락이 발생하지 않고 정상적으로 진행할 수 있다.
  
  
### 가시성

- synchronized는 가시성을 지원한다.
- 가시성이란 한 스레드가 공유자원을 수정하거나 쓰기 작업을 했을때 다른 스레드가 수정한 내용이 보이는 것을 말한다.

### 그 외 특성

1. **상호 배제(Mutual Exclusion)**:
    - **`Synchronized`** 키워드가 적용된 메서드나 블록은 한 시점에 하나의 스레드만 실행할 수 있습니다.
    - 다른 스레드는 현재 실행 중인 스레드가 **`synchronized`** 블록을 완료하고 락을 해제할 때까지 대기해야 합니다.
2. **락(Lock) 메커니즘**:
    - 객체 레벨 락: 일반 **`synchronized`** 메서드는 객체의 락을 사용합니다. 이는 객체의 모든 **`synchronized`** 메서드가 같은 락을 공유한다는 것을 의미합니다.
    - 클래스 레벨 락: **`static synchronized`** 메서드는 클래스의 Class 객체의 락을 사용합니다. 이는 해당 클래스의 모든 **`static synchronized`** 메서드가 동일한 락을 공유한다는 것을 의미합니다.
3. **자동 락 관리**:
    - 스레드가 **`synchronized`** 블록에 진입할 때 자동으로 락을 획득하고, 블록을 벗어날 때 락을 자동으로 해제합니다.
4. **메모리 가시성(Memory Visibility)**:
    - **`Synchronized`**는 메모리 가시성도 제공합니다. 한 스레드가 수정한 변수의 값이 다른 스레드에게 올바르게 보이도록 보장합니다.
5. **스레드 간 협력**:
    - **`synchronized`** 블록 내에서 **`wait()`**, **`notify()`**, **`notifyAll()`** 메서드를 사용하여 스레드 간 협력이 가능합니다. 이 메서드들은 스레드가 조건이 충족될 때까지 대기하거나 다른 스레드에게 신호를 보낼 수 있게 합니다.

## 스레드간 협력

자바에서 스레드 간의 협력은 주로 **`wait()`**, **`notify()`**, **`notifyAll()`** 메서드를 사용하여 이루어집니다. 이러한 메서드들은 동기화된(synchronized) 블록 또는 메서드 내에서 호출되어야 하며, 객체의 내장 락(intrinsic lock)을 사용하여 스레드 간의 상호 작용을 조절한다.  

**`wait()`**, **`notify()`**, **`notifyAll()`** 은 모니터 객체의 조건 변수오 ㅏ함께 사용해서 동기화를 구현할 수 있는 동기화 메커니즘이라 할 수 있다. 뮤텍스(상호배제) 동기화 기법은으로 충족되지 않는 동기화 문제를 해결할 수 있는 협력에 의한 동기화 장치이다.  

**`wait()`**, **`notify()`**, **`notifyAll()`** 이 메소드들은 **반드시 `Synchronized`블록 안에서만 사용해야 하며** 이는 스레드가 모니터 락을 확보한 상태에서 이 API들이 작동한다는 것을 의미한다.

> 복습
>
> - **Entry Set**: 객체에 대한 동기화된 메서드나 블록에 접근하려는 스레드들이 대기하는 곳입니다. 이 곳에서 스레드들은 객체의 락을 획득하기 위해 대기한다.
> - **Wait Set**: **`wait()`** 메서드 호출로 인해 특정 객체에 대해 대기하고 있는 스레드들이 위치하는 곳입니다. 이 스레드들은 **`notify()`** 또는 **`notifyAll()`** 메서드에 의해 깨어날 때까지 대기한다.

## wait()

**`wait()`** 메서드는 **호출된 객체에 대한 락을 해제**하고, 스**레드를 객체의 Wait Set에 넣습니다**. 스레드는 **`notify()`** 또는 **`notifyAll()`** 메서드가 호출될 때까지 대기합니다.

### 동작 흐름

- 스레드를 **대기 상태로 전환**시키고 모니터 **락은 해제**되며 다른 스레드가 모니터 락을 획득하여 작업을 수행할 수 있다
- **조건 변수와 함께 사용**되어 특정 **조건이 만족될 때까지 대기**하게 되며 이를 통해 스레드 간의 효율적인 협력을 구현할 수 있다
- 다른 스레드가 동일한 모니터 락을 획득하고 notify() 또는 notifyAll() 메서드를 호출하면 대기 중의 한 스레드 혹 모든 스레드가 깨어난다
- **스레드는 깨어난 상태에서 바로 실행하는 것이 아니라 락을 획득해야 하며** 락을 획득한 스레드는 **wait() 다음 구문을 수행**하게 된다
- wait(long timeout) 을 사용하여 일정 시간 동안 대기하도록 타임아웃을 지정할 수 있으며 타임아웃이 경과하면 스레드는 자동으로 깨어난다
- 인터럽트가 걸리면 InterruptedException 예외가 발생하고 인터럽트 된 스레드는 대기에서 깨어나게 된다. 예외 처리가 필요하다.

```java
synchronized (object) {
    while (조건이 충족되지 않음) {
        object.wait();
    }
    // 조건이 충족된 후의 작업 수행
}
```

## notify(), notifyAll()

**`notify()`** 메서드는 **대기 중인 스레드 중 하나 또는 모두를 임의로 깨웁**니다. 깨어난 스레드는 대기하던 조건이 충족되었는지 다시 확인해야 합니다.

### 동작 흐름

- notify()는 같은 모니터의 **조건 변수에서 대기 중인 스레드 중에서 임의의 하나를 깨우며 notifyAll()은 스레드 전체를 깨운다.**
- **어떤 스레드가 깨어날 것인지 알 수 없으며** 무작위로 선택되기 때문에 **notify() 보다 notifyAll() 을 사용하는 것을 선호**한다
- 깨어난 스레드가 **다시 실행되어야 할 때는 해당 객체의 모니터 락을 다시 획득하기 위해 경쟁**해야 한다
- 스레드를 깨울 때 **우선순위가 높은 스레드가 깨어날 것이라는 보장은 없다.** 운영체제와 JVM의 스케줄링 정책에 따라 결정된다
- 메서드 호출 후 **synchronized 블록이 끝나기 전까지 락이 해제되지 않으며** 해당 블록에서 빠져나가야 락이 해제된다

```java
synchronized (object) {
    // 조건 변경
    object.notify();
}
```

## 스레드 간 협력의 기본 동작 구조

스레드 간 협력의 기본 동작 구조는 자바에서 **`wait()`**, **`notify()`**, **`notifyAll()`** 메서드를 사용하여 구현된다. 이들은 객체의 내장 락(intrinsic lock)을 기반으로 동작하며, 스레드가 특정 조건이 충족될 때까지 기다리거나, 조건 충족 시 다른 스레드에게 알림을 보내는 데 사용된다

> 만약 특정한 조건이 만족될 때까지 다음으로 진행하지 못한다면?
>
> - 이미 락을 소유한 스레드가 특정한 조건이 만족 될 때까지 동기화 영역을 빠져 나오지 못하므로 다른 스레드들은 락을 무한정 기다려야 하는 상황이 발생할 수 있다
> - 특정한 조건이 만족 될 때까지 계속 반복하면서 상태를 확인(SpinLock) 해야 하므로 CPU 부하 등 쓸데없는 자원낭비로 이어질 수 있다

`wait()`은 **대기(락 해제) 하게** 하고 `notify()`는 **통지(락 획득) 함**으로서 스레드간 상호 배제와 상호 협력으로 동기화를 구현할 수 있다.
  
### 동기화 영역에서 특정한 조건이 만족될 때가지 다음으로 진행하지 못할 경우 조건변수는 좋은 해결책
- 이미 락을 소유한 스레드가 특정한 조건이 만족 될때 까지 가지고 있는 락을 해제하고 대기하도록 한다.
- 다른 스레드가 락을 획득한 후에 특정한 상황을 해결 하고 대기 중인 스레드들을 깨우면 깨어난 스레드는 라글 다시 획득한 후 계속 프로세스를 진행하도록 한다.
- 스레드는 조건이 만족 될 때가지 계속 반복 수행 할 필요가 없으며 스레드 간 협력을 통해서 상호배제 동기호를 유지하면서 문제를 해결해 나갈 수 있다.


### **1. 동기화된 블록 또는 메서드**

스레드 간 협력은 **`synchronized`** **키워드를 사용한 블록 또는 메서드 내에서 이루어집니다.** 이는 스레드가 객체의 내장 락을 획득해야만 해당 블록 또는 메서드 내의 코드를 실행할 수 있음을 의미한다.

### **2. 조건의 대기와 신호 (wait, notify, notifyAll)**

- **wait()**:
    - 스레드가 특정 조건이 충족되기를 기다리는 동안 호출됩니다.
    - `wait()`를 호출하는 스레드는 객체의 락을 해제하고, 객체의 대기 집합(wait set)에 들어갑니다.
    - 이 스레드는 다른 스레드가 **`notify()`** 또는 `notifyAll()`을 호출할 때까지 대기합니다.
- **notify()**:
    - 다른 스레드에게 조건이 충족되었음을 알리기 위해 호출됩니다.
    - 대기 집합에 있는 스레드 중 하나를 임의로 깨워 실행을 재개하게 합니다.
- **notifyAll()**:
    - `notify()`와 유사하지만, 대기 집합에 있는 모든 스레드를 깨웁니다.
    - 여러 스레드가 동일한 조건에 대해 기다리고 있을 때 사용됩니다.

### **3. 락의 재획득과 조건 재확인**

- **락 재획득**:
    - **`notify()`** 또는 `notifyAll()`에 의해 깨어난 스레드는 객체의 락을 재획득하기 위해 경쟁합니다.
    - 락을 재획득하면, 스레드는 대기 전의 상태로 돌아가 코드 실행을 계속합니다.
- **조건 재확인**:
    - 깨어난 스레드는 대기 조건을 다시 확인해야 합니다. 이는 `notify()`가 호출된 후 조건이 여전히 충족되는지, 또는 다른 스레드에 의해 변경되었는지 확인하기 위함입니다.

### **예시 코드**

```java
javaCopy code
class SharedResource {
    private boolean condition = false; // 1.상태 변수에 따라 wiat()을 실행할 것인지 아닌지 조건을 명시한다.

    public synchronized void waitForCondition() throws InterruptedException {
        //2. wiat()을 호출하기 전에 조건을 확인하고 wait()에서 리턴된 후에도 조건을 확인해야한다.
        //3. 조건을 확인하는 구문은 반드시 while 구문이 되도록한다.
        // 알 수 없는 이유로 스레드가 깨어나는 현상이 있는데 이를 spurious wakeups 하고 notify()로 깨어나야 할 스레드가 이미 깨어나 활동하고 있는 심각한 상황이 발생할 수 있다.
        // 대기에서 깨어난 스레드가 락을 획득한 후 wait() 구문에서 리턴하여 진행을 하는데 그 전에 조건을 확인해 보니 다시 wait() 를 실행해야 하는 상태가 발생할 수 있다. 
        // 즉 깨어나서 실행하려고 하는 사이에 다른 스레드에 의해 상태 값이 변경될 가능성이 있다.
        
        while (!condition) {
            wait();  // 조건이 충족될 때까지 기다림 wiat() 메소드는 반드시 synchronized 블록안에서 실행되어야한다. 그렇지 않으면 IllegalMonitorStateException이 발생한다.
            
        }
        // 조건 충족 시 수행할 작업
        condition = false;  // 조건 초기화
    }

    public synchronized void setCondition() {
        condition = true;  // 조건 설정
        notifyAll();  // 모든 대기 중인 스레드에 신호
    }
}

```

여기서 `waitForCondition()`은 특정 조건(예: **`condition`** 변수의 값)이 충족될 때까지 대기하고, `setCondition()`은 조건을 충족시키고 대기 중인 스레드들에게 신호를 보내는 역할을 합니다.

### **요약**

스레드 간 협력은 **`wait()`**, **`notify()`**, **`notifyAll()`** 메서드를 사용하여 동기화된 블록 또는 메서드 내에서 조건의 대기와 신호를 통해 이루어 진다. 이를 통해 스레드들은 서로의 작업 상태에 따라 동작을 조율하고, 공유 자원에 대한 안전한 접근을 보장 한다.

# volatile
volaitle은 변수의 가시성과 연산의 순서를 제어하기 위해 사용하는 키워드, 스레드간 데이터의 일관성과 가시성을 보장하는 역할을 한다.

## volatile 키워드

`volatile`은 자바에서 변수를 선언할 때 사용하는 키워드로, 해당 변수의 읽기와 쓰기가 메인 메모리에서 직접 이루어지도록 보장 한다. **`volatile`** 키워드가 사용된 변수는 다음과 같은 특징을 가진다.

1. **메모리 가시성 보장**: **`volatile`** 변수는 모든 스레드에게 항상 가장 최근에 쓰여진 값이 보이도록 합니다. 이는 각 스레드가 자신의 로컬 캐시가 아닌 메인 메모리에서 변수의 값을 읽고 쓰게 함으로써 달성 된다.
2. **원자성은 보장하지 않음**: **`volatile`**은 변수의 연산이 원자적(atomic)이라는 것을 보장하지 않습니다. 예를 들어, **`volatile`** 변수에 대한 증감 연산(**`++`**)은 원자적이지 않습니다.

## **CPU 캐시 메모리 와 메인 메모리**

현대 컴퓨터는 거의 대부분 2개 이상의 CPU가 장착되어 있으며 각 코어에는 레지스터와 캐시메모리가 존재한다. CPU 캐시 메모리는 CPU 레지스터와 메인 메모리 사이에서 데이터 흐름을 최적화하고 성능을 향상시키기 위해 사용되는 고속 메모리이다.  
  
**CPU 는 값을 읽어올 때 우선 캐시에 해당 값이 있는지 확인**하고 **없는 경우에만 메인 메모리에서 읽어오는 특성**을 가진다. 이 캐시 메모리는 메인 메모리보다 훨씬 빠르게 데이터에 접근할 수 있다.

> **캐시 메모리 (Cache Memory)**
>
>
> 캐시 메모리는 CPU와 주 메모리(RAM) 사이에 위치하며, 자주 사용되는 데이터와 명령어를 임시로 저장합니다. 이는 주 메모리에 비해 빠른 데이터 접근 속도를 제공합니다.
>
> - **속도**: 캐시 메모리는 주 메모리보다 훨씬 빠른 접근 속도를 가집니다.
> - **용도**: CPU가 반복적으로 사용하는 데이터와 명령어를 저장하여, CPU의 처리 속도를 향상시킵니다.
> - **계층 구조**: 캐시 메모리는 여러 레벨(L1, L2, L3 등)로 구성될 수 있으며, L1 캐시가 가장 빠르지만 용량이 가장 작고, L3 캐시는 상대적으로 느리지만 용량이 더 큽니다.

> **레지스터 (Register)**
>
>
> 레지스터는 CPU 내부에 있는 매우 빠른 메모리로, 현재 CPU가 실행 중인 연산에 필요한 데이터와 명령어를 저장합니다.
>
> - **속도**: 레지스터는 모든 유형의 메모리 중에서 가장 빠른 접근 속도를 제공합니다.
> - **용도**: 현재 CPU에서 실행 중인 명령어의 매개변수, 중간 결과, 기계어 명령어 등을 저장합니다.
> - **용량**: 매우 제한적인 용량을 가지며, 이는 CPU가 직접적으로 처리하는 데 필요한 소량의 정보만을 저장하기 위한 것입니다.

> **캐시 메모리와 레지스터의 차이점**
>
> 1. **위치와 속도**:
     >     - 레지스터는 CPU 내부에 위치하고, 캐시 메모리는 CPU와 주 메모리 사이에 위치합니다.
>     - 레지스터는 캐시 메모리보다 접근 속도가 더 빠릅니다.
> 2. **용량**:
     >     - 레지스터의 용량은 매우 제한적이며, 캐시 메모리는 더 큰 용량을 가집니다.
> 3. **사용 목적**:
     >     - 레지스터는 현재 CPU에서 처리 중인 데이터를 위한 공간으로 사용됩니다.
>     - 캐시 메모리는 자주 사용되는 데이터와 명령어를 저장하여 CPU의 성능을 향상시키는 데 사용됩니다.

### CPU가 데이터 처리를 위해 메인 메모리에 접근 할때 발생하는 과정

**1. CPU가 처리할 데이터 요청**

- CPU는 특정 작업을 수행하기 위해 데이터가 필요할 때 메인 메모리에 접근합니다. 이는 프로그램의 명령어 실행 중에 발생하는 일반적인 시나리오입니다.

**2. 캐시 메모리 확인**

- CPU가 데이터에 접근하기 전에 먼저 캐시 메모리를 확인합니다. 캐시 메모리는 작고 빠른 메모리로, CPU가 자주 사용하는 데이터와 명령어를 저장합니다.
- 캐시 메모리는 여러 레벨(L1, L2, L3 등)로 구성되어 있으며, CPU는 먼저 L1 캐시를 확인한 후 L2, L3 순으로 검색합니다.

**3. 캐시 히트와 미스**

- **캐시 히트(Cache Hit)**: 요청한 데이터가 캐시 메모리에 존재하는 경우, CPU는 즉시 해당 데이터를 사용합니다. 캐시 히트는 메모리 접근 시간을 크게 단축시킵니다.
- **캐시 미스(Cache Miss)**: 데이터가 캐시에 없는 경우, 캐시 미스가 발생하고 CPU는 메인 메모리에 직접 접근해야 합니다.

**4. 메인 메모리 접근**

- 캐시 미스가 발생하면 CPU는 메인 메모리에 접근하여 필요한 데이터를 검색합니다. 메인 메모리는 캐시보다 접근 속도가 느립니다.
- 메인 메모리에서 데이터를 읽은 후, 이 데이터는 나중에 다시 접근할 가능성을 고려하여 캐시 메모리에도 저장됩니다.

**5. 데이터 처리**

- 메모리에서 데이터를 읽은 후, CPU는 이 데이터를 처리합니다. 예를 들어, 데이터를 CPU의 레지스터로 이동시키고, 연산을 수행한 다음, 결과를 다시 메모리에 저장할 수 있습니다.

**CPU 는 처리 성능을 높이기 위해서** 속도가 느린 메인 메모리에서 데이터를 읽고 쓰는 대신 속도가 빠른  CPU **캐시 메모리에서 데이터를 읽고 저장하는 메카니즘**을 수행한다.  
  
멀티 스레드 환경에서 CPU 에 할당된 스레드가 메인 메모리가 아닌 CPU 캐시에서 공유 변수를 참조하게 되면 서로 다른 변수 값을 스레드가 참조하게 되는 되는 상황이 발생하게 된다.  
   
> **가시성이 보장된다는 의미**  
> 여러 스레드들이 바라보는 모든 값이 공통된 영역의 값을 참조한다는 의미  
> 메인 메모리는 하나 밖에 없기 떄문에 모든 스레드들이 이 메인 메모리를 바라보기만 한다면  가시성을 확보할 수 있다. 
>   
> 즉 가시성을 확보한다는 의미는 모든 데이터를 캐시 메모리가 아닌 메인 메모리에서 그 값을 읽고 쓰게 한다는 의미

### 가시성(visibility)

멀티스레드 환경에서 공유 변수의 변경 내용이 한 스레드에서 다른 스레드에게 어떻게 보이는지를 나타내는 개념을 말한다.  
  
멀티스레드 프로그래밍에서는 여러 스레드가 동시에 변수에 액세스하고 수정할 수 있기 때문에 모든 스레드에게 변수의 값이 일관되게 보여지도록 가시성이 확보되어야 한다.

### **가시성 문제의 발생**

- **독립적인 캐시**: 멀티코어 프로세서에서 각 코어는 자체 캐시 메모리를 가지고 있습니다. 스레드가 특정 코어에서 실행되면, 해당 코어의 캐시에 데이터를 저장하고 접근합니다.
- **비동기화된 캐시 상태**: 한 스레드가 공유 변수의 값을 변경하고 이를 자신의 캐시에 저장하면, 이 변경사항이 다른 코어의 캐시에 즉시 반영되지 않을 수 있습니다. 결과적으로, 다른 스레드는 변경된 최신 값을 볼 수 없게 됩니다.

### **가시성 문제의 예**

예를 들어, 두 스레드가 각각 다른 CPU 코어에서 실행되고 있고, 두 코어는 공유 변수 `x`의 값을 캐시에 저장하고 있다.  
  
한 스레드가 `x`의 값을 변경한다면, 이 변경사항은 해당 스레드가 실행되는 코어의 캐시에만 반영되지만 다른 코어에서 실행되는 스레드는 여전히 오래된 `x`의 값을 볼 수 있으며, 이로 인해 데이터의 일관성이 깨지고 예상치 못한 결과가 발생할 수 있습니다.

### **해결 방법**

### **Volatile 키워드**

자바에서 **`volatile`** 키워드는 **가시성 문제를 해결하는 데 사용** 된다.  
  
`volatile`로 선언된 변수는 각 스레드에 의해 수정될 때 메인 메모리에 쓰여지고, 다른 스레드에 의해 읽힐 때 메인 메모리로부터 읽혀 진다. 이를 통해 모든 스레드가 변수의 최신 값을 볼 수 있도록 한다.  
  
따라서 공유변수에 `volatile` 키워드를 선언하면 CPU가 데이터 작업을 할 때 메인 메모리에서 공유 변수를 직접 읽고 수정된 결과를 메모리에 즉시 반영함으로 가시성 문제를 해결한다.  
  
### 한계점
`volatile`은 스레드 간 공유변수에 대한 **가시성**을 보장하지만 동시적 상호배제를 보장하지는 않는다. 즉, 읽기 작업하는 스레드와 쓰기작업하는 스레드가 N:1 의 상황에서는 동시성을 보장하지만 N:N의 상황에서는 동시성을 보장해주지 못한다.

### **동기화 메커니즘 (synchronized)**

**`synchronized`** 블록이나 `ReentrantLock`과 같은 동기화 메커니즘을 사용하면, 스레드가 공유 데이터에 접근하기 전에 메모리의 가시성을 보장할 수 있다. `synchronized 블록`을 사용하면 한 시점에 오직 하나의 쓰레드만이 동기화 영역에 접근할 수 있도록 보장해준다. 
  
이는 락을 획득하거나 해제할 때 메모리 배리어(memory barrier)를 사용하여 캐시의 데이터를 주 메모리와 동기화 한다.

synchronized 블록 안에서 참조되는 모든 변수들은 메인 메모리로부터 읽어들여지고 블록을 벗어나면 그 동안 수정된 모든 변수들이 즉시 메인 메모리로 반영될 수 있도록 해준다.  **synchronized 는 상호배제와 함께 가시성의 문제까지 해결할 수 있는 기능을 포함**하고 있다`(synchronized 블록 내에서는 volatile 키워드가 없어도 된다)`

### **경쟁 조건 (Race Condition)**

경쟁 조건(Race Condition)은 멀티스레딩 환경에서 여러 스레드가 동시에 공유 자원에 접근하고, 이 자원의 결과가 그 접근 순서에 따라 달라질 때 발생하는 상황을 말합니다.  
  
간단하게 말해서 여러 스레드가 동일한 자원에 접근 할때 그 결과값이 서로 달라질 수 있음을 의미한다.

### **경쟁 조건의 발생**

- **공유 자원에 대한 동시 접근**: 두 개 이상의 스레드가 동시에 공유 자원(변수, 파일, 데이터베이스 레코드 등)을 읽거나 수정할 때 발생 한다.
- **비동기적 실행**: 멀티스레딩 환경에서 스레드들은 서로 독립적으로 실행되며, 이들의 실행 순서는 운영 체제의 스케줄링에 따라 달라 진다.

### **경쟁 조건의 예시**

```java

public class Counter {
    private int count = 0;

    public void increment() {
        count++;  // count = count + 1
    }

    public int getCount() {
        return count;
    }
}

Counter counter = new Counter();

// 스레드 A
new Thread(() -> {
    counter.increment();
}).start();

// 스레드 B
new Thread(() -> {
    counter.increment();
}).start();

```

이 예시에서 **`counter.increment()`** 메소드는 **`count`** 변수를 증가 시킨다. 두 스레드가 거의 동시에 `increment()`를 호출하면, 한 스레드가 변수를 읽고 증가시킨 후 다른 스레드가 동일한 작업을 수행하기 전에 변수를 다시 읽을 수 있다. 이로 인해 **`count`** 변수의 최종 값은 예상치 못한 결과를 나타낼 수 있다.

### **경쟁 조건 해결 방법**

- **동기화(Synchronization)**: **`synchronized`** 키워드, `ReentrantLock`과 같은 동기화 메커니즘을 사용하여 한 시점에 하나의 스레드만이 공유 자원에 접근하도록 제한 한다.
- **원자적 연산(Atomic Operations)**: **`java.util.concurrent.atomic`** 패키지의 클래스들은 원자적 연산을 제공하여 공유 자원에 대한 안전한 접근을 보장 한다.
- **락(Lock)과 조건 변수(Condition Variables)**: 더 복잡한 동기화 요구 사항에 대해 락과 조건 변수를 사용하여 세밀한 제어를 수행할 수 있다.


## **Happens-Before 보장**

Happens-Before 보장은 특정 메모리 작업(읽기, 쓰기)의 순서를 정의하는 규칙입니다. 이 규칙은 멀티스레드 프로그램에서 하나의 스레드에서 수행된 작업이 다른 스레드에 어떻게 보이는지를 정의 한다.  
  
즉, 한 스레드의 작업 결과가 다른 스레드에게 언제 그리고 어떻게 가시적(Visible)이 되는지를 규정하는 것이다

### **Happens-Before 규칙의 핵심**

Happens-Before 규칙의 핵심은 메모리 **가시성(Memory Visibility)과 작업 순서(Ordering)** 입니다. 이 규칙에 따르면, 특정 작업 A가 다른 작업 B보다 먼저 일어난다면("happens-before"), 작업 A의 결과는 작업 B에서 관찰될 수 있어야 한다.

### 예시

JVM 은 프로그램의 성능을 향상시키기 위해 명령어를 재 정렬하지만 volatile 변수를 사용하면 해당 변수를 읽거나 쓰는 작업은 특별한 규칙에 따라 재정렬되지 않도록 보장한다.

즉 volatile 변수 전과 후에 실행되는 명령들은 JVM 컴파일러에 의해 재 정렬 될 수 있으나 volatile 변수에 대한 명령 이전/이후에 존재한다는 규칙은 반드시 지켜진다.

> **JVM 컴파일에 의한 재정렬 이란?**
> 자바 가상 머신(JVM)에서 수행되는 코드 최적화 과정 중 하나를 가리킵니다. 이 과정에서 JVM의 Just-In-Time(JIT) 컴파일러는 프로그램의 성능을 향상시키기 위해 코드의 실행 순서를 변경(재정렬)할 수 있습니다. 이러한 최적화는 프로그램의 동작에 영향을 미치지 않는 범위 내에서 수행됩니다.
>
- **쓰기-읽기 순서 보장**: **`volatile`** 변수에 값을 쓰는 작업은 이후에 발생하는 해당 변수에 대한 모든 읽기 작업에 대해 순서가 보장됩니다. 즉, 한 스레드에서 **`volatile`** 변수를 수정한 후, 다른 스레드가 이 변수를 읽으면 항상 가장 최근에 쓰여진 값을 읽게 됩니다.

```java
public class Exam {
    private int x = 0;
    private volatile boolean flag = false;
    
    public void write() {
        x = 42;
        flag = true;
    }
    
    public void read() {
        if (flag) {
            System.out.println(x);
        }
    }
}

```
#### 컴파일 후 재정령 안됨 flag가 volatile 변수로 선언되어서 명령어 재 정렬이 일어나지 않음


```java
public class Exam {
    private int x = 0;
    private boolean flag = false;
    
    public void write() {
        x = 42;
        flag = true;
    }
    
    public void read() {
        if (flag) {
            System.out.println(x);
        }
    }
}

```
### 컴파일 전

```java
public class Exam {
    private int x = 0;
    private boolean flag = false;
    
    public void write() {
        flag = true;
        x = 42;
    }
    
    public void read() {
        if (flag) {
            System.out.println(x);
        }
    }
}

```
### 컴파일 후 재 정렬됨 
모든 변수가 일반변수 이기때문에 재 정렬이 일어날 수 있음

`volatile` 키워드가 붙은 변수기준으로 그 위에 선언된 변수와 그아래 선언된 변수들은 재정령이 가능하다. 하지만 `volatile` 키워드를 기준으로 위에 선언된 변수와 아래 선언된 변수가 서로 번가라 가변수 재정령 되지는 않는다.  

```java
private String b = 2;
private String c = 3;
private volatile String a = 1;

private String d = 4;
private String e = 4;

```
a를 기준으로 b,c는 재정렬 될수있고 그 밑에있는 d,e도 재정령 될수 있지만 b가 d에 있는 위치로 가거나 e가 c에 위치로 정렬되는 현상은 발생하지 않는다는 말이다.  

### **작동 원리**

- **메모리 배리어**: **`volatile`** 변수에 대한 쓰기 작업이 일어날 때, Java Memory Model은 쓰기 전에 발생한 모든 메모리 작업이 쓰기 작업 이전에 완료되었음을 보장하는 '메모리 배리어'를 삽입합니다. 이로 인해 쓰기 작업 이전의 모든 변경사항이 메인 메모리에 반영됩니다.
- **가시성 보장**: **`volatile`** 변수에 대한 읽기 작업은 메인 메모리에서 최신 값을 읽어오므로, 다른 스레드에서 수행한 최근의 쓰기 작업의 결과가 항상 보장됩니다.

> **메모리 배리어란?**
`메모리 배리어(Memory Barrier)`, 또는 `메모리 펜스(Memory Fence)`는 멀티스레딩 환경에서 스레드 간의 메모리 가시성과 순서를 보장하기 위해 사용되는 낮은 수준의 프로그래밍 구조입니다. 메모리 배리어는 CPU나 컴파일러가 명령어의 실행 순서를 재배열하는 것을 제한하여, 특정 지점에서 메모리 작업의 완료를 보장합니다.
>
>
> **Java에서의 메모리 배리어**
>
> 자바에서는 **`volatile`** 키워드와 **`synchronized`** 블록을 통해 메모리 배리어의 역할이 내부적으로 처리됩니다.
>
> - **volatile 변수**: **`volatile`** 변수에 대한 쓰기 작업은 쓰기 배리어처럼 작동하여, 해당 작업 이전에 발생한 모든 메모리 작업이 쓰기 전에 완료되도록 보장합니다. 마찬가지로, **`volatile`** 변수의 읽기 작업은 읽기 배리어 역할을 하여, 해당 작업 이후의 모든 메모리 작업이 읽기 후에 발생하도록 보장합니다.
> - **synchronized 블록**: **`synchronized`** 블록의 시작과 끝에는 전체 배리어가 존재하여, 블록 내의 모든 메모리 작업이 올바르게 순서가 지켜지고 완료되도록 합니다.

## 데드락  

데드락(Deadlock)은 두 개 이상의 **스레드가 서로의 작업 완료를 무한히 기다리는 상태**를 말합니다. 이 상태에서는 해당 스레드들이 영원히 진행되지 못하고, 락(lock)을 획득하거나 자원을 사용하는 것이 영원히 불가능해 진다.  
  
즉 교착상태에서는 아무런 진전도 이루어지지 않아 작업이 진행되지 않는 문제가 발생한다. 이 DeadLock 은 **동일한 환경과 코드에서 발생할 수도 있고 발생하지 않을 수도 있다.**  
  
여러 스레드가 동일한 자원에 접근하게 될때 이 데이터가 불일치하는 동시성문제가 발생한다. 이 문제를 해결하기위해서 적절한 동기화 기법을 사용해서 동시성 문제를 해결하는 방법을 앞에서 배웠다.  
  
이때 이 동기화기법에 있어서 한 스레드가 공유자원에 접근하게 되면 다른 스레드들은 대기하게 된다. 이때 이 대기하는 상태에서 **자원을 점유하고 있는 스레드와 대기하고 있는 스레드 사이에서 서로의 자원을 주지 못하는 경우가 발생**할 수 있다.  
  
즉 동시성 문제를 해결하기위해 동기화기법을 사용하였는데 거기서 문제가 다시발생하게 되는 형태가 데드락이라고 할 수 있다.

### **데드락 발생의 네 가지 조건**

데드락이 발생하기 위해서는 다음 네 가지 조건이 동시에 충족되어야 한다.

1. **상호 배제(Mutual Exclusion)**: 한 번에 하나의 스레드만이 자원을 사용할 수 있습니다.
2. **점유와 대기(Hold and Wait)**: 스레드가 최소한 하나의 자원을 점유한 상태로, 다른 스레드가 사용 중인 자원을 추가로 요구하며 대기합니다.
3. **비선점(No Preemption)**: 다른 스레드가 이미 점유하고 있는 자원은 강제로 뺏을 수 없습니다.
4. **순환 대기(Circular Wait)**: 각 스레드가 순환적으로 다음 스레드가 요구하는 자원을 점유하고 있으며, 이로 인해 무한 대기 상태가 발생합니다.

### **데드락의 예시**

가장 간단한 예시는 두 스레드가 서로 다른 두 자원을 점유하고, 동시에 상대방의 자원을 요구하는 상황입니다.

```java
class ResourceA {
    synchronized void methodA(ResourceB b) {
        // ResourceA의 일부 작업 수행
        b.methodB();
    }
}

class ResourceB {
    synchronized void methodB() {
        // ResourceB의 일부 작업 수행
    }
}

// 스레드 1
new Thread(() -> {
    resourceA.methodA(resourceB);
}).start();

// 스레드 2
new Thread(() -> {
    resourceB.methodB();
}).start();

```

여기서, 스레드 1은 `ResourceA`의 락을 획득하고 `ResourceB`의 락을 기다리고, 스레드 2는 `ResourceB`의 락을 획득하고 `ResourceA`의 락을 기다리는 상황이 발생할 수 있다.

### **데드락 해결 및 예방 방법**

데드락 방지는 데드락 발생 조건인 네 가지 중에서 최소한 1가지를 방지함으로서 네 가지를 모두 만족하지 않게 하는 기법이다. 일단 데드락이 발생하면 어플리케이션 단에서 데드락을 해소하는 것은 어렵고 서버를 재 기동하거나 종료하는 것 밖에 현실적으로 다른 해결책은 없다.

1.**한번에 하나 이상의 락을 사용하지 않는다**

- 데드락은 스레드가 락을 중첩으로 제어하면서 발생하는 경우가 많기 때문에 가능한 한 스레드가 두 개 이상의 락을 제어하는 상황을 만들지 않도록 하는 것이 좋다

    ```java
    class Resource {
        private final Object lock = new Object();
    
        public void doSomething() {
            synchronized (lock) {
                // 락을 사용한 작업
            }
        }
    }
    ```


2.**락의 순서를 잘 조정한다**

- 불가피하게 여러 개의 락을 사용해야 한다면 락의 점유 순서를 일정한 순서로 정해주도록 함으로써 데드락이 발생할 수 있는 조건 중 하나인 순환 대기를 방지하도록 한다

    ```java
    class OrderedLock {
        private final Object lock1 = new Object();
        private final Object lock2 = new Object();
    
        public void method1() {
            synchronized (lock1) {
                synchronized (lock2) {
                    // 락 lock1, 그 다음 lock2를 순차적으로 사용
                }
            }
        }
    
        public void method2() {
            synchronized (lock1) {
                synchronized (lock2) {
                    // 동일한 순서로 락 사용
                }
            }
        }
    }
    ```


3.**락 타임아웃을 건다**

- 락을 요청할 때 일정 시간 이내에 락을 얻지 못하면 다른 작업을 수행하도록 타임아웃을 설정한다.
- 락 획득에 타임아웃 오류가 나면 오래 기다리지 않고 제어권이 다시 돌아오기 때문에 현재 소유한 락을 해제하고 잠시 기다리다가 데드락 상황이 지나가면 다시 정상으로 동작할 수 있다

    ```java
    import java.util.concurrent.locks.ReentrantLock;
    import java.util.concurrent.TimeUnit;
    
    class TimeoutLock {
        private final ReentrantLock lock = new ReentrantLock();
    
        public void tryLockMethod() {
            try {
                if (lock.tryLock(1000, TimeUnit.MILLISECONDS)) { // 1초 타임아웃
                    try {
                        // 임계 영역
                    } finally {
                        lock.unlock();
                    }
                } else {
                    // 타임아웃 후의 작업
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    ```


4.**메서드는 오픈 호출 형태로 구현한다**

- 락을 전혀 확보하지 않은 상태에서 메서드를 호출하는 것을 오픈 호출이라고 하며 락을 전체 메서드에 적용하지 않고 락이 필요한 임계영역만 보호하도록 한다
- 여러 개의 락을 호출하더라도 동시에 락을 점유하는 것이 아닌 순차적으로 락을 획득하고 해제하는 방식으로 메서드를 호출하도록 한다

    ```java
    class OpenCall {
        private final Object lock = new Object();
    
        public void openCallMethod() {
            // 락을 획득하기 전에 필요한 작업
            synchronized (lock) {
                // 임계 영역
            }
            // 락을 해제한 후의 작업
        }
    }
    ```


5.**스레드 덤프를 활용한다**

- 스레드 덤프에는 실행중인 스레드의 모든 스택 트레이스가 담겨져 있고 락과 관련된 정보도 포함되어 있기 때문에 이를 활용해서 어디에서, 어떤 스레드가 , 어느 시점에 , 왜 데드락이 발생했는지 원인을 추척 및 분석하고 해결방안을 모색할 수 있다.
  
## 그외 활동성 문제

### **기아 상태 (Starvation)**

기아 상태는 특정 스레드나 프로세스가 필요한 자원을 무기한으로 기다리게 되는 상황을 말합니다. 다른 스레드들이 우선적으로 자원을 점유하거나 실행되어 해당 스레드가 자원을 얻지 못하게 되면 기아상태가 발생한다.  
  
이는 일반적으로 자원에 대한 접근이 우선순위나 다른 스레드에 의해 지속적으로 차단될 때 발생합니다.

- **원인**: 일부 스레드가 높은 우선순위를 가지거나, 자원을 과도하게 점유하고 있어 다른 스레드가 자원을 사용할 기회를 얻지 못하는 경우에 발생합니다.
- **결과**: 낮은 우선순위의 스레드 또는 자원을 요청하는 스레드가 무한히 대기하는 상태가 됩니다.
- **해결**: 우선순위를 기반으로 한 스케줄링이 아니라 공정성을 고려하여 모든 스레드가 공평하게 실행될 수 있도록 우선순위를 조정하는 등의 설계가 뒷받침 됨어야 한다.  

### **라이브락 (Livelock)**

라이브락은 스레드들이 실제로는 아무런 진전도 이루지 못하면서도 계속해서 실행 상태인 것처럼 보이는 상황을 말합니다. 라이브락은 데드락과 다르게 작업이 멈추지 않고 계속해서 진행되지만, 실질적인 작업이 진행되지 않거나 진행이 제대로 이루어지지 않는 상태를 의미한다.
  
스레드들은 서로를 피해 자원을 사용하려고 하지만, 결국 아무것도 수행하지 못하는 상태가 됩니다. 또는 서로의 자원을 기다리기 거나 서로가 양보하는 동작이 반복되면서 진행이 지연되는 상태가 발생한다.

- **원인**: 라이브락은 보통 스레드들이 서로의 작업을 방해하지 않으려고 할 때 발생합니다. 예를 들어, 두 스레드가 서로의 작업을 방해하지 않기 위해 동시에 자원을 놓아주려고 하면, 끊임없이 이러한 상태가 반복될 수 있습니다.
- **결과**: 스레드들이 계속해서 실행되고 있지만, 실제로는 어떠한 유용한 작업도 수행하지 못합니다.
- ```java
  public class LivelockExam{
  
  static class Worker{
    private boolean isBusy;
    public Worker(){
    this.isBusy = true;
  }
  public void doWorkWith(Worker partner){
    while(isBusy){
        if(partner.isBusy){
            Thread.sleep(1);
            System.out.println("다른 스레드에게 양보!");
        }else{
            System.out.println("other person will continue working");
            this.isBusy = flase;
        }
  
    }
  }
  
    
  }
  public static void main(String[] args){
    Worker worker1 = new Worker();
    Worker worker2 = new Worker();
  
    new Thread(() -> worker1.doWorkWith(worker2)).start();
    new Thread(() -> worker2.doWorkWith(worker1)).start();
  }
  
  }
  ```
### **차이점**

- **데드락**: 스레드가 서로의 자원을 기다리면서 완전히 멈춘 상태.
- **기아 상태**: 스레드가 자원에 대한 접근을 무기한 대기하는 상태, 하지만 시스템은 여전히 작동 중.
- **라이브락**: 스레드들이 실행 상태이지만 실제로는 진전을 이루지 못하는 상태.
  
# Java Locks
  
## Lock 과 ReentrantLock
락(Lock)은 여러 스레드가 공유 자원에 접근하는 것을 제어하는 데 사용한다. 구현은 synchronized 구문과 마찬가지로 상호배제와 가시성 기능을 가진 동기화 기법이며 synchronized 보다 더 확장된 락 작업을 제공한다.  
  
락을 획득 시 블록되지 않는 비 차단 시도(tryLock()), 인터럽트가 가능한 방식으로 락을 획득하는 시도(lockInterruptibly) 및 시간 제한을 둔 방식으로 락을 획득하는 시도(tryLock(long, TimeUnit))와 같은 추가 기능을 제공한다.

1. **synchronized**: 락 획득과 락 해제가 블로 구조화된 방식으로 발생하도록 강제한다.
- **`synchronized`** 키워드는 메소드 전체 또는 특정 코드 블록에 사용할 수 있습니다.
- 이 키워드는 사용하기 쉬우며, 메소드나 블록이 실행될 때 자동으로 잠금을 획득하고, 실행이 끝나면 자동으로 잠금을 해제합니다.
- `synchronized`는 내부적으로 모니터 락(Intrinsic Lock 또는 Monitor Lock)을 사용합니다.
- 객체 레벨 락(메소드에 사용될 때) 또는 클래스 레벨 락(정적 메소드에 사용될 때)을 제공합니다.
- 예외가 발생하면 잠금이 자동으로 해제됩니다

즉 해당 키워드는 락 획득과 해제가 블록 구조화된 방식으로 발생하도록 강제한다. 만약 여러 **락을 획득하면 반드시 반대 순서대로 해제해야 하며 모든 락은 동일한 문장블록 범위에서 획득하고 해제되어야 한다.**

1. **Lock 인터페이스**:
    - **`java.util.concurrent.locks.Lock`** 인터페이스는 더 복잡한 잠금 작업을 수행할 수 있습니다.
    - `Lock`을 사용하면 수동으로 잠금을 획득하고 해제해야 합니다 (`lock()`과 **`unlock()`** 메소드 사용).
    - 더 세밀한 잠금 제어를 제공합니다, 예를 들어 시도 시간을 설정하거나 잠금을 시도할 수 있는 **`tryLock()`** 메소드가 있습니다.
    - `ReentrantLock`은 **`Lock`** 인터페이스의 일반적인 구현입니다.
    - `Lock`을 사용하면 잠금을 더 유연하게 관리할 수 있지만, `unlock()`을 항상 **`finally`** 블록 내에서 호출해야 하므로 사용이 더 복잡할 수 있습니다.

락을 좀더 유연한 방식으로 작업할 수 있다. 예를 들어 노드 A의 락을 획득한 다음 노드 B의 락을 획득하고 A를 해제하고 C를 획득하고 B를 해제하고 D를 획득하고 이런 식으로 진행할 수 있다.  
  
즉 락을 다른 범위에서 획득하고 해제하도록 허용하며 **락을 어떤 순서로든 획득하고 해제할 수 있도록 허용** 한다.

**synchronized 는 블록을 벗어나면 락 해제가 자동적으로 이루어지지만 Lock 구현은 명시적으로 락을 해제해 주어야 한다.**

### **Lock 인터페이스 주요 메소드:**

1. **void lock()**:
    - 잠금을 획득합니다.
    - 이미 다른 스레드에 의해 잠겨있는 경우, 현재 스레드는 잠금이 해제될 때까지 대기합니다.
2. **void lockInterruptibly() throws InterruptedException**:
    - 잠금을 획득할 때 스레드가 인터럽트될 수 있습니다.
    - 인터럽트가 발생하면 `InterruptedException`이 발생합니다.
    - 락을 정상적으로 또는 재진입으로 획득하는 것보다 인터럽트에 응답하는 것이 우선적으로 처리된다.
3. **boolean tryLock()**:
    - 잠금을 시도하고 즉시 반환합니다.
    - 잠금을 획득할 수 있으면 `true`를, 그렇지 않으면 `false`를 반환합니다.
    - 락이 다른 스레드에 의해 소유되어 있다면 이 메서드는 즉시 false 값을 반환하고 락을 획득하지 못하더라도 스레드가 대기하거나 차단되지 않는다.
4. **boolean tryLock(long time, TimeUnit unit) throws InterruptedException**:
    - 지정된 시간 동안 잠금을 시도합니다.
    - 지정된 시간 내에 잠금을 획득할 수 있으면 **`true`**, 그렇지 않으면 `false`를 반환합니다.
    - 이 메소드 역시 인터럽트에 반응합니다.
    - 이 락이 공정성을 가지도록 설정되어있다면 락이 사용 가능한 경우에는 다른 스레드가 락을 기다리고 있는지 여부와 상관없이 즉시 락을 획득하지 않는다.
    - 현재 스레드가 이 메서드를 호출할 때 인터럽트 상태가 설정되어 있거나 락을 획득하는 동안 인터럽트가 발생한경우 InterruptedException 이 발생 되고 인터럽트 상태가 초기화된다.
5. **void unlock()**:
    - 잠금을 해제합니다.
    - 잠금을 소유하지 않은 스레드가 `unlock()`을 호출하면 `IllegalMonitorStateException`이 발생합니다.
6. **Condition newCondition()**:
    - 현재 잠금과 연관된 **`Condition`** 인스턴스를 반환합니다.
    - **`Condition`** 인스턴스는 특정 조건이 충족될 때까지 스레드가 기다리게 하거나, 특정 조건이 충족됐을 때 스레드에 신호를 보내는 데 사용됩니다.

### **ReentrantLock 클래스:**

`ReentrantLock`은 **`Lock`** 인터페이스의 가장 일반적인 구현체입니다. 재진입 가능한 뮤텍스 잠금을 제공하며, 한 스레드가 이미 잠금을 보유하고 있을 때 그 스레드가 잠금을 다시 획득할 수 있습니다. 이는 재귀적인 메소드 호출이나 반복적인 자원 접근에 유용합니다.

`ReentrantLock`은 선택적으로 공정성을 제공합니다. 생성자에 `true`를 전달하면 가장 오래 기다린 스레드가 먼저 잠금을 획득하도록 할 수 있습니다. 그러나 이는 성능에 영향을 미칠 수 있습니다.  
  
이 ReentrantLock은 내부적으로 Sync라는 클레스를 가지고 있으면 이 클레스를상속 받는 2개의 FairSync(공정한 락 구현), NonFairSyn(불공정한 락 구현) 이 있다.

### **사용 예:**

```java
Lock lock = new ReentrantLock();

public void method() {
    lock.lock();
    try {
        // critical section code
    } finally {
        lock.unlock();
    }
}

```

**`Lock`** 인터페이스와 **`ReentrantLock`** 클래스를 사용함으로써, 개발자는 더 세밀한 동시성 제어와 복잡한 동기화 스케줄링을 수행할 수 있습니다. 이는 **`synchronized`** 키워드를 사용하는 것보다 더 유연하지만, 올바르게 사용되지 않을 경우 복잡성과 오류 가능성이 증가할 수 있습니다.

## synchronized & Lock 구현 비교

synchronized 구문은 락의 획득과 해제가 내장되어 있어 암묵적인 락이라고 하고 Lock 은 락의 회득과 해제를 직접 명시해서 사용함으로 명시적인 락이라고 한다.

### **Synchronized**

1. **기본 사용법**:
    - **`synchronized`** 키워드는 메소드 전체 또는 특정 객체에 대한 블록에 적용됩니다.
    - JVM이 잠금 및 잠금 해제를 자동으로 관리합니다.
2. **구현 예**:

    ```java
    public synchronized void method() {
        // Critical section
    }
    
    public void method() {
        synchronized (this) {
            // Critical section
        }
    }
    
    ```

3. **장점**:
    - 구현이 간단하고 명확합니다.
    - 자동 잠금 관리로 인해 deadlocks를 방지하는 데 도움이 됩니다.
4. **단점**:
    - 잠금 획득/해제에 대한 세밀한 제어가 불가능합니다.
    - 대기 중인 스레드에 대한 관리가 제한적입니다 (예: 대기 시간 설정 불가능).
    - 블록/메소드 단위로만 동기화가 가능합니다.
   
### 선택기준
- ReentrantLock
  - tryLock() : 비차단 락 획득이 필요한 경우
  - lockInterruptibly() : 락 획득을 시도하거나 대기하는 중에 중단이 필요한 경우
  - tryLock(long time, TimeUnit unit) : 지정된 시간 안에 락 획득이 필요한 경우
  - new ReentrantLock() : 공정하게 락을 획득하는 정책을 사용하는 경우
  - {lock.lock()}{...}{lock.unlock()} : 락 획득과 해제가 단일 블록을 벗어나는 경우
- synchronized
  - ReentrantLock의 기능이 필요하지 않을 경우
  - 사용하기 더 편리하고 익숙하다
  - 성능상 크게 차이가 나지 않으며 락 해제가 불 필요하다
  - 복잡하지 않고 문법적으로 더 간단하며 단순한 동기화에서는 가독성이 좋을 수 있다.

## ReentrantLock

**`ReentrantLock`** 클래스는 Java의 **`java.util.concurrent.locks`** 패키지에 있는 **`Lock`** 인터페이스의 구현입니다. 이 클래스는 명시적인 락킹 메커니즘을 제공하며, 동시성 프로그래밍에서 보다 세밀한 잠금 제어가 가능합니다. 여기 `ReentrantLock`의 주요 API들과 각각의 사용 예를 살펴보겠습니다.

### **1. ReentrantLock()**

- **설명**: 기본 생성자로, '비공정 락'을 생성합니다. 이는 먼저 도착한 스레드가 락을 획득하지 못할 수 있음을 의미합니다.
- **예제**:

    ```java
    
    Lock lock = new ReentrantLock();
    
    ```


### **2. ReentrantLock(boolean fair)**

- **설명**: 공정성을 지정할 수 있는 생성자입니다. `fair`가 `true`일 경우, 가장 오래 기다린 스레드가 락을 획득합니다.
- **예제**:

    ```java
    
    Lock lock = new ReentrantLock(true); // 공정 락 생성
    
    ```


### **3. void lock()**

- **설명**: 락을 획득합니다. 락이 이미 다른 스레드에 의해 획득된 경우, 현재 스레드는 락이 해제될 때까지 대기합니다.
- **예제**:

    ```java
    
    lock.lock();
    try {
        // 임계 영역의 코드
    } finally {
        lock.unlock();
    }
    
    ```


### **4. void lockInterruptibly() throws InterruptedException**

- **설명**: 락을 획득합니다. 하지만 현재 스레드가 인터럽트될 수 있으며, 인터럽트될 경우 `InterruptedException`을 던집니다.
- **예제**:

    ```java
    
    try {
        // 락획득을 시도하며 인터럽트에 의해 중단 가능
        lock.lockInterruptibly();
        // 임계 영역의 코드
    } catch (InterruptedException e) {
        // 인터럽트 처리
    } finally {
        lock.unlock();
    }
    
    ```


### **5. boolean tryLock()**

- **설명**: 락을 즉시 획득하려고 시도합니다. 락을 획득할 수 있으면 `true`를, 그렇지 않으면 `false`를 반환합니다.
- **예제**:

    ```java
    
    // 락획득 여부를 즉시반환함
    // 락 획득을 실패하더라도 스레드가 대기하거나 차된지 않음
    if (lock.tryLock()) {
        try {
            // 임계 영역의 코드
        } finally {
            lock.unlock();
        }
    }else{
    // 락을 획득하지 못했을 경우 별도 처리
  }
    
    ```


### **6. boolean tryLock(long time, TimeUnit unit) throws InterruptedException**

- **설명**: 지정된 시간 동안 락을 획득하려고 시도합니다. 시간 내에 락을 획득하면 `true`를, 그렇지 않으면 `false`를 반환합니다.
- **예제**:

    ```java
    
    try {
        // 지정된 시간동안 락획득을 시도하고 시간이 경과하면 락 획득 실패하고 false를 반환
        if (lock.tryLock(10, TimeUnit.SECONDS)) {
            try {
                // 임계 영역의 코드
            } finally {
                lock.unlock();
            }
        }
    } catch (InterruptedException e) {
        // 인터럽트 처리
    }
    
    ```


### **7. void unlock()**

- **설명**: 락을 해제합니다. 락을 소유하지 않은 스레드가 이 메소드를 호출하면 `IllegalMonitorStateException`이 발생합니다.
- **예제**:

    ```java
    
    lock.unlock(); // 보통 finally 블록 내에서 호출됩니다.
    
    ```


### **8. Condition newCondition()**

- **설명**: 현재 락과 연관된 **`Condition`** 인스턴스를 반환합니다. 이 **`Condition`** 인스턴스는 특정 조건이 충족될 때까지 스레드가 기다리게 하거나, 특정 조건이 충족됐을 때 스레드에 신호를 보내는 데 사용됩니다.
- **예제**:

    ```java
    
    Condition condition = lock.newCondition();
    
    lock.lock();
    try {
        condition.await(); // 특정 조건이 충족될 때까지 대기
        // 임계 영역의 코드
        condition.signal(); // 다른 스레드에 신호
    } finally {
        lock.unlock();
    }
    
    ```
  
### 그외 메서드
- int getHoldCount()
  - 현재 스레드가 이 락을 보유한 횟수를 반환하며 이 락을 보유하지 않은 경우에는 0을 반환
- boolean isHeldByCurrentThread()
  - 현재 스레드가 이 락을 보유하고 있는지 확인한다. 이 메서드는 주로 디버깅 및 테스트에 사용되며 락이 보유될 떄만 호출되어야 하는 메서드는 이러한 경우를 확인할 수 있다.
- boolean hasQueuedThreads()
  - 스레드가 이 락을 획득하기 위해 대기 중인지 여부를 조회한다.
  - 취소는 언제든지 발생할 수 있으므로 true를 반환한다고 해서 다른 스레드가 이 락을 획득한다고 보장하지 않는다(모니터링 용으로 사용)
- int getQueueLength()
  - 대기 중인 스레드의 수의 추정치 반환
- boolean hasWaiters(Condition condition)
  - 해당 락과 관련된 지정된 Condition에 대기 중인 스레드가 있는지를 조회
- int getWaitQueueLength(Condition condition)
  - Condition에 대기중인 스레드의 수에 대한 추정치를 반환


`ReentrantLock`을 사용함으로써 개발자는 더 세밀한 동시성 제어와 복잡한 동기화 스케줄링을 수행할 수 있습니다. 그러나 이러한 기능의 잘못된 사용은 복잡성과 오류의 가능성을 증가시킬 수 있으므로 주의가 필요합니다.
  
## ReadWriteLock
ReadWriteLock 은 읽기 작업과 쓰기 작업을 위해 연관된 두 개의 락(읽기 락, 쓰기 락)을 유지하는 인터페이스이다. 일반적으로 **락은 데이터를 조작하는 하나의 스레드의 임계영역**을 보호하는 장치이며 데이터를 읽는 작업만 실행되는 영역은 여러 스레드가 동시에 접근해도 동시성 문제가 발생하지 않는다. **읽기 작업이 많고 쓰기 작업이 적은 영역을 효율적으로 처리**하기 위해 다수의 읽기와 하나의 쓰기를 읽기락과 쓰기락으로 구분해서 락을 운용하는 것이 필요하다.

즉 ,ReadWriteLock는 **여러 스레드가 공유 자원을 동시에 읽을 수 있게 하지만, 한 스레드가 자원에 쓰려고 할 때는 독점적 접근을 요구하는 동시성 제어 메커니즘이다.** 모든 접근을 직렬화하는 표준 상호 배제 잠금(mutex)과 비교하여 성능과 처리량을 향상시킬 수 있습니다.

ReadWriteLock은 다음과 같은 특성이 있다.

1. **읽기 잠금 (공유 잠금):** 다중 스레드가 **쓰기 잠금을 보유하지 않는 한** 동시에 읽기 잠금을 획득할 수 있습니다. 이를 통해 동시에 읽기 작업을 수행할 수 있으며, 공유 자원을 수정하지 않는 읽기 작업이 빈번할 때 효율적 이다.
2. **쓰기 잠금 (독점 잠금):** **한 번에 하나의 스레드만 쓰기 잠금을 획득할 수 있다**. 쓰기 잠금을 보유한 스레드가 있는 동안 다**른 스레드는 읽기 잠금이나 쓰기 잠금을 보유할 수 없다**. 이는 쓰기 작업이 동시 읽기나 쓰기 없이 수행되도록 하여 **데이터 일관성을 유지**합니다.
3. **공정성과 기아:** 구현에 따라 ReadWriteLock은 공정하거나 불공정할 수 있습니다. 공정한 잠금에서는 요청한 순서대로 스레드에게 잠금이 부여되어 스레드의 기아를 줄일 수 있지만 처리량이 감소할 수 있다. 불공정한 잠금에서는 이러한 보장이 없어 스레드가 기아 상태에 빠질 수 있지만 처리량을 증가시킬 수 있다.

### 특징

- **성능 개선**
    - 읽기 락과 쓰기 락의 조합은 상호 배타적인 락을 사용하는 것보다 데이터에 대한 동시 액세스를 허용하므로 동시성이 높아진다.
    - 특히 읽기 작업이 더 빈번한 경우에 효과적이며 읽기 락의 경우 여러 스레드가 동시에 데이터를 읽을 수 있고 쓰기 락의 경우 하나의 스레드만 데이터를 수정할 수 있다.
- **메모리 동기화**
    - 읽기 락 작업은 다른 읽기 락 작업과 상호 작용하는 것이 아니므로  스레드 간 동시에 읽기 작업을 하더라도 메모리의 가시성에 아무런 문제가 없다.
    - 쓰기 락 작업은 읽기 작업 및 다른 쓰기 작업과의 메모리 동기화를 보장해야 한다. 즉 스레드가 쓰기 락을 해제하고 다른 스레드가 읽기 락을 얻었을 때 이전 쓰기 작업의 업데이트를 볼 수 있어야 한다.
  

  데이터 구조가 자주 읽히지만 드물게 수정될 때 ReadWriteLock이 특히 유용하며, 동시에 읽기를 허용함으로써 표준 mutex에 비해 성능을 크게 향상시킬 수 있다. 그러나 올바르게 구현하는 것이 더 복잡할 수 있으며 모든 상황에 가장 적합한 선택은 아닐 수 있다.
  
> **동시성이 높아진다?**  
> 시스템이나 프로그램에서 동시에 실행되는 작업의 수가 증가하거나, 여러 작업이 병렬로 효율적으로 수행될 수 있음을 의미합니다. 이 경우, 프로그램의 동시성을 높이는 것은 더 많은 요청을 동시에 처리할 수 있게 함으로써 전체 시스템의 처리량을 증가시키고 응답 시간을 줄일 수 있습니다.

### 사용 기준

- 읽기/쓰기 락의 사용은 데이터가 읽히는 빈도와 수정되는 빈도, 읽기 및 쓰기 작업의 지속 시간, 데이터에 대한 경합(동시에 데이터를 읽거나 쓰려는 스레드 수)에 따라 결정된다.
- **수정은 드물게 일어나고 검색은 빈번히 발생한다면 읽기/쓰기 락의 사용에 적합한 이상적인 후보**라 할 수 있지만 업데이트가 빈번해지면 **데이터가 대부분 배타적으로 작동**한다.
- 읽기 작업 시간이 긴 경우 여러 스레드들이 경합없이 모두 읽는 이점이 있으나 너무 짧은 경우 읽기/쓰기 락 구현의 오버헤드(읽기작업과 쓰기 작업의 상태를 계속 확인하기 때문에 상호 배제 락보다 알고리즘이 더 복잡함)가 증가하기 때문에 효율성이 떨어진다.

> **데이터가 배타적으로 작동한다?**
> ReadWriteLock을 사용하는 환경에서 쓰기(업데이트) 작업이 빈번하게 발생할 경우의 상황을 설명하는 것 이다.
> 이 말은 특정 상황에서 데이터에 대한 접근이나 조작이 배타적인 잠금 메커니즘을 통해 제어되고 있다는 것을 의미합니다. 즉, 한 시점에 하나의 스레드만이 데이터에 접근하거나 수정할 수 있으며, 다른 스레드들은 그 스레드가 작업을 마칠 때까지 대기해야 한다는 의미이다.
>

### ReadLock
ReentrantReadWriteLock.ReadLock  

읽기 잠금을 반환합니다. 이 잠금을 획득한 스레드는 다른 스레드들도 읽기 작업을 수행할 수 있도록 허용하지만, 쓰기 작업은 차단 된다.  
  
그러나 대기하는 중에도 계속 읽기락을 요청하는 상황이 발생하면 쓰기락을 요청한 스레드는 기아상태가 될 수 있으므로 쓰기락을 요청한 상태에서는 더 이상 스레드가 읽기 접근을 할 수 없다. **가장 큰 장점은 여러 스레드가 상호배제 없이 동시에 데이터를 읽을 수 있어서 동시성이 증가**한다는 점이다.  
  


### WriteLock
ReentrantReadWriteLock.WriteLock  

쓰기 잠금을 반환합니다. 이 잠금을 획득한 스레드는 해당 자원에 대한 독점적인 접근 권한을 갖게 되며, **다른 스레드들은 읽기와 쓰기 모두 차단** 된다.  
  
즉, 쓰기 락은 배타적이며 한 번에 하나의 스레드만 쓰기 락을 보유할 수 있고 쓰기 락을 보유하는 동안에는 다른 어떤 스레드도 읽기 락이나 쓰기 락을 얻을 수 없다. 쓰기 락이 보유되는 동안에 데이터를 수정하는 작업이 수행되며 이 작업이 완료될 때까지 다른 스레드가 해당 락을 얻지 못한다.

### 예시

```java
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class DataContainer {
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    private int data = 0;

    public void writeData(int newData) {
        lock.writeLock().lock();
        try {
            this.data = newData;
            // 데이터 쓰기 작업 수행
        } finally {
            lock.writeLock().unlock();
        }
    }

    public int readData() {
        lock.readLock().lock();
        try {
            // 데이터 읽기 작업 수행
            return this.data;
        } finally {
            lock.readLock().unlock();
        }
    }
}
```

이 예제에서 **`DataContainer`** 클래스는 데이터를 저장하고 있으며, **`writeData`** 메소드와 **`readData`** 메소드를 제공합니다. **`writeData`** 메소드는 쓰기 잠금을 사용하여 데이터를 안전하게 수정하고, **`readData`** 메소드는 읽기 잠금을 사용하여 데이터를 안전하게 읽습니다.

- **쓰기 작업 (`writeData`)**: `writeLock().lock()`을 호출하여 쓰기 잠금을 획득 한다. 이 때 다른 스레드들은 읽기나 쓰기를 수행할 수 없습니다. 작업이 끝나면 `unlock()`을 호출하여 잠금을 해제한다.
- **읽기 작업 (`readData`)**: `readLock().lock()`을 호출하여 읽기 잠금을 획득합니다. 읽기 잠금은 다른 스레드들도 동시에 읽기 작업을 수행할 수 있게 한다. 작업이 끝나면 `unlock()`을 호출하여 잠금을 해제 한다.

## **ReentrantReadWriteLock**

`ReentrantReadWriteLock`은 Java의 **`java.util.concurrent.locks`** 패키지에 있는 클래스로, **`ReadWriteLock`** 인터페이스의 구현입니다. 이 클래스는 읽기와 쓰기 잠금을 모두 지원하며, 특히 "재진입 가능(reentrant)"이라는 특성을 가지고 있다. 재진입 가능이란 한 스레드가 이미 획득한 잠금을 다시 요청할 수 있음을 의미하며, 이로 인해 교착 상태(deadlock)를 방지하는 데 도움이 된다.

### 주요 메소드

1. **ReentrantReadWriteLock.readLock().lock()**
    - **설명**: 읽기 잠금을 제어하는 데 사용됩니다. 이 메소드는 **`Lock`** 인터페이스를 구현하는 객체를 반환합니다.
    - **용도**: 여러 스레드가 동시에 읽기 작업을 수행할 수 있도록 합니다. 쓰기 잠금이 활성화되어 있지 않은 경우에만 읽기 잠금을 획득할 수 있습니다.
2. **ReentrantReadWriteLock.writeLock().lock()**
    - **설명**: 쓰기 잠금을 제어하는 데 사용됩니다. 이 메소드 역시 **`Lock`** 인터페이스를 구현하는 객체를 반환합니다.
    - **용도**: 쓰기 작업을 위한 독점적인 접근을 제공합니다. 쓰기 잠금이 활성화되어 있는 동안 다른 스레드는 읽기나 쓰기를 수행할 수 없습니다.
3. **lock()**
    - **설명**: 잠금을 획득합니다. 잠금을 이미 다른 스레드가 보유하고 있다면, 현재 스레드는 잠금을 획득할 수 있을 때까지 대기합니다.
    - **용도**: 데이터에 안전한 접근을 보장하기 위해 잠금을 사용할 때 필수적으로 호출됩니다. 만약 현재 읽기 락의 수가 0이라면 락은 쓰기 락 시도를 위해 사용 가능하게 된다.
4. **unlock()**
    - **설명**: 잠금을 해제합니다.
    - **용도**: 작업 완료 후 데이터에 대한 접근을 다른 스레드에게 허용하기 위해 사용됩니다.
5. **tryLock()**
    - **설명**: 잠금을 시도하고, 즉시 잠금을 획득할 수 있으면 **`true`**를 반환하고, 그렇지 않으면 **`false`**를 반환합니다.
    - **용도**: 잠금 대기 없이 즉시 잠금을 획득하려는 경우에 사용됩니다.
6. **lockInterruptibly()**
    - **설명**: 잠금을 획득하려고 대기하는 동안 스레드가 인터럽트(interrupt)될 수 있도록 합니다.
    - **용도**: 대기 중인 스레드가 인터럽트에 반응하게 하려는 경우 사용됩니다.
7. **Condition newCondition()**
   - ReadLock은 Condition을 지원하지 않기 때문에 UnsupportedOperationException이 발생한다.
   - 읽기 락은 쓰기 락과 독립적으로 소유되므로 영향을 주지 않지만 현재 스레드가 읽기 락도 획득한 상태에서 조건 대기 메서드를 호출하는 것은 사실상 항상 오류이다. 왜냐하면 대기를 해제할 수 있는 다른 스레드도 쓰기 락을 획득하지 못할 수 있기 때문이다.

      ### **사용 예시**

```java

ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
rwLock.readLock().lock();
try {
    // 데이터 읽기 작업 수행
} finally {
    rwLock.readLock().unlock();
}

rwLock.writeLock().lock();
try {
    // 데이터 쓰기 작업 수행
} finally {
    rwLock.writeLock().unlock();
}

```

   이 예시에서는 먼저 읽기 잠금을 획득하여 데이터 읽기 작업을 수행한 후 잠금을 해제합니다. 그 다음에 쓰기 잠금을 획득하여 데이터 쓰기 작업을 수행한 후 잠금을 해제합니다. 이러한 패턴은 데이터의 일관성과 동시성을 모두 관리하는 데 중요하다.

## Lock 공정성  

공정성은 잠**금을 요청하는 스레드들 사이에서 공평하게 잠금을 할당하는 방식**을 말합니다. 공`정한 잠금 메커니즘`은 대기 중인 스레드들에게 **순차적이고 균등한 기회**를 제공하여 모든 스레드가 잠금을 획득할 수 있는 기회를 보장합니다.

Java의 **`ReentrantLock`** 클래스는 공정성을 선택할 수 있는 옵션을 제공합니다. 생성자에서 `true`를 전달하여 공정한 잠금을 활성화할 수 있다.

### 공정성

- 공정한 락으로 생성된 경우 **스레드는 도착 순서 정책을 사용하**여 진입하는데 현재 보유 중인 락이 해제될 때 **가장 오래 기다린 단일 쓰기 스레드가** 쓰기 락을 할당받거나 모든 대기하는 쓰기 스레드보다 **더 오래 기다린 읽기 스레드 그룹**이 있는 경우 해당 그룹이 읽기 락을 할당받게 된다
- 공**정한 읽기 락(재진입이 아닌 경우)을 획득**하려는 스레드는 쓰기 락이 보유 중이거나 대기 중인 쓰기 스레드가 있는 경우 차단되며 가장 오래 대기 중인 쓰기 스레드가 쓰기 락을 획득하고 해제한 후에 읽기 락을 획득한다
- 물론 대기 중인 쓰기 스레드가 대기를 포기하고 쓰기 락이 해제되어 읽기 락이 가능한 상태가 되면 해당 읽기 스레드들이 읽기 락을 할당받게 된다
- **공정한 쓰기 락(재진입이 아닌 경우)을 획득**하려는 스레드는 읽기 락과 쓰기 락 모두 대기하는 스레드가 없을 경우 락을 획득하고 그 외에는 차단된다
- 공정성 락은 성능은 감수하더라도 기아상태(Starvation) 을 방지해야 하는 상황이 꼭 필요할 경우 좋은 해결책이 될 수 있다
- ReentrantLock.tryLock() 메서드는 공정성을 따르지 않고 대기 중인 스레드와 관계없이 락을 즉시 획득하며 ReentrantLock.tryLock(timeout, TimeUnit) 은 공정성을 따른다

### 불 공정성

- 불 공정한 락으로 생성된 경우 경쟁 상황에서 읽기 및 쓰기 락에 대한 진입 순서는 정해지지 않으며 하나 이상의 읽기 또는 쓰기 스레드를 무기한으로 연기할 수 있으나 일반적으로 공정한 락보다 더 높은 처리량을 가진다.
- 불 공정성은 락을 획득하려는 시점에 락이 사용 중이라면 대기열에 들어가게 되고 락이 해제되었다면 대기열에 대기중인 스레드를 건너뛰고 락을 획득하게 되는 정책이다.
- 대부분의 경우 공정하게 처리해서 얻는 장점보다 `불공정하게 처리해서 얻는 성능상 이점이 더 크다.` 왜냐하면 락을 사용하고자 하는 스레드가 있을 때 바로 획득하게 하는 것이 대기 중인 스레드를 찾아 락을 획득하도록 처리하는 시간보다 더 빠르기 때문이다.
  
스레드 1번이 어떤 자원에 대한 락을 획득하여 작업중이고 대기 큐에는 스레드2, 스레드3, 스레드4 번이 있다고 가정해보자.  
  
이때 스레드1번이 모든 작업을 완료하고 락을 해제했을때 이 시점에 스레드 5번이 접근하여 자원에 대한 락을 획득할 수 있다. 이러한 방식을 불공정하다고 말한다.(대기하는 스레드의 순서와 상관이 없다.)

### 예시

```java
ReentrantLock fairLock = new ReentrantLock(true);  // 공정한 잠금
ReentrantLock unfairLock = new ReentrantLock(false); // 비공정한 잠금
```

## **ReentrantReadWriteLock** **재 진입 정책**

`ReentrantReadWriteLock`은 Java의 **`java.util.concurrent.locks`** 패키지에 있는 클래스로, 재진입(reentrant) 정책을 지원 한다. 이 정책은 같은 스레드가 이미 획득한 잠금을 반복해서 획득할 수 있도록 허용하는 것을 의미 한다. 이는 특히 재귀 호출이나 반복 로직에서 유용하며, 교착 상태(deadlock)를 방지하는 데 도움이 된다.

이 락은 ReentrantLock 과 같이 읽기 및 쓰기 락을 다시 획득할 수 있도록 재 진입을 허용하며 쓰기 락을 보유하고 있는 스레드가 모든 쓰기 락을 해제하기 전까지는 재진입이 아닌 (Non-reentrant) 읽기 스레드를 허용하지 않는다.  
  
**쓰기 스레드는 읽기 락을 획득할 수 있지만 읽기 스레드가 쓰기 락을 획득하려고 하면 실패하게 된다.** 쓰기 락을 보유한 스레드가 읽기 락 아래에서 읽기를 수행하는 메서드 또는 콜백 호출 시 재 진입이 유용할 수 있다.

- **락 다운그레이드** (Lock Downgrade)
    - 재 진입성은 쓰기 락에서 읽기 락으로 다운그레이드할 수 있게 해 준다
    - **이를 위해 쓰기 락을 획득하고 그런 다음 읽기 락을 획득하고 마지막으로 쓰기 락을 해제한다**
- **락 업그레이드** (Lock Upgrade)
    - **읽기 락에서 쓰기 락으로 업그레이드하는 것은 불가능**하다
    - 읽기 락은 여러 스레드가 동시에 보유할 수 있기 때문에 **업그레이드가 허용되지 않는다**
  
>  쓰기 락을 획득하면 다른 스레드는 어떤 형태로든 락을 획득할 수 없지만 읽기 락을 사용하면 원하는 경우 다른 모든 스레드가 읽기 락을 획득 할 수 있다.  
>   
> 여기서 락을 `Downgrade` 한다는 것은 쓰기 락을 보유한 상태에서 릭기 락을 획득한 다음 쓰기락을 해제하여 읽기 락만 유지하도록 전환할 수 있음을 의미한다.  
>   
> 예를 들어 매우 중요한 작업은 쓰기 락으로 시작해서 상호배제를 구현하고 중요 작업을 마친 후에 동시적인 읽기 접근을 허용하는 읽기 락 스레드를 가질 수 있다.

### **재진입 정책의 특징**

1. **스레드가 같은 잠금을 여러 번 획득 가능**: 동일한 스레드가 이미 보유 중인 잠금(읽기 또는 쓰기)을 추가로 획득할 수 있습니다. 이 경우 잠금의 보유 횟수가 증가합니다.
2. **스레드가 잠금을 해제해야만 다른 스레드 접근 가능**: 잠금을 여러 번 획득한 스레드는 그만큼 잠금을 해제해야만 다른 스레드가 해당 잠금을 획득할 수 있습니다.
3. **재진입 가능한 쓰기 잠금**: 쓰기 잠금을 보유한 스레드는 추가적인 쓰기 잠금 요청에서 블록되지 않습니다. 해당 스레드는 이미 쓰기 잠금을 보유하고 있으므로, 쓰기 잠금을 추가로 획득할 수 있습니다.
4. **재진입 가능한 읽기 잠금**: 읽기 잠금도 동일한 원리로 작동합니다. 한 스레드가 읽기 잠금을 보유하고 있을 때, 같은 스레드는 추가적인 읽기 잠금을 획득할 수 있습니다.


### **예시**

```java
import java.util.concurrent.locks.ReentrantReadWriteLock;

public static void main(String[] args) {
    ReentrantReadWriteLock.WriteLock writeLock = new ReentrantReadWriteLock().writeLock();
    ReentrantReadWriteLock.ReadLock readLock = new ReentrantReadWriteLock().readLock();
    
    writeLock.lock(); //상호배재
    System.out.println("쓰기 락 획득!"); // 임계영역 데이터
    
    // 다운 그레드: 쓰기 락을 읽기 락으로 다운그레이드
    readLock.lock();
    System.out.println("다운그레이드 (쓰기 락 -> 읽기 락)");
    
    writeLock.unlock();
    // 읽기락 사용 로직... 쓰기 락을 해제 하였기 때문에 여러 스레드가 락을 획득 가능
    
    readLock.unlock();
}

```
**`자바는 쓰기 락에서 읽기 락으로의 재진입은 허용한다.`**
  
## Condition
Java에서 `Condition`은 **`java.util.concurrent.locks`** 패키지에 있는 인터페이스로, **`Object`** 클래스의 **`wait()`**, **`notify()`**, 그리고 **`notifyAll()`** 메소드에 대한 확장된 형태의 제어를 제공 한다. `Condition`은 특정 `Lock`과 연관되어 있으며, 더 세분화된 스레드 대기/통지 제어를 가능하게 합니다.

Condition 은 **조건 변수 또는 조건 큐**로 알려진 객체로서 **Lock 과 결합**하여 객체 당 여러 개의 Wait Queue 을 가지는 효과를 제공한다 Lock 이 synchronized 메서드와 문장의 사용을 대체하는 것처럼 Condition은 **Object 모니터 메서드 (wait, notify and notifyAll) 의 사용을 대체**하며 Lock 에 바인딩된다.  
  
Condition 은 한 스레드가 다른 스레드로부터 어떤 상태 조건이 참이 될 수 있다는 통지를 받을 때까지 실행을 중단하도록 하는 수단을 제공한다. Condition 의 가장 중요한 특성은 **락을 원자적으로 해제**하고 현재 스레드를 중단하는 것이며 이는 Object.wait() 메서드와 동일하게 동작한다.

| Java `Object` Methods | `ReentrantLock` Methods |
|-----------------------|-------------------------|
| `synchronized(object){}` | `lock.lock()`, `lock.unlock()` |
| `object.wait()` | `condition.await()` |
| `object.notify()` | `condition.signal()` |
| `object.notifyAll()` | `condition.signalAll()` |
  
### 예제
```java
class SharedData{
    private boolean hasItem = false;
    
    public void consume() throws InterruptedException {
        synchronized (this) {
            while (!hasItem) wait();
            hasItem = false;
        }
    }
    
    public void produce() throws InterruptedException {
        synchronized (this) {
            hasItem = true;
            notify(); //notifyAll(); 
        }
    }
    
}
```

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SharedData {
    private boolean hasItem = false;
    private static final Lock lock = new ReentrantLock();
    private static final Condition con = lock.newCondition();

    public void consume() throws InterruptedException {
        try {
            lock.lock();
            while (!hasItem) con.await();
            hasItem = false;
        }finally {
            lock.unlock();
        }
    }

    public void produce() throws InterruptedException {
        try {
            lock.lock();
            hasItem = true;
            con.signal(); //con.signalAll();
        }finally {
            lock.unlock();
        }
    }

}
```

### **1. 일반적인 Lock 사용 예제**

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Counter {
    private final Lock lock = new ReentrantLock();
    private int count = 0;

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }

    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}

```

이 예제에서 **`Counter`** 클래스는 **`increment`** 메소드와 **`getCount`** 메소드를 통해 카운터를 관리합니다. `Lock`은 동시에 하나의 스레드만이 카운터를 증가시킬 수 있도록 보장합니다.

### **2. Condition과 함께 사용하는 Lock 예제**

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class BoundedBuffer {
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();
    private final int[] items = new int[100];
    private int putptr, takeptr, count;

    public void put(int x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                notFull.await();  // 대기: 버퍼가 가득 찼을 때
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal();  // 알림: 버퍼에 공간이 생겼을 때
        } finally {
            lock.unlock();
        }
    }

    public int take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await();  // 대기: 버퍼가 비었을 때
            int x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal();  // 알림: 버퍼에 아이템이 추가되었을 때
            return x;
        } finally {
            lock.unlock();
        }
    }
}

```

이 예제에서 **`BoundedBuffer`** 클래스는 고정된 크기의 버퍼를 관리합니다. **`put`** 메소드는 버퍼에 아이템을 추가하고, **`take`** 메소드는 버퍼에서 아이템을 가져옵니다.  
  
**`Condition`** 객체 `notFull`과 `notEmpty`는 버퍼의 상태에 따라 대기 및 통지를 관리합니다.

### **차이점**

- **대기 조건의 세밀한 제어**: **`Condition`**을 사용하면 특정 조건(예: 버퍼 가득 참, 버퍼 비어 있음)에 따라 스레드를 대기시키고, 해당 조건이 만족될 때 스레드를 깨울 수 있습니다. 일반 **`Lock`**만 사용하는 경우에는 이러한 세밀한 조건 기반의 제어가 불가능합니다.
- **여러 대기 조건**: **`Condition`**을 사용하면 여러 대기 조건을 다룰 수 있습니다. 예를 들어, 하나의 **`Lock`**에 대해 "버퍼 가득 참"과 "버퍼 비어 있음"을 나타내는 두 개의 다른 **`Condition`** 객체를 사용할 수 있습니다.
- **유연성**: **`Condition`**은 **`Object`**의 **`wait()`**와 **`notify()`**에 비해 더 유연한 대기/통지 메커니즘을 제공합니다. 여러 조건을 사용하여 서로 다른 상황에서 대기하거나 통지할 수 있습니다.

### Condition 사용의 전반적인 흐름

스레드 T1과 T2가 있을때 다음과 같은 흐름을 가진다.

1. **Lock 획득**
    - 스레드 T1은 **`lock()`** 메소드를 호출하여 잠금을 획득합니다.
    - 이로 인해 T1은 임계 영역(자원에 대한 접근 권한이 있는 코드 영역)에 진입하여 작업을 수행할 수 있습니다.
    - 다른 스레드들(T2, T3)은 이 잠금이 해제될 때까지 대기 큐에서 대기합니다.
2. **Condition 대기**
    - 스레드 T1은 특정 조건이 만족되지 않는 것을 확인하고 **`Condition`** 객체의 **`await()`** 메소드를 호출하여 대기 상태로 들어갑니다.
    - T1은 **`Condition1 Queue`**로 이동하여, 이 조건이 신호를 받을 때까지 대기합니다.
    - 이 때, 잠금(Lock)은 자동으로 해제되고, 다른 스레드들이 잠금을 획득할 수 있는 기회를 갖게 됩니다.
3. **Lock 재획득 및 조건 충족**
    - 대기 큐에서 기다리던 스레드 T2가 잠금을 획득하고 임계 영역에 진입하여 작업을 수행합니다.
    - T2의 작업으로 인해 **`Condition1`**의 대기 조건이 충족되면, T2는 **`Condition1`**에 대해 **`signal()`** 또는 **`signalAll()`**을 호출하여 대기 중인 스레드(T1, T6) 중 하나 또는 모두를 깨울 수 있습니다.
4. **Condition 알림 및 잠금 재획득**
    - **`Condition1`**의 **`signal()`** 호출로 인해 T1이 깨어나 잠금을 재획득하기 위해 대기합니다.
    - T1이 다시 잠금을 획득하면, 이전에 중단되었던 작업을 계속 수행할 수 있습니다.
5. **다른 Condition 대기 및 알림**
    - 동시에 다른 스레드들(T4, T5)은 **`Condition2`**를 사용하여 다른 조건에 대해 대기하고 있을 수 있습니다.
    - 이 스레드들도 해당 조건이 충족되면 **`Condition2`**의 **`signal()`** 호출로 인해 깨어날 수 있습니다.
6. **Unlock**
    - 스레드 T1(또는 T6)이 작업을 완료하고 **`unlock()`**을 호출하면, 잠금이 해제됩니다.
    - 이로 인해 다른 스레드들(T2, T3 또는 다른 대기 중인 스레드들)이 잠금을 획득할 수 있는 기회를 갖게 됩니다.

### **주요 메소드**

1. **await()**
    - **설명**: 현재 스레드를 대기 상태로 만듭니다. 스레드는 다른 스레드가 **`signal()`** 또는 `signalAll()`을 호출할 때까지 대기합니다.
      - 현재 스레드가 다음 네가지 중 하나가 바생할 때가지 대기하게 되며 이 Condition과 관련된 락은 원자적으로 해제된다.
        - 다른 스레드가 이 Conditon에 대해 signal() 호출한경우
        - 다른 스레드가 이 Conditon에 대해 signalAll() 호출한경우
        - 다른 스레드가 현재 스레드를 인터럽트하고 스레드 중단의 인터럽션을 지원 하는 경우
        - 의미 없는 깨어남(squrious wakeup) 이 발생함
    - **유사**: **`Object.wait()`**
2. **signal()**
    - **설명**: 대기 중인 스레드 중 하나를 깨웁니다. **`await()`**을 호출하여 대기 중인 스레드 중 하나를 선택해 깨우게 됩니다.
    - **유사**: **`Object.notify()`**
3. **signalAll()**
    - **설명**: 대기 중인 모든 스레드를 깨웁니다. 이 메소드는 **`await()`**을 호출하여 대기 중인 모든 스레드를 깨우게 됩니다.
    - **유사**: **`Object.notifyAll()`**

### 주의사항

**signalAll() 보다 signal() 을 활용하라**

- Condition 에서 신호를 알릴 때 signalAll() 보다 signal()을 사용하는 것이 다중 조건을 다루는 더욱 효과적인 방법일 수 있다
- 한 개의 Lock 객체에서 생성한 여러 개의 Condition은 특정한 조건에 따라 스레드를 구분해서 관리함으로 미세한 제어를 가능하게 해준다
- 여러 개의 조건이 있을 때 모든 스레드를 동시에 깨우면 경쟁 상태가 발생할 수 있으나 Condition 을 여러 개 사용하면 각각의 조건에 대해 필요한 스레드만 깨울 수 있다

**Condition 사용 시 주의 사항**

- Condition 객체는 단순한 일반 객체로서 synchronized 문에서 대상으로 사용하거나, 자체 모니터 wait 및 notify 메서드를 호출할 수 있다
- Condition 객체의 모니터를 사용하는 것은 해당 Condition 과 연결된 Lock 을 사용하거나 await() 및 signal() 메서드를 사용하는 것과 특정한 관계가 없다
- 혼동을 피하기 위해 Condition 인스턴스를 이러한 방식으로 사용하지 않는 것이 좋다
  
