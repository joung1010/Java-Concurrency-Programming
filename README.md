## 자바 동시성 프로그래밍
자바에서 쓰레드는 내부적으로는 운영체제의 도움을 받아 작동하게 된다.  
쓰레드 생성되는 시점에 운영체제가 개입을 해 제어하는 방식으로 동작한다.  
### 동작 방식
1. **쓰레드 생성**: 자바에서 쓰레드를 생성하면, JVM은 이 요청을 운영체제에 전달한다. 운영체제는 이를 수행하고, 자바 쓰레드에 대응하는 운영체제 수준의 쓰레드를 생성.
2. **쓰레드 스케줄링과 관리**: 쓰레드의 실행, 스케줄링(언제 어떤 쓰레드가 실행될지 결정하는 과정)은 운영체제의 책임이다. JVM은 운영체제의 스케줄링 정책을 따르며, 운영체제는 사용 가능한 프로세서 자원을 쓰레드에 할당
3. **사용자 수준 쓰레드와 커널 수준 쓰레드**: 일부 운영체제에서는 사용자 수준 쓰레드(운영체제 커널이 관리하지 않는 쓰레드)와 커널 수준 쓰레드(운영체제 커널에 의해 직접 관리되는 쓰레드)를 지원한다. `자바`는 이러한 구분 없이 **투명하게 쓰레드를 관리**하도록 설계되었습니다.
4. **플랫폼 독립성**: 자바의 플랫폼 독립성으로 인해, 동일한 자바 쓰레드 코드가 다양한 운영체제에서 동일하게 작동할 수 있다. 그러나 쓰레드의 성능과 행동은 운영체제에 따라 다를 수 있다.
5. **JVM과 운영체제의 최적화**: 최신 JVM과 운영체제는 쓰레드 성능을 최적화하기 위해 긴밀하게 협력한다. 예를 들어, 가비지 컬렉션, 쓰레드 풀 관리 등은 JVM과 운영체제 간의 효율적인 상호작용을 통해 이루어진다.
  
이처럼 자바의 쓰레드와 운영체제는 긴밀하게 서로 소통하기 때문에 이 쓰레드를 잘 이해하기 위해서는 그 밑단에 흐르는 운영체제에서 동작하는 기본적인 쓰레드 원리 와 작동원리 및 도시성에 대하여 알 필요가 있다.  
즉, 자바쓰레드가 실행되는 시점에 운영체제의 상태와 쓰레드간의 전환이 발생하는 문제에 대한 처리 방법등 이러한 기본적인 흐름에 대한 이해가 필요하다.  
  
# 프로세스 와 쓰레드
| 프로세스 | 쓰레드 |
| --- | --- |
| 운영체제로부터 자원을 할당 받은 작업 단위 | 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위 |  
## 프로세스
### 프로그램
운영체제에 의해 시스템에 설치되어 있는 파일을 프로그램이라 말한다.  
예를들어 윈도우의 `.exe` 파일이나 Mac의 `.dmg` 파일과 같은 컴퓨터에서 실행할 수 있는 파일을 통칭한다.  
즉 아직 **파일을 실행하지 않는 상태**를 말한다.  
  
### 프로세스
프로그램이 실행하지 않는 파일을 말한다면 이를 **동작시켜서 프로그램이 돌아가고 있는 상태**를 프로세스라고 한다.  
즉, 프로세스는 프로그램의 실제 실행을 의미하며 이를 실행함으로써 프로그램의 **데이터들이 메모리에 올라와 cpu를 할당받고 명령을 수행하고 있는 상태** 이다.  

| 프로그램 | 프로세스 |
| --- | --- |
| 어떤 작업을 하기 위해 실행할 수 있는 파일 | 실행되어 작업중인 컴퓨터 프로그램 |
| 파일이 저장 장치에 있지만 메모리에는 올라가 있지 않은 정적인 상태 | 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태 |
| 코드 덩어리 | 코드 실행시킨 것 |  
  
## 쓰레드
오늘날 우리가 컴퓨터에서 파일을 다운로드 받으면 다른 작업을 당연하게 할 수 있지만 예전에는 파일을 다운로드 받으면 이 작업이 종료될때까지 기다려야 다음 작업을 할 수 있었다. 그렇다고 동일한 프로그램을 여러개의 프로세스로 만들게 되면 메모리와 CPU의 자원이 중복되게 되는 문제점이 발생한다. 이러한 한계를 극복하고자 나온 개념이 쓰레드이다.  
  
즉, **하나의 프로세스 내에서 동시에 진행되는 작업의 갈래, 흐름의 단위를 말한다.** 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다.
  
## 프로세스의 메모리 구조
- **코드 영역(Code/ Text)**: 프로그래머가 작성한 프로그램 함수들의 코드가 CPU가 해석 가능한 기계어 형태로 저장
- **데이터 영역(Data)**: 코드가 실행되면서 사용하는 전역 변수나 각종 데이터들이 모여있다. 데이터영역은 .data ,.rodata, .bss 영역으로 세분화 된다.
    - .data: 전역변수, 또는 static 변수 등 프로그램이 사용하는 데이터를 저장
    - .BSS : 초기값 없는 전역 변수, static 변수가 저장
    - .rodata: const 같은 상수 키워드 선언 된 변수나 문자열 상수가 저장
- **스택 영역(Stack):** 지역 변수와 같은 호출한 함수가 종료되면 되돌아올 임시적인 자료를 저장하는 독립적인 공간. Stack은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 만일 stack 영역을 초과하면 stack overflow 에러가 발생한다.
- **힙 영역(Heap):** 생성자, 인스턴스와 같은 동적으로 할당되는 데이터들을 위해 존재하는 공간이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
  
운영 체제는 프로세스마다 위처럼 각각 독립적인 메모리 영역을 할당해 주게 된다. 이때 코드 영역과 데이터 영역은 크기가 정해져 있지만, **스택 영역과 힙영역은 실행 되는 동안 크기가 늘었다가 줄었다가 하는 동적 영역**이다.  
이렇게 프로세스 마다 독립된 메모리 영역이 할당되기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행 할 수 있다. 기본적으로 프로세스간의 정보 공유가 완전히 불가능한 것은 아닌데 IPC(Inter-Process Communication) , LPC(Local inter-Process Communication), 별도로 공유 메모리를 만들어서 정보를 주고받도록 설정하면 공유가 가능하다.  
  
## 쓰레드의 자원 공유
 쓰레드는 프로세스가 운영체제로부터 할당 받은 자원을 이용하는 실행,흐름 단위로서 하나의 프로세스는 하나 이상의 스레드를 갖는다. 스레드가 여러개 있으면 우리가 브라우저에서 파일을 다운로드 받으면서 동시에 웹서핑을 할 수 있게 해준다.  
이 쓰레드는 **프로세스의 자원을 공유** 하면서 실행 흐름의 일부가 되기때문에 **동시 작업이 가능**한 것이다. 이 프로세스의 자원공유란 프로세스 내에서 각 필요한 스택(함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수 내에서 선언하는 변수 등을 저장하는 공간)만 할당 받고 코드,데이타,힙 영역을 공유한다.  
이때 스레드 간 메모리 스택 영역에는 서로 접근할 수 없으므로 스레드는 독립적인 실행 흐름을 가질 수 있게되어 독립적인 함수 호출이 가능해 진다.  
  
# CPU
## CPU
CPU (Central Processing Unit)는 컴퓨터의 주요 구성 요소로, **컴퓨터의 모든 명령을 처리**하는 데 필요한 계산 및 제어 작업을 수행합니다. CPU는 **컴퓨터의 '두뇌'**로 간주되며, 모든 프로그램 실행, 데이터 처리, 명령 실행 등을 담당합니다. CPU의 성능은 컴퓨터의 전반적인 속도와 성능에 중요한 영향을 미칩니다.
  
### 멀티 코어와 쓰레드
컴퓨터 부품을 검색해보면 CPU 4코어 12쓰레드, 8코어 4쓰레드 이런 단어를 본적이 있을 것이다. CPU 한개는 여러 코어를 가질 수 있다.  
이 코어는 말그대로 CPU 코어 유닛인데, 명령어를 메모리에서 뽑아 해석하고 실행하는 유닛이 물리적으로 4개가 있으면 4코어, 8개가 있으면 8코어라고 불린다.  
이때 4코어 2쓰레드는 물리적인 코어 하나가 쓰레드 2개 이상을 동시에 실행 가능하다는 의미이고, 운영체제는 8개의 작업(4코어*2쓰레드)을 동시에 처리할 수 있다는 의미이기도 한다. 이를 하이퍼스레딩(Hyper-Threading) 기술이라 말한다.  

# CPU 작업의 병렬성(Parallelism) 과 동시성(Concurrency)
## 동시성
동시성은 둘 이상의 작업이 동시에 실행되는 것을 의미하는데 이는 **CPU가 한번에 많은 일을 처리하는 것**에 중점을 두고 있다. 즉, 많은 작업들을 아주 빠른 시간으로 교체하면서 전체 작업을 수행한다. 예를 들어 1개의 코어가 있고 여러개의 작업이 존재한다면 CPU는 프로세스들을 번걸아가며 조금씩 아주 빠르게 처리함으로써 마치 프로그램이 동시에 실행되는 것처럼 보인다.
이때 작업들을 번갈아가면서 실행하기 때문아 아주 잘게 나누어 조금씩 작업을 수행하고 다음 작업으로 넘어가는 식으로 동작한다. 이렇게 하는 이유는 여러 작업을 동시에 처리하는 것처럼 보이게 만들어 사용자에게 더 빠른 반응성을 제공하기 위해서이다.  
진행중인 작업들을 A -> B -> C -> D -> A 이런식으로 번걸아 바꾸는 작업을 **Context Switching** 이라고 부른다.  
이 도싱성 작업은 처리를 빠르게 하기 위한 목적이 아닌 CPU를 효율적으로 사용하는 것에 더 중점을 두고 있다. 따라서 이 동시성 작업에 대한 처리 방식을 어떤식으로 진행할 것인지 고려해야하며 동시성으로 작업해햐할 수가 CPU 코어 수 보다 많을 경우 해당되며 동시성이 없으면 작업을 순차적으로 진행한다.  
  
## 병렬성
병렬성은 직관적으로 명령어를 메모리에 뽑아 해석하고 실행하는 반도체 유닛인 **코어에 맞춰 여러개의 프로세스, 스레드를 돌려 병렬로 작업을 동시 수행**하는 것을 말한다. 이 병렬성은 **CPU가 동시에 많은 일을 수행하는 것에 중점**을 두고 CPU가 놀지않고 바쁘게 동작한다. 따라서 병렬성은 런타임에 동시에 물리적으로 작업을 실행하는 것이며 여러 컴퓨팅 리소스가 있는 하드웨어가 필요함로 한 개의 코어에서는 절대 병렬성이 구현될 수 없다.  
이 병렬성은 동시성의 하위 개념으로 여러 쓰레드로 작업을 분리하여 그 쓰레드를 CPU에 적절히 분배하여 동시적으로 실행하도록 하는 것이므로 병렬 작업해야할 수가 CPU 코어 수보다 같거나 적을 경우 효율이 가장 좋다.  
  
# 프로세스,스레드의 생명주기
프로세스와 스레드의 생명주기는 운영 체제의 스케줄링 및 자원 관리와 밀접하게 연관되어 있습니다. 프로세스는 보다 무거운 자원 사용을 하며, 스레드는 같은 프로세스 내에서 더 가볍게 자원을 공유한다.  
  
## 프로세스 스케줄링
프로세스 스케줄링(Process Scheduling)은 운영체제에서 CPU를 사용할 수 있는 프로세스를 선택하고, CPU를 할당하는 작업을 말한다.이는 시스템의 효율성, 반응성, 공정성을 극대화하는 데 중요한 역할을 하고 다양한 스케줄링 알고리즘이 있으며, 각각의 사용 환경과 요구 사항에 따라 적합한 알고리즘이 선택된다.  

프로세스 스케줄링은 프로세스의 우선순위, 작업량등을 고려하여 효율적으로 배치하고 이를 통해 운영체제는 CPU를 효율적으로 사용하며 시스템 전반적인 성능을 향상시킨다. 이는 멀티 태스킹 작업을 만들어내는 데에 있어서 핵심적인 부분이다.  
  
대표적으로는 해당 알고리즘 등이 있다. 
1. FCFS (First-Come, First-Served)  
   특징: 가장 간단한 스케줄링 알고리즘으로, 먼저 도착한 프로세스가 먼저 서비스를 받습니다.  
   장점: 구현이 쉽고, 공정합니다.  
   단점: 짧은 작업이 긴 작업 뒤에 오면 대기 시간이 길어지는 '호위 효과(Convoy Effect)' 발생 가능.
2. SJF (Shortest-Job-First)
   특징: 예상 실행 시간이 가장 짧은 프로세스를 먼저 실행합니다.  
   장점: 평균 대기 시간을 최소화할 수 있습니다.  
   단점: 실행 시간을 미리 알아야 하며, 긴 작업은 무한정 대기할 수 있습니다 (기아 현상).  
3. 우선순위 스케줄링 (Priority Scheduling)  
   특징: 각 프로세스에 우선순위를 부여하고, 높은 우선순위의 프로세스를 먼저 실행합니다.  
   장점: 중요한 작업을 빠르게 처리할 수 있습니다.  
   단점: 낮은 우선순위의 프로세스가 기아 상태에 빠질 수 있습니다.  
4. RR (Round-Robin)  
   특징: 각 프로세스에 동일한 시간 할당량(Time Quantum)을 주고, 순서대로 실행합니다.  
   장점: 모든 프로세스가 공정하게 CPU 시간을 받으며, 반응 시간이 짧습니다.  
   단점: 시간 할당량의 크기에 따라 성능이 크게 달라질 수 있습니다.  
5. 멀티레벨 큐 (Multilevel Queue)  
   특징: 프로세스를 여러 큐로 분류하고, 각 큐에 다른 스케줄링 알고리즘을 적용합니다.  
   장점: 다양한 유형의 프로세스를 효율적으로 관리할 수 있습니다.  
   단점: 큐 사이의 이동 규칙과 각 큐에 대한 스케줄링이 복잡할 수 있습니다.  
  
## 프로세스 상태
프로세스의 상태는 프로세스가 실행되는 동안 변경되는 고유의 상태를 의미 하며 프로세스가 생성되어 실행하기 까지 프로세스는 여러가지의 상태를 갖게 되고, 상태의 변화에 따라 프로세스가 동작 되는 것이다.  
1. **생성 (Creation)**: 프로세스가 생성되며, 이 때 필요한 자원과 메모리가 할당됩니다.
2. **준비 (Ready)**: 프로세스가 CPU에서 실행될 준비가 되어 대기합니다.
3. **실행 (Running)**: 프로세스가 CPU를 할당받아 명령을 실행합니다.
4. **대기 (Waiting)**: 프로세스가 특정 이벤트나 자원을 기다리는 동안 일시적으로 중지됩니다.
5. **종료 (Termination)**: 프로세스가 실행을 완료하고 모든 자원이 해제됩니다.
  
## 프로세스 상태 전이
프로세스의 상태전이(Process State Transition)는 프로세스가 생명주기 동안 거치는 다양한 상태와 그 상태들 간의 전환을 나타낸다. 일반적으로 프로세스는 다음과 같은 상태들을 거진다.  

1. 신규 (New): 프로세스가 생성되고 초기화되는 단계입니다.

2. 준비 (Ready): 프로세스가 CPU에서 실행될 준비가 되어 있으며, 실행을 기다리는 상태입니다.

3. 실행 (Running): 프로세스가 CPU를 할당받아 명령어들을 실행하는 상태입니다.

4. 대기 (Waiting): 프로세스가 I/O 작업이나 특정 이벤트의 완료를 기다리는 상태입니다.

5. 종료 (Terminated): 프로세스가 실행을 완료하고 시스템에서 제거되는 상태입니다.

### 상태전이
1. 신규 -> 준비: 프로세스가 생성되어 실행을 위해 준비됩니다.

2. 준비 -> 실행: 스케줄러가 프로세스를 선택하여 CPU를 할당합니다.

3. 실행 -> 대기: 프로세스가 I/O 작업을 요청하거나 특정 이벤트를 기다려야 할 때입니다.

4. 대기 -> 준비: I/O 작업이 완료되거나 기다리던 이벤트가 발생하여 다시 CPU에서 실행될 준비가 됩니다.

5. 실행 -> 준비: 선점형 스케줄링에서, 프로세스가 CPU 할당 시간을 다 쓰거나 더 높은 우선순위의 프로세스가 준비 상태가 되었을 때 발생합니다.

6. 실행 -> 종료: 프로세스가 모든 작업을 완료하고 시스템에서 제거됩니다.
  
## 스레드 생명주기
스레드는 프로세스 내에서 실행되는 실행 단위이다. 스레드의 생명주기는 다음과 같다:

1. 생성 (New): 스레드가 생성되고 초기화됩니다.
2. 준비 (Ready): 스레드가 실행을 위해 준비되며 CPU 할당을 기다립니다.
3. 실행 (Running): 스레드가 CPU를 할당받아 실행됩니다.
4. 대기 (Blocked): 스레드가 I/O 작업과 같은 이유로 일시적으로 중지됩니다.
5. 종료 (Terminated): 스레드가 작업을 완료하고 종료됩니다.  

프로세스와 스레드의 생명주기는 운영 체제의 스케줄링 및 자원 관리와 밀접하게 연관되어 있다. 프로세스는 보다 무거운 자원 사용을 하며, 스레드는 같은 프로세스 내에서 더 가볍게 자원을 공유한다.  
  
# 프로세스 컨텍스트 스위칭
컨텍스트 스위칭(Context Switching)은 운영 체제에서 CPU가 하나의 프로세스 또는 스레드에서 다른 프로세스 또는 스레드로 전환하는 과정을 말한다.  
  
CPU는 한번에 하나의 프로세스만 실행할 수 있으므로, 여러개의 프로세스를 번갈아가며 실행하여 CPU 활용률을 높이기 위해 컨텍스트 스위칭이 필요하다.  
  
컨텍스트 스위칭은 **동작중인 프로세스가 대기를 하면서 해당 프로세스의 상태를 보관**하고, 대기하고 있던 **다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업**을 말한다. 이러한 컨텍스트 스위칭이 일어날때 다음번 프로세스는 스케줄러가 결정하게 된다.  
1. **현재 프로세스의 상태 저장**: 현재 실행 중인 프로세스 또는 스레드의 상태(컨텍스트)를 저장합니다. 컨텍스트에는 프로그램 카운터, 레지스터 값, 메모리 상태 등이 포함됩니다.

2. **다음 프로세스의 상태 복원**: 다음에 실행할 프로세스 또는 스레드의 컨텍스트를 복원합니다. 이를 통해 이전에 중단된 지점부터 실행을 계속할 수 있습니다.
  
## PCB( Process Control Block)
PCB(Process Control Block)는 운영 체제에서 프로세스를 관리하기 위해 사용하는 중요한 데이터 구조(프로세스의 상태정보등)이다.프로세스를 컨텍스트 스위칭 할때 기존 프로세스의 상태를 어딘가에 저장해 둬야 다음에 똑같은 작업을 이어 서 할 수 있을 것이고, 새로 해야 할 작업의 상태 또한 알아야 어디서부터 다시 작업을 시작할지 결졍할 수 있을 것이다.  

즉, PCB는 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보 저장하는 **임시저장소**인 것이고 컨텍스트 스위칭은 CPU가 프로세스 간 PCB(Process Control Block) 정보를 교체하고 기존에 저장했던 PCB(Process Control Block)를 비우는 일련의 과정이라고 불 수 있다.  
  
**프로세스가 생성되면 메모리에 해당 프로세스의 PCB가 함께 생성되고, 종료 시 삭제**된다. 따라서 운영체제는 PCB에 담긴 프로세스 고유 정보를 통해 프로세스를 관리하고, 프로세스의 실행 상태를 파악하고, 우선순위를 조정하며, 스케줄링을 수행하고, 다른 프로세스와의 동기화를 제어한다.  
### PCB의 주요 구성 요소
* **프로세스 식별자 (Process Identifier, PID)**: 각 프로세스를 구별하는 고유한 식별자입니다.

* **프로세스 상태 (Process State)**: 프로세스가 현재 어떤 상태에 있는지를 나타냅니다 (예: 준비, 실행, 대기).

* **프로그램 카운터 (Program Counter)**: 프로세스가 다음에 어떤 명령어를 실행해야 하는지를 가리키는 카운터입니다.

* **레지스터 세트 (Register Set)**: 프로세스 실행 중 필요한 레지스터들의 현재 값을 저장합니다.

* **메모리 관리 정보 (Memory Management Information)**: 프로세스의 주소 공간, 페이지 테이블, 세그먼트 테이블 등 메모리 관련 정보를 포함합니다.

* **계정 정보 (Accounting Information)**: 프로세스 실행 시간, 사용된 CPU 시간, 프로세스가 시작된 시간 등을 기록합니다.

* **I/O 상태 정보 (I/O Status Information)**: 프로세스에 할당된 I/O 장치 목록과 열린 파일 목록 등이 포함됩니다.  
  
> Register란?  
레지스터는 컴퓨터의 중앙 처리 장치(CPU) 내부에 있는 매우 빠른 메모리 단위입니다. 이들은 CPU가 수행하는 연산에 필요한 데이터나 연산 결과를 일시적으로 저장하는 역할을 합니다. 레지스터는 컴퓨터의 데이터 처리 속도에 큰 영향을 미치는 중요한 구성 요소입니다.  
>  
> PCB와 레지스터  
PCB(Process Control Block) 내의 레지스터 세트는 특정 프로세스가 중단될 때 그 프로세스의 레지스터 상태를 저장합니다. 컨텍스트 스위칭 시, 이 정보는 해당 프로세스가 재개될 때 CPU에 다시 로드되어 프로세스가 중단된 지점부터 연산을 계속할 수 있도록 합니다. 이는 멀티태스킹 환경에서 각 프로세스의 실행 상태를 유지하는 데 필수적입니다.
  
## Context Switching 과정
![switching.png](src%2Fresources%2Fstatic%2Fimg%2Fswitching.png)  
해당 이미지는 두 개의 프로세스 P1과 P2가 CPU를 공유하며 실행되는 컨텍스트 스위칭 과정을 도식화한 것이다.  
1. **프로세스 P1 실행 중**: 초기 상태에서 프로세스 P1이 CPU를 사용하여 실행 중입니다.
2. **인터럽트 또는 시스템 콜 발생**: 프로세스 P1의 실행 중에 인터럽트 또는 시스템 콜이 발생합니다. 이는 CPU가 다른 작업을 수행해야 함을 의미하며, 이 때문에 프로세스 P1의 실행이 중단됩니다.
3. **프로세스 P1 상태 저장**: CPU는 프로세스 P1의 현재 상태(레지스터 값, 프로그램 카운터 등)를 프로세스 P1의 PCB(PCB1)에 저장합니다. 이로써 프로세스 P1은 중단된 지점에서 나중에 재개할 수 있습니다.
4. **프로세스 P2 상태 복원**: 이어서 CPU는 프로세스 P2의 이전 상태를 PCB(PCB2)에서 가져와 CPU에 로드합니다. 프로세스 P2는 이전에 중단됐던 지점부터 실행을 재개합니다.
5. **프로세스 P2 실행**: CPU는 이제 프로세스 P2를 실행 상태로 전환하고, 프로세스 P1은 대기 상태(Idle)로 전환됩니다.
6. **두 번째 인터럽트 또는 시스템 콜 발생**: 프로세스 P2가 실행 중일 때 또 다른 인터럽트 또는 시스템 콜이 발생합니다.
7. **프로세스 P2 상태 저장**: 프로세스 P2의 현재 상태는 PCB2에 저장됩니다.
8. **프로세스 P1 상태 복원**: 다시 프로세스 P1의 상태가 PCB1에서 가져와 CPU에 로드되어 프로세스 P1이 실행을 재개할 수 있도록 합니다.
  
## Context Switching Overhead
컨텍스트 스위칭 오버헤드(Context Switching Overhead)는 운영 체제가 하나의 프로세스에서 다른 프로세스로 전환할 때 발생하는 추가적인 시간 및 자원 소모를 말한다. 이때 전환되는 과정에서 프로세스의 상태, 레지스터 값등이 저장되고 불러오는 등의 작업이 수행되기 때문에 시스템에 많은 부담을 준다.  
  
컨텍스트 스위칭 과정에서 위의 그림에서 P1이 실행 중에 P2의 작업에 대한 실행요청이 왔을때 바로 실행되는 것이 아니라 **대기 상태**에 있다가 실행 되는 것을 확인할 수 있는데 이 **간극이 바로 컨텍스트 스위창 오버헤드 인 것**이다.  
  
즉,오버헤드는 프로세스가 실행 상태에서 대기 상태로 바뀌고, 다시 실행 상태로 돌아올 때 발생하는 일련의 작업들과 관련이 있습니다.  
  
### 오버헤드에 포함되는 주요 작업
1. 레지스터 상태 저장 및 복원
2. 메모리 관리자 업데이트
3. 캐시 초기화 또는 업데이트
4. 보안 및 접근성 업데이트
  
# 스레드 스케줄링
스레드 스케줄링은 프로세스 내의 개별 스레드에 CPU 시간을 할당하는 과정이다.즉, 스레드 스케줄링은 운영체제에서 다중 스레드를 관리하며, CPU를 사용할 수 있는 스레드를 선택하고, CPU를 할당하는 작업을 말한다.  

이는 프로세스 스케줄링과 유사하지만, 스레드는 프로세스보다 더 가벼운 실행 단위이며, 일반적으로 같은 프로세스 내의 스레드들은 일부 자원(예: 메모리)을 공유한다.이 스레드 스케줄링의 주요 목적은 CPU 사용률을 극대화하고, 프로그램의 응답 시간을 최소화하며, 시스템 전반의 처리량을 증가시키는 것이다.  

다만 스레드 스케줄링은 프로세스 스케줄링과 다르게, 하나의 프로세스 내에서 다수의 스레드가 동작하는 형태이기 때문에, 스레드 간의 상호작용과 동기화 문제를 고려해야 한다는 차이점이 존재한다.  
  
## 스레드 컨텍스트 스위치
스레드 컨텍스트 스위칭은 프로세스 컨텍스트 스위칭과 유사한 메커니즘을 가지고 있지만, 주로 같은 프로세스 내의 스레드들 사이에서 일어나며, 비교적 더 가볍다. 이는 같**은 프로세스 내의 스레드들이 코드, 데이터, 힙 영역과 같은 메모리 자원을 공유**하기 때문이다.  

### **스레드 컨텍스트 스위칭 과정**

1. **스레드 상태 저장**: 현재 실행 중인 스레드의 상태(레지스터 세트, 프로그램 카운터 등)를 저장합니다.
2. **CPU 레지스터 변경**: 다음 실행할 스레드의 상태 정보로 CPU의 레지스터를 업데이트합니다.
3. **스택 포인터 변경**: 다음 실행할 스레드의 스택 포인터로 변경하여, 해당 스레드의 스택 프레임에 접근할 수 있도록 합니다.
4. **프로그램 카운터 업데이트**: 프로그램 카운터를 다음 스레드가 계속해서 실행할 코드의 주소로 업데이트합니다.
5. **스레드 상태 복원**: 중단되었던 다른 스레드의 상태를 복원합니다.  

## TCB(Thread Control Block)
PCB 처럼, TCB (Thread Control Block)는 각 스레드마다 운영 체제에서 유지하는 스레드에 대한 정보를 담고 있는 자료 구조이다.TCB는 PCB 블록안에 들어 있다. 스레드가 프로세스 내에 위치한 것 처럼 말이다.  

프로세스의 정보를 저장하는 PCB(Process Control Block)와 유사하게, TCB는 스레드의 상태, 스레드 식별자, 레지스터 세트, 프로그램 카운터, 스택 포인터, 우선순위, 상태 정보 등 스레드 실행에 필요한 모든 정보를 포함하고 있다. TCB도 스레드가 생성될 때 운영 체제에 의해 생성되며, 스레드가 실행을 마치고 소멸될 때 함께 소멸된다.  

스레드 간의 자원 공유와 동기화도 TCB를 사용하여 관리된다. 예를 들어, 뮤텍스(mutual exclusion)나 세마포어(semaphore)와 같은 동기화 기법을 사용할 때, TCB에서 해당 스레드의 뮤텍스나 세마포어 정보를 관리하고, 스레드가 해당 자원에 대한 접근 권한을 획득하거나 반납할 때 TCB의 정보를 업데이트하게 된다.  
1. **뮤텍스 (Mutex)**:
   - 뮤텍스는 "Mutual Exclusion"의 줄임말로, 한 번에 하나의 스레드만 특정 자원에 접근할 수 있도록 합니다.
   - 뮤텍스는 임계 영역(critical section)에 대한 접근을 제어하여, 동시성 문제를 방지합니다.
   - 뮤텍스는 잠금(lock)과 해제(unlock) 메커니즘을 사용하여 자원을 보호합니다.
2. **세마포어 (Semaphore)**:
   - 세마포어는 뮤텍스와 유사하지만, 한 번에 여러 스레드가 자원에 접근할 수 있는 '카운트' 개념을 제공합니다.
   - 세마포어는 특정 자원이 여러 개 있을 때 유용하며, 자원의 사용 가능한 개수를 관리합니다.
   - 세마포어는 신호를 보내 자원을 획득하거나 반납하는 방식으로 작동합니다.
  
# 프로세스 컨텍스트 스위칭 vs 스레드 컨텍스트 스위칭
프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭은 둘 다 운영 체제가 실행 중인 작업 간에 CPU를 전환하는 데 사용하는 메커니즘입니다. 그러나 이 두 스위칭 방식 사이에는 중요한 차이점이 있다.  

1. TCB가 PCB 보다 가볍다
   - **프로세스 컨텍스트 스위칭**은 프로세스 간에 전환할 때 발생하며, 더 많은 시간과 자원을 소모합니다.
   - **스레드 컨텍스트 스위칭**은 같은 프로세스 내의 스레드들 간의 전환에 사용되며, 상대적으로 오버헤드가 적습니다.
2. 캐시 메모리 초기화
   1. 프로세스 컨텍스트 스위칭
      - 프로세스 간에 컨텍스트 스위칭을 할 때, 새로운 프로세스는 다른 메모리 공간을 사용합니다.
      - CPU 캐시에 로드된 데이터는 이전 프로세스의 메모리 주소 공간에 대응되므로, 새 프로세스에는 무효가 됩니다.
      - 결과적으로 캐시 메모리는 초기화되거나 새로운 프로세스의 데이터로 재충전되어야 합니다.
      - 이로 인해 캐시 미스가 증가하고 성능이 저하될 수 있습니다.
   2. 스레드 컨텍스 스위칭
      - 동일 프로세스 내의 스레드들은 메모리 공간을 공유하기 때문에, 캐시에 있는 데이터가 여전히 유효할 수 있습니다.
      - 스레드 간 스위칭 시에 캐시를 초기화할 필요가 없거나, 초기화가 필요한 범위가 매우 제한적입니다.
      - 따라서 스레드 스위칭은 캐시 메모리의 재사용도가 높고, 캐시 효율성이 유지되어 성능 저하가 적습니다.
3. 자원 동기화
   1. 프로세스 컨텍스트 스위칭
      - 프로세스들은 독립적인 메모리 공간을 가지고 있으며, 일반적으로 서로의 자원에 접근하지 않습니다.
      - 자원 동기화의 필요성이 상대적으로 낮고, 프로세스 간 통신을 위해서는 IPC(Inter-Process Communication) 메커니즘이 사용됩니다.
      - 프로세스 간의 자원 공유가 일어날 때는 주로 파일 시스템, 데이터베이스, 네트워크 소켓 등을 통해 관리됩니다.
   2. 스레드 컨텍스 스위칭
      - 스레드들은 같은 프로세스의 메모리 공간 내에서 코드, 데이터, 힙 등을 공유합니다.
      - 공유 자원에 대한 접근을 동기화하기 위해 뮤텍스, 세마포어, 모니터 등의 동기화 메커니즘이 필요합니다.
      - 스레드 간 동기화는 공유 자원에 대한 일관성을 유지하고 경쟁 상태(race condition)를 방지하기 위해 중요합니다.
      - 동기화는 오버헤드를 발생시킬 수 있으며, 잘못 관리될 경우 데드락(deadlock)이나 스타베이션(starvation) 같은 문제를 일으킬 수 있습니다.

