## 자바 동시성 프로그래밍
자바에서 쓰레드는 내부적으로는 운영체제의 도움을 받아 작동하게 된다.  
쓰레드 생성되는 시점에 운영체제가 개입을 해 제어하는 방식으로 동작한다.  
### 동작 방식
1. **쓰레드 생성**: 자바에서 쓰레드를 생성하면, JVM은 이 요청을 운영체제에 전달한다. 운영체제는 이를 수행하고, 자바 쓰레드에 대응하는 운영체제 수준의 쓰레드를 생성.
2. **쓰레드 스케줄링과 관리**: 쓰레드의 실행, 스케줄링(언제 어떤 쓰레드가 실행될지 결정하는 과정)은 운영체제의 책임이다. JVM은 운영체제의 스케줄링 정책을 따르며, 운영체제는 사용 가능한 프로세서 자원을 쓰레드에 할당
3. **사용자 수준 쓰레드와 커널 수준 쓰레드**: 일부 운영체제에서는 사용자 수준 쓰레드(운영체제 커널이 관리하지 않는 쓰레드)와 커널 수준 쓰레드(운영체제 커널에 의해 직접 관리되는 쓰레드)를 지원한다. `자바`는 이러한 구분 없이 **투명하게 쓰레드를 관리**하도록 설계되었습니다.
4. **플랫폼 독립성**: 자바의 플랫폼 독립성으로 인해, 동일한 자바 쓰레드 코드가 다양한 운영체제에서 동일하게 작동할 수 있다. 그러나 쓰레드의 성능과 행동은 운영체제에 따라 다를 수 있다.
5. **JVM과 운영체제의 최적화**: 최신 JVM과 운영체제는 쓰레드 성능을 최적화하기 위해 긴밀하게 협력한다. 예를 들어, 가비지 컬렉션, 쓰레드 풀 관리 등은 JVM과 운영체제 간의 효율적인 상호작용을 통해 이루어진다.
  
이처럼 자바의 쓰레드와 운영체제는 긴밀하게 서로 소통하기 때문에 이 쓰레드를 잘 이해하기 위해서는 그 밑단에 흐르는 운영체제에서 동작하는 기본적인 쓰레드 원리 와 작동원리 및 도시성에 대하여 알 필요가 있다.  
즉, 자바쓰레드가 실행되는 시점에 운영체제의 상태와 쓰레드간의 전환이 발생하는 문제에 대한 처리 방법등 이러한 기본적인 흐름에 대한 이해가 필요하다.  
  
# 프로세스 와 쓰레드
| 프로세스 | 쓰레드 |
| --- | --- |
| 운영체제로부터 자원을 할당 받은 작업 단위 | 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위 |  
## 프로세스
### 프로그램
운영체제에 의해 시스템에 설치되어 있는 파일을 프로그램이라 말한다.  
예를들어 윈도우의 `.exe` 파일이나 Mac의 `.dmg` 파일과 같은 컴퓨터에서 실행할 수 있는 파일을 통칭한다.  
즉 아직 **파일을 실행하지 않는 상태**를 말한다.  
  
### 프로세스
프로그램이 실행하지 않는 파일을 말한다면 이를 **동작시켜서 프로그램이 돌아가고 있는 상태**를 프로세스라고 한다.  
즉, 프로세스는 프로그램의 실제 실행을 의미하며 이를 실행함으로써 프로그램의 **데이터들이 메모리에 올라와 cpu를 할당받고 명령을 수행하고 있는 상태** 이다.  

| 프로그램 | 프로세스 |
| --- | --- |
| 어떤 작업을 하기 위해 실행할 수 있는 파일 | 실행되어 작업중인 컴퓨터 프로그램 |
| 파일이 저장 장치에 있지만 메모리에는 올라가 있지 않은 정적인 상태 | 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태 |
| 코드 덩어리 | 코드 실행시킨 것 |  
    
프로세스가 메모리를 할당받으면 할당받은 메모리 일부를 커널 서비스를 위해 별도로 할당해준다.
## 쓰레드
오늘날 우리가 컴퓨터에서 파일을 다운로드 받으면 다른 작업을 당연하게 할 수 있지만 예전에는 파일을 다운로드 받으면 이 작업이 종료될때까지 기다려야 다음 작업을 할 수 있었다. 그렇다고 동일한 프로그램을 여러개의 프로세스로 만들게 되면 메모리와 CPU의 자원이 중복되게 되는 문제점이 발생한다. 이러한 한계를 극복하고자 나온 개념이 쓰레드이다.  
  
즉, **하나의 프로세스 내에서 동시에 진행되는 작업의 갈래, 흐름의 단위를 말한다.** 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다. 실질적으로 **프로세스는 운영체제로부터 메모리 자원을 할당 받는 것**이고 실제 **CPU를 할당받아서 우리가 제안한 코드를 실행하는 주체는 스레드**이다.
  
## 프로세스의 메모리 구조
- **코드 영역(Code/ Text)**: 프로그래머가 작성한 프로그램 함수들의 코드가 CPU가 해석 가능한 기계어 형태로 저장
- **데이터 영역(Data)**: 코드가 실행되면서 사용하는 전역 변수나 각종 데이터들이 모여있다. 데이터영역은 .data ,.rodata, .bss 영역으로 세분화 된다.
    - .data: 전역변수, 또는 static 변수 등 프로그램이 사용하는 데이터를 저장
    - .BSS : 초기값 없는 전역 변수, static 변수가 저장
    - .rodata: const 같은 상수 키워드 선언 된 변수나 문자열 상수가 저장
- **스택 영역(Stack):** 지역 변수와 같은 호출한 함수가 종료되면 되돌아올 임시적인 자료를 저장하는 독립적인 공간. Stack은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 만일 stack 영역을 초과하면 stack overflow 에러가 발생한다.
- **힙 영역(Heap):** 생성자, 인스턴스와 같은 동적으로 할당되는 데이터들을 위해 존재하는 공간이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
  
운영 체제는 프로세스마다 위처럼 각각 독립적인 메모리 영역을 할당해 주게 된다. 이때 코드 영역과 데이터 영역은 크기가 정해져 있지만, **스택 영역과 힙영역은 실행 되는 동안 크기가 늘었다가 줄었다가 하는 동적 영역**이다.  
이렇게 프로세스 마다 독립된 메모리 영역이 할당되기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행 할 수 있다. 기본적으로 프로세스간의 정보 공유가 완전히 불가능한 것은 아닌데 IPC(Inter-Process Communication) , LPC(Local inter-Process Communication), 별도로 공유 메모리를 만들어서 정보를 주고받도록 설정하면 공유가 가능하다.  
  
## 쓰레드의 자원 공유
 쓰레드는 프로세스가 운영체제로부터 할당 받은 자원을 이용하는 실행,흐름 단위로서 하나의 프로세스는 하나 이상의 스레드를 갖는다. 스레드가 여러개 있으면 우리가 브라우저에서 파일을 다운로드 받으면서 동시에 웹서핑을 할 수 있게 해준다.  
이 쓰레드는 **프로세스의 자원을 공유** 하면서 실행 흐름의 일부가 되기때문에 **동시 작업이 가능**한 것이다. 이 프로세스의 자원공유란 프로세스 내에서 각 필요한 스택(함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수 내에서 선언하는 변수 등을 저장하는 공간)만 할당 받고 `코드,데이타,힙 영역`을 공유한다.  
이때 스레드 간 메모리 스택 영역에는 서로 접근할 수 없으므로 스레드는 독립적인 실행 흐름을 가질 수 있게되어 독립적인 함수 호출이 가능해 진다.  
  
# CPU
## CPU
CPU (Central Processing Unit)는 컴퓨터의 주요 구성 요소로, **컴퓨터의 모든 명령을 처리**하는 데 필요한 계산 및 제어 작업을 수행합니다. CPU는 컴퓨터의 `두뇌`로 간주되며, 모든 프로그램 실행, 데이터 처리, 명령 실행 등을 담당합니다. CPU의 성능은 컴퓨터의 전반적인 속도와 성능에 중요한 영향을 미칩니다.
  
### CPU와 스레드
**스레드는 운영체제의 스케줄러에 의해 관리되는 CPU의 최소 실행단위를 의미한다.** 스케줄러 알고리즘에 따라 프로세스에 속한 한개의 스레드가 선점되어 CPU에 할당되고 스레드 선점이 일어날 때 CPU의 실행 흐름(문맥)이 전환되는 **컨텍스트 스위칭**이 발생한다.

### 멀티 코어와 쓰레드
컴퓨터 부품을 검색해보면 CPU 4코어 12쓰레드, 8코어 4쓰레드 이런 단어를 본적이 있을 것이다. CPU 한개는 여러 코어를 가질 수 있다.  
이 코어는 말그대로 CPU 코어 유닛인데, 명령어를 메모리에서 뽑아 해석하고 실행하는 유닛이 물리적으로 4개가 있으면 4코어, 8개가 있으면 8코어라고 불린다.  
이때 4코어 2쓰레드는 물리적인 코어 하나가 쓰레드 2개 이상을 동시에 실행 가능하다는 의미이고, 운영체제는 8개의 작업(4코어*2쓰레드)을 동시에 처리할 수 있다는 의미이기도 한다. 이를 하이퍼스레딩(Hyper-Threading) 기술이라 말한다.  

# CPU 작업의 병렬성(Parallelism) 과 동시성(Concurrency)
## 동시성
동시성은 둘 이상의 작업이 동시에 실행되는 것을 의미하는데 이는 **CPU가 한번에 많은 일을 처리하는 것**에 중점을 두고 있다. 즉, 많은 작업들을 아주 빠른 시간으로 교체하면서 전체 작업을 수행한다. 예를 들어 1개의 코어가 있고 여러개의 작업이 존재한다면 CPU는 프로세스들을 번걸아가며 조금씩 아주 빠르게 처리함으로써 마치 프로그램이 동시에 실행되는 것처럼 보인다.
이때 작업들을 번갈아가면서 실행하기 때문아 아주 잘게 나누어 조금씩 작업을 수행하고 다음 작업으로 넘어가는 식으로 동작한다. 이렇게 하는 이유는 여러 작업을 동시에 처리하는 것처럼 보이게 만들어 사용자에게 더 빠른 반응성을 제공하기 위해서이다.  
진행중인 작업들을 A -> B -> C -> D -> A 이런식으로 번걸아 바꾸는 작업을 **Context Switching** 이라고 부른다.  
이 동시성 **작업은 처리를 빠르게 하기 위한 목적이 아닌 CPU를 효율적으로 사용하는 것에 더 중점**을 두고 있다. 예를 들어 스레드가 작업을 처리하다가 IO 작업을 만나게 되면 현재 스레드를 대기시키고 다시 다른 스레드로 전환(다른 스레드를 할당)해서 작업을 진행한다. 따라서 이 동시성 작업에 대한 처리 방식을 어떤식으로 진행할 것인지(많은 작업들 어떻게 하면 효율적으로 처리 할지) 고려해야하며 동시성으로 작업해햐할 수가 CPU 코어 수 보다 많을 경우 해당되며 동시성이 없으면 작업을 순차적으로 진행한다.  
  
## 병렬성
병렬성은 직관적으로 명령어를 메모리에 뽑아 해석하고 실행하는 반도체 유닛인 **코어에 맞춰 여러개의 프로세스, 스레드를 돌려 병렬로 작업을 동시 수행**하는 것을 말한다. 이 병렬성은 **CPU가 동시에 많은 일을 수행하는 것에 중점**을 두고 CPU가 놀지않고 바쁘게 동작한다. 따라서 병렬성은 런타임에 동시에 물리적으로 작업을 실행하는 것이며 여러 컴퓨팅 리소스가 있는 하드웨어가 필요함로 한 개의 코어에서는 절대 병렬성이 구현될 수 없다.  
이 병렬성은 동시성의 하위 개념으로 여러 쓰레드로 작업을 분리하여 그 쓰레드를 CPU에 적절히 분배하여 동시적으로 실행하도록 하는 것이므로 병렬 작업해야할 수가 CPU 코어 수보다 같거나 적을 경우 효율이 가장 좋다.  
  
### 병렬성과 동시성의 조합
1. ThreadPoolExecutor
   * 병렬성으로 처리 성능을 극대화하고 동시성으로 CPU 자원을 효율적으로 관리
2. ForkJoinPool
   * **Parallelism Divide and Conquer 알고리즘**
   * Fork 생성하다는 의미 이다. 즉 하나의 큰 작업을 여러 하위 작업으로 분할한다음 여러개의 CPU 코어로 이 분할된 작업을 병렬로 처리하고 그결과들을 연결(Join) 하여 최종적으로 결과를 도출한다.
   * 하나의 작업을 서브 작업으로 분할하여 병렬처리함으로써 전체 작업 성늘을 높임

##   동시성의 개념차이
`"동시성"`이라는 용어는 컴퓨팅에서 다소 다른 맥락으로 두 가지 방식에서 사용된다. 하나는 프로세스 또는 스레드가 시스템에서 동시에 실행되는 것처럼 관리되는 일반적인 개념이고, 다른 하나는 멀티스레드 프로그래밍에서 발생할 수 있는 특정한 문제들과 관련된 개념이다.

1. **동시성(Concurrency) - 일반적 개념**:
    - 이 개념은 컴퓨터 프로그램, 프로세스, 스레드 등이 시스템 내에서 "동시에" 실행되는 것처럼 보이게 만드는 기능을 의미
    - 단일 코어 CPU에서는 이것이 시분할 방식으로 번갈아가며 실행되어, 동시에 실행되는 것처럼 보이게 하는 것이다. 멀티코어 CPU에서는 실제로 여러 작업이 동시에 실행될 수 있습니다.
2. **동시성(Concurrency) - 멀티스레드 프로그래밍의 문제점**:
    - 멀티스레드 환경에서 동시에 여러 스레드가 공유 자원에 접근할 때 발생하는 문제들을 지칭
    - 여기에는 경합 상태, 데드락, 라이브락, 스타베이션 등과 같은 문제가 포함됩니다. 이러한 문제들은 멀티스레드 환경에서 데이터의 무결성과 일관성을 유지하는 데 중요한 영향을 미칩니다.
        1. **경합 상태(Race Condition)**:
            - 두 개 이상의 스레드가 동시에 같은 데이터에 접근하고, 적어도 하나의 스레드가 그 데이터를 수정할 때 발생합니다.
            - 경합 상태는 데이터가 예상치 못한 방식으로 변경되어 부정확한 결과나 시스템의 실패를 초래할 수 있습니다.
        2. **데드락(Deadlock)**:
            - 두 개 이상의 스레드가 서로가 보유한 자원을 기다리며 무한히 대기하는 상태입니다.
            - 이 상황에서는 어떤 스레드도 진행할 수 없으며, 프로그램이 멈춰버릴 수 있습니다.
        3. **라이브락(Livelock)**:
            - 데드락과 유사하게, 스레드가 실행되고 있지만 실제로는 유용한 작업을 수행하지 못하는 상태입니다.
            - 스레드들이 서로를 피해 계속 상태를 변경하지만, 결국에는 아무런 진전도 이루지 못합니다.
        4. **스타베이션(Starvation)**:
            - 한 스레드가 필요한 자원에 접근하지 못하고 무한히 대기하는 상황입니다.
            - 특정 스레드가 CPU 시간이나 필요한 자원을 독점하여 다른 스레드가 작업을 수행할 기회를 얻지 못하는 경우 발생합니다.

따라서 동시성이라는 용어는 컴퓨팅의 광범위한 영역에서 다양한 맥락으로 사용되며, 그 의미는 사용되는 상황에 따라 달라진다. 일반적으로는 시스템이 여러 작업을 동시에 처리할 수 있는 능력을 나타내며, 멀티스레딩 환경에서는 이러한 동시 작업 처리로 인해 발생할 수 있는 특정 문제들을 가리킨다.



# 프로세스,스레드의 생명주기
프로세스와 스레드의 생명주기는 운영 체제의 스케줄링 및 자원 관리와 밀접하게 연관되어 있습니다. 프로세스는 보다 무거운 자원 사용을 하며, 스레드는 같은 프로세스 내에서 더 가볍게 자원을 공유한다.  
  
## 프로세스 스케줄링
프로세스 스케줄링(Process Scheduling)은 운영체제에서 CPU를 사용할 수 있는 프로세스를 선택하고, CPU를 할당하는 작업을 말한다.이는 시스템의 효율성, 반응성, 공정성을 극대화하는 데 중요한 역할을 하고 다양한 스케줄링 알고리즘이 있으며, 각각의 사용 환경과 요구 사항에 따라 적합한 알고리즘이 선택된다.  

프로세스 스케줄링은 프로세스의 우선순위, 작업량등을 고려하여 효율적으로 배치하고 이를 통해 운영체제는 CPU를 효율적으로 사용하며 시스템 전반적인 성능을 향상시킨다. 이는 멀티 태스킹 작업을 만들어내는 데에 있어서 핵심적인 부분이다.  
  
대표적으로는 해당 알고리즘 등이 있다. 
1. FCFS (First-Come, First-Served)  
   특징: 가장 간단한 스케줄링 알고리즘으로, 먼저 도착한 프로세스가 먼저 서비스를 받습니다.  
   장점: 구현이 쉽고, 공정합니다.  
   단점: 짧은 작업이 긴 작업 뒤에 오면 대기 시간이 길어지는 '호위 효과(Convoy Effect)' 발생 가능.
2. SJF (Shortest-Job-First)
   특징: 예상 실행 시간이 가장 짧은 프로세스를 먼저 실행합니다.  
   장점: 평균 대기 시간을 최소화할 수 있습니다.  
   단점: 실행 시간을 미리 알아야 하며, 긴 작업은 무한정 대기할 수 있습니다 (기아 현상).  
3. 우선순위 스케줄링 (Priority Scheduling)  
   특징: 각 프로세스에 우선순위를 부여하고, 높은 우선순위의 프로세스를 먼저 실행합니다.  
   장점: 중요한 작업을 빠르게 처리할 수 있습니다.  
   단점: 낮은 우선순위의 프로세스가 기아 상태에 빠질 수 있습니다.  
4. RR (Round-Robin)  
   특징: 각 프로세스에 동일한 시간 할당량(Time Quantum)을 주고, 순서대로 실행합니다.  
   장점: 모든 프로세스가 공정하게 CPU 시간을 받으며, 반응 시간이 짧습니다.  
   단점: 시간 할당량의 크기에 따라 성능이 크게 달라질 수 있습니다.  
5. 멀티레벨 큐 (Multilevel Queue)  
   특징: 프로세스를 여러 큐로 분류하고, 각 큐에 다른 스케줄링 알고리즘을 적용합니다.  
   장점: 다양한 유형의 프로세스를 효율적으로 관리할 수 있습니다.  
   단점: 큐 사이의 이동 규칙과 각 큐에 대한 스케줄링이 복잡할 수 있습니다.  
  
## 프로세스 상태
프로세스의 상태는 프로세스가 실행되는 동안 변경되는 고유의 상태를 의미 하며 프로세스가 생성되어 실행하기 까지 프로세스는 여러가지의 상태를 갖게 되고, 상태의 변화에 따라 프로세스가 동작 되는 것이다.  
1. **생성 (Creation)**: 프로세스가 생성되며, 이 때 필요한 자원과 메모리가 할당됩니다.
2. **준비 (Ready)**: 프로세스가 CPU에서 실행될 준비가 되어 대기합니다.
3. **실행 (Running)**: 프로세스가 CPU를 할당받아 명령을 실행합니다.
4. **대기 (Waiting)**: 프로세스가 특정 이벤트나 자원을 기다리는 동안 일시적으로 중지됩니다.
5. **종료 (Termination)**: 프로세스가 실행을 완료하고 모든 자원이 해제됩니다.
  
## 프로세스 상태 전이
프로세스의 상태전이(Process State Transition)는 프로세스가 생명주기 동안 거치는 다양한 상태와 그 상태들 간의 전환을 나타낸다. 일반적으로 프로세스는 다음과 같은 상태들을 거진다.  

1. 신규 (New): 프로세스가 생성되고 초기화되는 단계입니다. 이때 커널 영역에 PCB가 만들어 짐

2. 준비 (Ready): 프로세스가 CPU에서 실행될 준비가 되어 있으며, 실행을 기다리는 상태입니다.

3. 실행 (Running): 프로세스가 CPU를 할당받아 명령어들을 실행하는 상태입니다.

4. 대기 (Waiting): 프로세스가 I/O 작업이나 특정 이벤트의 완료를 기다리는 상태입니다.

5. 종료 (Terminated): 프로세스가 실행을 완료하고 시스템에서 제거되는 상태입니다.

### 상태전이
1. 신규 -> 준비: 프로세스가 생성되어 실행을 위해 준비됩니다.

2. 준비 -> 실행: 스케줄러가 프로세스를 선택하여 CPU를 할당합니다.

3. 실행 -> 대기: 프로세스가 I/O 작업을 요청하거나 특정 이벤트를 기다려야 할 때입니다.

4. 대기 -> 준비: I/O 작업이 완료되거나 기다리던 이벤트가 발생하여 다시 CPU에서 실행될 준비가 됩니다.

5. 실행 -> 준비: 선점형 스케줄링에서, 프로세스가 CPU 할당 시간을 다 쓰거나 더 높은 우선순위의 프로세스가 준비 상태가 되었을 때 발생합니다.

6. 실행 -> 종료: 프로세스가 모든 작업을 완료하고 시스템에서 제거됩니다.
  
## 스레드 생명주기
스레드는 프로세스 내에서 실행되는 실행 단위이다. 스레드의 생명주기는 다음과 같다:

1. 생성 (New): 스레드가 생성되고 초기화됩니다.
2. 준비 (Ready): 스레드가 실행을 위해 준비되며 CPU 할당을 기다립니다.
3. 실행 (Running): 스레드가 CPU를 할당받아 실행됩니다.
4. 대기 (Blocked): 스레드가 I/O 작업과 같은 이유로 일시적으로 중지됩니다.
5. 종료 (Terminated): 스레드가 작업을 완료하고 종료됩니다.  

프로세스와 스레드의 생명주기는 운영 체제의 스케줄링 및 자원 관리와 밀접하게 연관되어 있다. 프로세스는 보다 무거운 자원 사용을 하며, 스레드는 같은 프로세스 내에서 더 가볍게 자원을 공유한다.  
  
# 프로세스 컨텍스트 스위칭
하나의 CPU는 동일한 시간에 하나의 작업만 수행할 수 있기 때문에 여러 프로세스를 동시에 실행할 수 없다. 하나의 CPU에서 여러 프로세스를 동시성으로 처리하기 위해서는 **한 프로세스에서 다른 프로세스로 전환**해야 하는데 이것을 **컨텍스트 스위치** 라고한다.  

즉, **컨텍스트 스위칭(Context Switching)은 운영 체제에서 CPU가 하나의 프로세스 또는 스레드에서 다른 프로세스 또는 스레드로 전환하는 과정**을 말한다.  
  
CPU는 한번에 하나의 프로세스만 실행할 수 있으므로, 여러개의 프로세스를 번갈아가며 실행하여 CPU 활용률을 높이기 위해 컨텍스트 스위칭이 필요하다.  
  
컨텍스트 스위칭은 **동작중인 프로세스가 대기를 하면서 해당 프로세스의 상태를 보관**하고, 대기하고 있던 **다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업**을 말한다. 이러한 컨텍스트 스위칭이 일어날때 다음번 프로세스는 스케줄러가 결정하게 된다.  
1. **현재 프로세스의 상태 저장**: 현재 실행 중인 프로세스 또는 스레드의 상태(컨텍스트)를 저장합니다. 컨텍스트에는 프로그램 카운터, 레지스터 값, 메모리 상태 등이 포함됩니다.

2. **다음 프로세스의 상태 복원**: 다음에 실행할 프로세스 또는 스레드의 컨텍스트를 복원합니다. 이를 통해 이전에 중단된 지점부터 실행을 계속할 수 있습니다.
  
### 컨텍스트(Context)
컨텍스트 스위치(context switch)에서의 `"컨텍스트"`는 운영 체제가 프로세스나 스레드를 **교체할 때 저장하고 복원해야 하는 그 프로세스나 스레드의 상태 정보**를 의미한다. Context는 CPU가 해당 프로세스를 실행하기 위한 프로세스의 정보를 의미하며 정보들은 운영체제가 관리하는 PCB 라고 하는 자료 구조 공간에 저장한다.  

## PCB( Process Control Block)
PCB(Process Control Block)는 운영 체제에서 프로세스를 관리하기 위해 사용하는 커널 내의 중요한 데이터 구조(프로세스의 상태정보등)이다.프로세스를 컨텍스트 스위칭 할때 기존 프로세스의 상태를 어딘가에 저장해 둬야 다음에 똑같은 작업을 이어 서 할 수 있을 것이고, 새로 해야 할 작업의 상태 또한 알아야 어디서부터 다시 작업을 시작할지 결졍할 수 있을 것이다.  

즉, PCB는 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보 저장하는 **임시저장소**인 것이고 컨텍스트 스위칭은 CPU가 프로세스 간 PCB(Process Control Block) 정보를 교체하고 기존에 저장했던 PCB(Process Control Block)를 비우는 일련의 과정이라고 불 수 있다.  
  
**프로세스가 생성되면 메모리에 해당 프로세스의 PCB가 함께 생성되고, 종료 시 삭제**된다. 따라서 운영체제는 PCB에 담긴 프로세스 고유 정보를 통해 프로세스를 관리하고, 프로세스의 실행 상태를 파악하고, 우선순위를 조정하며, 스케줄링을 수행하고, 다른 프로세스와의 동기화를 제어한다.  
### PCB의 주요 구성 요소
* **프로세스 식별자 (Process Identifier, PID)**: 각 프로세스를 구별하는 고유한 식별자입니다.

* **프로세스 상태 (Process State)**: 프로세스가 현재 어떤 상태에 있는지를 나타냅니다 (예: 준비, 실행, 대기).

* **프로그램 카운터 (Program Counter)**: 프로세스가 다음에 어떤 명령어를 실행해야 하는지를 가리키는 카운터입니다.

* **레지스터 세트 (Register Set)**: 프로세스 실행 중 필요한 레지스터들의 현재 값을 저장합니다.

* **메모리 관리 정보 (Memory Management Information)**: 프로세스의 주소 공간, 페이지 테이블, 세그먼트 테이블 등 메모리 관련 정보를 포함합니다.

* **계정 정보 (Accounting Information)**: 프로세스 실행 시간, 사용된 CPU 시간, 프로세스가 시작된 시간 등을 기록합니다.

* **I/O 상태 정보 (I/O Status Information)**: 프로세스에 할당된 I/O 장치 목록과 열린 파일 목록 등이 포함됩니다.  

> Register란?  
> 레지스터는 컴퓨터의 중앙 처리 장치(CPU) 내부에 있는 매우 빠른 메모리 단위입니다. 이들은 CPU가 수행하는 연산에 필요한 데이터나 연산 결과를 일시적으로 저장하는 역할을 합니다. 레지스터는 컴퓨터의 데이터 처리 속도에 큰 영향을 미치는 중요한 구성 요소입니다.  
>  
> PCB와 레지스터  
> PCB(Process Control Block) 내의 레지스터 세트는 특정 프로세스가 중단될 때 그 프로세스의 레지스터 상태를 저장합니다. 컨텍스트 스위칭 시, 이 정보는 해당 프로세스가 재개될 때 CPU에 다시 로드되어 프로세스가 중단된 지점부터 연산을 계속할 수 있도록 합니다. 이는 멀티태스킹 환경에서 각 프로세스의 실행 상태를 유지하는 데 필수적입니다.
  
## Context Switching 과정
![switching.png](src%2Fresources%2Fstatic%2Fimg%2Fswitching.png)  
해당 이미지는 두 개의 프로세스 P1과 P2가 CPU를 공유하며 실행되는 컨텍스트 스위칭 과정을 도식화한 것이다.  
1. **프로세스 P1 실행 중**: 초기 상태에서 프로세스 P1이 CPU를 사용하여 실행 중입니다.
2. **인터럽트 또는 시스템 콜 발생**: 프로세스 P1의 실행 중에 인터럽트 또는 시스템 콜이 발생합니다. 이는 CPU가 다른 작업을 수행해야 함을 의미하며, 이 때문에 프로세스 P1의 실행이 중단됩니다.
3. **프로세스 P1 상태 저장**: CPU는 프로세스 P1의 현재 상태(레지스터 값, 프로그램 카운터 등)를 프로세스 P1의 PCB(PCB1)에 저장합니다. 이로써 프로세스 P1은 중단된 지점에서 나중에 재개할 수 있습니다.
4. **프로세스 P2 상태 복원**: 이어서 CPU는 프로세스 P2의 이전 상태를 PCB(PCB2)에서 가져와 CPU에 로드합니다. 프로세스 P2는 이전에 중단됐던 지점부터 실행을 재개합니다.
5. **프로세스 P2 실행**: CPU는 이제 프로세스 P2를 실행 상태로 전환하고, 프로세스 P1은 대기 상태(Idle)로 전환됩니다.
6. **두 번째 인터럽트 또는 시스템 콜 발생**: 프로세스 P2가 실행 중일 때 또 다른 인터럽트 또는 시스템 콜이 발생합니다.
7. **프로세스 P2 상태 저장**: 프로세스 P2의 현재 상태는 PCB2에 저장됩니다.
8. **프로세스 P1 상태 복원**: 다시 프로세스 P1의 상태가 PCB1에서 가져와 CPU에 로드되어 프로세스 P1이 실행을 재개할 수 있도록 합니다.
  
## Context Switching Overhead
컨텍스트 스위칭 오버헤드(Context Switching Overhead)는 운영 체제가 하나의 프로세스에서 다른 프로세스로 전환할 때 발생하는 추가적인 시간 및 자원 소모를 말한다. 이때 전환되는 과정에서 프로세스의 상태, 레지스터 값등이 저장되고 불러오는 등의 작업이 수행되기 때문에 시스템에 많은 부담을 준다.  
  
컨텍스트 스위칭 과정에서 위의 그림에서 P1이 실행 중에 P2의 작업에 대한 실행요청이 왔을때 바로 실행되는 것이 아니라 **대기 상태**에 있다가 실행 되는 것을 확인할 수 있는데 이 **간극이 바로 컨텍스트 스위창 오버헤드 인 것**이다.  
  
즉,오버헤드는 프로세스가 실행 상태에서 대기 상태로 바뀌고, 다시 실행 상태로 돌아올 때 발생하는 일련의 작업들과 관련이 있습니다.  
  
### 오버헤드에 포함되는 주요 작업
1. 레지스터 상태 저장 및 복원
2. 메모리 관리자 업데이트
3. 캐시 초기화 또는 업데이트
4. 보안 및 접근성 업데이트
  
# 스레드 스케줄링
스레드 스케줄링은 프로세스 내의 개별 스레드에 CPU 시간을 할당하는 과정이다.즉, 스레드 스케줄링은 운영체제에서 다중 스레드를 관리하며, CPU를 사용할 수 있는 스레드를 선택하고, CPU를 할당하는 작업을 말한다.  

이는 프로세스 스케줄링과 유사하지만, 스레드는 프로세스보다 더 가벼운 실행 단위이며, 일반적으로 같은 프로세스 내의 스레드들은 일부 자원(예: 메모리)을 공유한다.이 스레드 스케줄링의 주요 목적은 CPU 사용률을 극대화하고, 프로그램의 응답 시간을 최소화하며, 시스템 전반의 처리량을 증가시키는 것이다.  

다만 스레드 스케줄링은 프로세스 스케줄링과 다르게, 하나의 프로세스 내에서 다수의 스레드가 동작하는 형태이기 때문에, 스레드 간의 상호작용과 동기화 문제를 고려해야 한다는 차이점이 존재한다.  
  
## 스레드 컨텍스트 스위치
스레드 컨텍스트 스위칭은 프로세스 컨텍스트 스위칭과 유사한 메커니즘을 가지고 있지만, 주로 같은 프로세스 내의 스레드들 사이에서 일어나며, 비교적 더 가볍다. 이는 같**은 프로세스 내의 스레드들이 코드, 데이터, 힙 영역과 같은 메모리 자원을 공유**하기 때문이다.  

### **스레드 컨텍스트 스위칭 과정**

1. **스레드 상태 저장**: 현재 실행 중인 스레드의 상태(레지스터 세트, 프로그램 카운터 등)를 저장합니다.
2. **CPU 레지스터 변경**: 다음 실행할 스레드의 상태 정보로 CPU의 레지스터를 업데이트합니다.
3. **스택 포인터 변경**: 다음 실행할 스레드의 스택 포인터로 변경하여, 해당 스레드의 스택 프레임에 접근할 수 있도록 합니다.
4. **프로그램 카운터 업데이트**: 프로그램 카운터를 다음 스레드가 계속해서 실행할 코드의 주소로 업데이트합니다.
5. **스레드 상태 복원**: 중단되었던 다른 스레드의 상태를 복원합니다.  

## TCB(Thread Control Block)
PCB 처럼, TCB (Thread Control Block)는 각 스레드마다 운영 체제에서 유지하는 스레드에 대한 정보를 담고 있는 자료 구조이다.TCB는 PCB 블록안에 들어 있다. 스레드가 프로세스 내에 위치한 것 처럼 말이다.  

프로세스의 정보를 저장하는 PCB(Process Control Block)와 유사하게, TCB는 스레드의 상태, 스레드 식별자, 레지스터 세트, 프로그램 카운터, 스택 포인터, 우선순위, 상태 정보 등 스레드 실행에 필요한 모든 정보를 포함하고 있다. TCB도 스레드가 생성될 때 운영 체제에 의해 생성되며, 스레드가 실행을 마치고 소멸될 때 함께 소멸된다.  

스레드 간의 자원 공유와 동기화도 TCB를 사용하여 관리된다. 예를 들어, 뮤텍스(mutual exclusion)나 세마포어(semaphore)와 같은 동기화 기법을 사용할 때, TCB에서 해당 스레드의 뮤텍스나 세마포어 정보를 관리하고, 스레드가 해당 자원에 대한 접근 권한을 획득하거나 반납할 때 TCB의 정보를 업데이트하게 된다.  
1. **뮤텍스 (Mutex)**:
   - 뮤텍스는 "Mutual Exclusion"의 줄임말로, 한 번에 하나의 스레드만 특정 자원에 접근할 수 있도록 합니다.
   - 뮤텍스는 임계 영역(critical section)에 대한 접근을 제어하여, 동시성 문제를 방지합니다.
   - 뮤텍스는 잠금(lock)과 해제(unlock) 메커니즘을 사용하여 자원을 보호합니다.
2. **세마포어 (Semaphore)**:
   - 세마포어는 뮤텍스와 유사하지만, 한 번에 여러 스레드가 자원에 접근할 수 있는 '카운트' 개념을 제공합니다.
   - 세마포어는 특정 자원이 여러 개 있을 때 유용하며, 자원의 사용 가능한 개수를 관리합니다.
   - 세마포어는 신호를 보내 자원을 획득하거나 반납하는 방식으로 작동합니다.
  
# 프로세스 컨텍스트 스위칭 vs 스레드 컨텍스트 스위칭
프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭은 둘 다 운영 체제가 실행 중인 작업 간에 CPU를 전환하는 데 사용하는 메커니즘입니다. 그러나 이 두 스위칭 방식 사이에는 중요한 차이점이 있다.  

1. TCB가 PCB 보다 가볍다
   - **프로세스 컨텍스트 스위칭**은 프로세스 간에 전환할 때 발생하며, 더 많은 시간과 자원을 소모합니다.
   - **스레드 컨텍스트 스위칭**은 같은 프로세스 내의 스레드들 간의 전환에 사용되며, 상대적으로 오버헤드가 적습니다.
2. 캐시 메모리 초기화
   1. 프로세스 컨텍스트 스위칭
      - 프로세스 간에 컨텍스트 스위칭을 할 때, 새로운 프로세스는 다른 메모리 공간을 사용합니다.
      - CPU 캐시에 로드된 데이터는 이전 프로세스의 메모리 주소 공간에 대응되므로, 새 프로세스에는 무효가 됩니다.
      - 결과적으로 캐시 메모리는 초기화되거나 새로운 프로세스의 데이터로 재충전되어야 합니다.
      - 이로 인해 캐시 미스가 증가하고 성능이 저하될 수 있습니다.
   2. 스레드 컨텍스 스위칭
      - 동일 프로세스 내의 스레드들은 메모리 공간을 공유하기 때문에, 캐시에 있는 데이터가 여전히 유효할 수 있습니다.
      - 스레드 간 스위칭 시에 캐시를 초기화할 필요가 없거나, 초기화가 필요한 범위가 매우 제한적입니다.
      - 따라서 스레드 스위칭은 캐시 메모리의 재사용도가 높고, 캐시 효율성이 유지되어 성능 저하가 적습니다.
3. 자원 동기화
   1. 프로세스 컨텍스트 스위칭
      - 프로세스들은 독립적인 메모리 공간을 가지고 있으며, 일반적으로 서로의 자원에 접근하지 않습니다.
      - 자원 동기화의 필요성이 상대적으로 낮고, 프로세스 간 통신을 위해서는 IPC(Inter-Process Communication) 메커니즘이 사용됩니다.
      - 프로세스 간의 자원 공유가 일어날 때는 주로 파일 시스템, 데이터베이스, 네트워크 소켓 등을 통해 관리됩니다.
   2. 스레드 컨텍스 스위칭
      - 스레드들은 같은 프로세스의 메모리 공간 내에서 코드, 데이터, 힙 등을 공유합니다.
      - 공유 자원에 대한 접근을 동기화하기 위해 뮤텍스, 세마포어, 모니터 등의 동기화 메커니즘이 필요합니다.
      - 스레드 간 동기화는 공유 자원에 대한 일관성을 유지하고 경쟁 상태(race condition)를 방지하기 위해 중요합니다.
      - 동기화는 오버헤드를 발생시킬 수 있으며, 잘못 관리될 경우 데드락(deadlock)이나 스타베이션(starvation) 같은 문제를 일으킬 수 있습니다.

## CPU Bound / IO Bound
프로세스는 CPU 작업과 I/O 작업의 연속된 흐름으로 진행된다. 프로세스는 CPU 명령어를 수행하다가 I/O를 만나면 대기하고 I/O 작업이 완료되면 다시 CPU 작업을 수행한다. 이러한 작업을 반복한다.  

이때 **CPU 바운드(CPU Bound) 와** **I/O 바운드(I/O Bound)는** 프로그램의 성능을 제한하는 요소에 대한 두 가지 다른 상황을 설명한다. 이 용어들은 프로그램이나 시스템이 어떤 자원에 의해 주로 성능이 제한되는지를 나타낸다.  

###  기본 용어

1. **Burst (버스트)**
   - 어떤 현상이 짧은 시간 안에 집중적으로 일어나는 것을 의미한다.
   - 한 작업을 짧은 시간동안 집중적으로 연속해서 처리하거나 실행하는 것
2. **Input/output (IO)**
   - 파일을 읽고 쓰거나, 네트워크 어딘가에 있는 다른 존재와 데이터를 주고받거나, 모니터/ 마우스 같은 입출력 장치와 데이터를 주고 받는 것을 IO라고 한다.
3. **CPU 버스트**
   - 프로세스가 CPU에서 한 번에 연속적으로 실행되는 시간을 의미한다. (CPU를 연속적으로 사용하면서 명령어를 실행하는 구간)
   - 메모리에 올라가 있는 프로세스가 자신의 차례가 되어서 CPU에서 실행됐을 때 자신의 명령어들이 CPU에서 연속적으로 실행되는 시간을 의미한다.
   - 프로세스가 CPU 명령어를 실행하는데 소비하는 시간 (프로세스의 RUNNING 상태를 처리)
4. **IO 버스트**
   - 프로세스가 IO 작업을 요청하고, 그 결과를 기다리는 시간을 의미한다.
   - 프로세스의 WAITING 상태를 처리

### ****CPU와 I/O 버스트의 교차****

대부분의 프로세스는 CPU 버스트와 I/O 버스트가 교대로 발생하는 패턴을 보인다. 예를 들어, 프로세스는 계산(CPU 버스트)을 수행한 후 결과를 파일에 저장(I/O 버스트)할 수 있습니다. 이러한 교차 패턴은 프로세스 스케줄링과 시스템 설계에 중요한 영향을 미칩니다. 예를 들어, CPU 바운드 프로세스는 짧고 빈번한 CPU 버스트를 보이는 반면, I/O 바운드 프로세스는 더 긴 I/O 버스트를 경험할 수 있습니다.

### 프로세스는 CPU 버스트 와 I/O 버스트의 연속된 흐름이다.

프로세스는 CPU 명령어를 수행하다가 I/O 를 만나면 대기하고 I/O 작업이 완료되면 다시 CPU 작업을 수행한다. 이 작업을 계속해서 반복하다 프로세스가 종료될땐 CPU 버스트로 마무리 된다.  

## CPU **Bounded Process**

CPU 바운드 프로세스는 주로 CPU의 처리 능력에 의해 성능이 제한되는 프로세스 이다. 이 유형의 프로세스는 계산 작업이 많으며(I/O Burst 가 거의 없는 경우), CPU의 사이클을 집중적으로 사용합니다.

예를 들어, 머신러닝, 블록체인, 동영상 편집 프로그램등 CPU 연산 위주의 작업을 하는경우를 의미한다 .CPU의 속도를 높이거나, 알고리즘을 최적화하거나, 멀티 쓰레딩 및 병렬 처리 기술을 적용하여 성능을 향상시킬 수 있다. 일반적으로 CPU 코어수와 스레드 수의 비율을 비슷하게 설정한다.

## **I/O Bounded Process**

I/O 바운드 프로세스는 입력/출력 작업에 의해 성능이 제한되는 프로세스 이다. 이 유형의 프로세스는 데이터를 읽고 쓰는 작업에 많은 시간을 소비합니다. 즉 I/O 버스트가 빈번하게 발생하는 프로세스로서 CPU 버스트가 매우 짧다.

예를 들어, 파일, 키보드, DB 네트워크 등 외부 연결이나 입출력 장치와의 통신 작업이 많은 경우에 해당된다. 더 빠른 스토리지 시스템(예: SSD), I/O 캐싱, 비동기 I/O 처리, 네트워크 대역폭 확장 등을 통해 성능을 개선할 수 있다. 이때 CPU 코어가 많을 경우 멀티 스레드의 동시성을 최대한 활용하여 CPU 가 Idle(대기상태)상태가 되지 않도록 하고 최적화 된 스레드 수를 운용해서 CPU의 효율적인 사용을 극대화 한다.  
  
## 사용자모드(User Mode) 와 커널 모드(Kernel Mode)
컴퓨터 시스템에서 "사용자 모드(User Mode)"와 "커널 모드(Kernel Mode)"는 운영 체제의 두 가지 주요 실행 모드를 나타낸다. 이들은 시스템 자원에 대한 접근 수준과 관련된 권한을 구분한다.  

## **커널(kernel)**

운영체제는 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어이고 여러 핵심 기능을 담당하는 부분을 **커널(kernel)** 이라고 한다.

![9914C3435D4024A324.png](src%2Fresources%2Fstatic%2Fimg%2F9914C3435D4024A324.png)

커널은 운영 체제의 핵심 구성 요소로, 시스템의 하드웨어와 소프트웨어 사이에서 **중개자 역할**을 합니다. 기본적으로 커널은 컴퓨터의 하드웨어 자원과 관련된 모든 저수준 작업을 관리한다. 이것은 컴퓨터가 제대로 기능할 수 있도록 여러 중요한 서비스를 제공한다.  

즉, 사용자가 운영체제 위에서 실행되는 프로그램을 편하고 효율적으로 사용할 수 있게 하드웨어와 소프트웨어 간 중개 자 역할을 하고 CPU, I/O 장치, 메모리, 저장소와 같은 하드웨어 자원을 프로그램에 잘 할당하는 데 있다.  


> **저수준 작업 이란?**
>
>
> "저수준 작업(Low-level operations)"이라는 용어는 컴퓨터 프로그래밍 및 시스템 설계에서 하드웨어에 가까운 작업을 가리킵니다. 이러한 작업은 하드웨어 자원과 밀접하게 상호작용하며, 보통 운영 체제의 커널이 담당합니다. 저수준 작업은 추상화 수준이 낮아서, 일반적으로 다음과 같은 활동을 포함합니다:
>
> 1. **메모리 관리**: 물리적 메모리 할당, 해제, 페이지 교체, 가상 메모리와 페이지 테이블 관리 등.
> 2. **프로세스 스케줄링**: CPU 시간 할당, 프로세스 상태 관리, 컨텍스트 스위칭 등 프로세스 실행을 조율하는 작업.
> 3. **디바이스 드라이버 인터페이스**: 하드웨어 장치와의 통신을 위한 인터페이스를 제공하며, 입출력 요청의 중재, 버퍼 관리 등을 수행합니다.
> 4. **시스템 호출 처리**: 사용자 모드 프로세스가 요청하는 다양한 시스템 서비스에 대한 접근과 실행을 관리합니다.
> 5. **인터럽트 처리**: 하드웨어나 소프트웨어 인터럽트를 받고 적절한 처리 루틴을 실행합니다.
> 6. **네트워크 스택 관리**: 데이터 패킷의 송수신, 네트워크 인터페이스 관리, 프로토콜 처리 등 네트워크 통신에 필요한 작업을 수행합니다.
> 7. **보안 기능**: 사용자 인증, 접근 권한 체크, 암호화 및 해독 등의 보안 관련 기능을 실행합니다.

운영체제는 응용 프로그램(Application)이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호한다.만약에 응용 프로그램이 하드웨어 자원에 직접 접근해서 조작 할 수 있다면 자원 관리가 되지 않고 프로세스 간 데이터가 훼손되어 컴퓨터 시스템 전체에 오류를 가져오게 된다. 따라서 **응용프로그램이 하드웨어 자원에 접근하려고 할때는 반드시 운영체제를 통해서만 접근**하도록 한다.  
  
즉, 응용 프로그램(Application)이 하드웨어에 접근을 하기위해서는 운영체제의 권한을 이용해서 접근을 해야한다.

## ****CPU Protection Ring****

운영체제는 프로세스들을 처리하기 위해 CPU의 기능과 시스템 자원에 접근할 수 있어야 한다. 하지만 컴퓨터의 주요한 자원에 무분별하게 접근할 수 있는 것은 아니다. 운영체제는 접근할 수 있는 권한이 부여된 요청만 CPU에 접근을 허락한다. 이 권한은 4가지로 분류되며, 접근 권한들을 분류하여 나눈 것을 CPU Protection Ring이라고 한다.

![cpuRing.png](src%2Fresources%2Fstatic%2Fimg%2FcpuRing.png)

CPU 보호 링(CPU Protection Rings)은 컴퓨터 시스템에서 보안 및 접근 제어를 제공하기 위해 사용되는 메커니즘이다. 이 개념은 주로 운영 체제와 하드웨어 아키텍처에서 사용되며, 다양한 권한 수준을 가진 여러 "링" 또는 "레벨"로 시스템을 분할하고 각 링은 서로 다른 권한과 책임을 가지며, 중심으로 갈수록 더 높은 권한을 가진다.  

CPU Protection Ring은 일반적으로 0부터 3까지의 숫자로 표현되며, 낮은 숫자일수록 더 높은 권한을 나타낸다. 주로 0부터 3까지의 권한 레벨이 사용된다.

- **레벨 0 (Level 0)**: 이것은 시스템의 **커널이 실행되는 가장 낮은 레벨**로, 시스템의 모든 자원에 대한 완전한 제어 권한을 가지고 있습니다. 여기에서 운영 체제의 핵심 부분들이 실행되며, 메모리 관리, 프로세스 스케줄링, 하드웨어와의 직접적인 상호작용 등을 담당합니다.
- **레벨 1 (Level 1)과 레벨 2 (Level 2)**: 이 레벨들은 일반적으로 **운영 체제의 특정 서브시스템**이나 **드라이버들에 의해 사용**됩니다. 이들은 커널 모드보다는 제한된 권한을 가지지만, 사용자 모드보다는 더 많은 시스템 자원에 접근할 수 있습니다. 대부분의 현대 운영 체제는 이 레벨들을 명시적으로 사용하지 않습니다.
- **레벨 3 (Level 3)**: **가장 바깥쪽 원이자 가장 낮은 권한을 가진 사용자 모드**입니다. 일반 애플리케이션들은 이 레벨에서 실행되며, 운영 체제로부터 제공받는 API를 통해 시스템 자원을 사용합니다. 이 레벨의 프로그램들은 직접적으로 하드웨어에 접근할 수 없으며, 모든 작업을 수행하기 위해 운영 체제에 요청을 보내야 합니다.

**0은 가장 높은 권한을 가진 커널 모드(Kernel Mode)이고**,**3은 가장 낮은 권한을 가진 사용자 모드(User Mode)이다.**

권한 레벨이 높은 커널 모드(Level 0)는 **운영체제와 시스템 자원에 대한 접근이 가능**하다. 반면에 **사용자 모드(Level 3)는** 프로세스가 제한된 자원에만 접근할 수 있으며, 시스템 자원에 직접 접근하는 것은 제한된다. 운영체제는 CPU Protection Ring을 사용하여 사용자 프로세스 간의 충돌, 잘못된 접근, 시스템 자원의 남용 등을 방지하고, 운영체제의 안정성을 유지할 수 있다. 그리고 시스템 보안을 강화하여 악성 코드나 해킹 시도로부터 시스템을 보호한다.  

## CPU 권한 모드

CPU의 권한 모드는 **운영 체제가 시스템의 자원과 작업을 관리하는 방법**을 정의합니다. 가장 일반적인 두 가지 모드는 사용자 모드(User Mode)와 커널 모드(Kernel Mode)입니다.  
  
![cpuMode.png](src%2Fresources%2Fstatic%2Fimg%2FcpuMode.png)

### 사용자 모드(Mode Bit =1)

사용자 모드는 응용 프로그램이 실행되는 일반적인 모드입니다. 이 모드에서는 제한된 시스템 자원과 메모리에만 접근할 수 있다.

사용자 응용프로그램의 코드가 실행 되는 모드로서 메모리의 유저영역만 접근 가능하다. 사용자 모드에서 실행되는 프로그램은 커널 모드에서 허용하지 않는 일부 작업을 수행할 수 없습니다.  예를 들어 디스크, 메모리, Printer 및 여러 I/O 장치들과 같은 특정 리소스들에 직접 접근할 수 없다. 이는 시스템의 보안과 안정성을 유지하는 데 도움이 됩니다.

대부분의 **응용프로그램은 입출력 장치나 파일로의 접근이 필요하기 때문에 이때는 유저모드에서 커널모드로 전환** 되어야 한다.

### 커널 모드 (Mode Bit =0)

커널 모드는 운영 체제의 핵심 부분이 실행되는 모드로, 시스템의 모든 자원에 대한 완전한 접근 권한이 있다. 이 모드에서 실행되는 코드는 하드웨어와 직접 상호작용할 수 있으며, 메모리 관리, 프로세스 관리, 하드웨어 장치 제어 등의 중요한 작업을 수행한다.

즉, 메모리의 유저영역, 커널영역 모두 접근 가능하다.

## 시스템 콜

시스템 콜(System Call)은 **응용 프로그램이 운영 체제의 커널 서비스를 요청할 때 사용하는 인터페이스**입니다. 간단히 말해, 시스템 콜은 사용자 모드에서 실행 중인 프로그램이 커널 모드의 기능을 이용하고자 할 때 커널에 접근하는 방법이다.  

### **시스템 콜의 역할**

1. **하드웨어 접근**: 직접적인 하드웨어 접근은 커널 모드에서만 가능하기 때문에, 응용 프로그램은 시스템 콜을 통해 하드웨어 자원을 안전하게 사용할 수 있습니다.
2. **자원 관리**: 파일 시스템 작업, 네트워크 통신, 프로세스 관리와 같은 시스템 자원을 효율적으로 관리합니다.
3. **보안과 안정성**: 시스템 콜은 사용자 모드와 커널 모드 간의 중요한 경계를 형성하여, 시스템의 안전과 안정성을 유지하는 데 기여합니다.

### **시스템 콜의 종류**

- **프로세스 관리**: 프로세스 생성 및 종료, 스케줄링 등을 관리합니다.
- **파일 조작**: 파일 열기, 읽기, 쓰기, 닫기 등의 파일 시스템 관련 작업을 수행합니다.
- **장치 관리**: 하드웨어 장치와의 통신과 관리를 담당합니다.
- **정보 유지**: 시스템 시간, 시스템 데이터 등에 대한 정보를 조회하거나 설정합니다.
- **통신**: 프로세스 간 통신(IPC)이나 네트워크 통신을 위한 시스템 콜입니다.

### **시스템 콜의 작동 방식**

1. **요청**: 응용 프로그램이 특정 작업을 수행하기 위해 시스템 콜을 요청합니다.
2. **모드 전환**: 시스템 콜이 실행되면 CPU는 사용자 모드에서 커널 모드로 전환됩니다.
3. **실행**: 커널은 요청된 작업을 수행합니다.
4. **복귀**: 작업이 완료되면 CPU는 다시 사용자 모드로 전환되고, 응용 프로그램으로 제어가 반환됩니다.

사용자 응용 프로그램은 작업 과정에서 커널의 기능을 사용하기 위해 매우 빈번하게 시스템 콜을 요청하고 이로 인해 사용자 모드와 커널 모드를 상호 전환하며 실행하게 된다. I/O 처리를 위해 사용자 모드와 커널 모드를 번갈아 오가는 것은 컨텍스트 스위칭과 관련이 있으며 이는 멀티 스레드 환경에서 참고해야 할 중요한 배경적 지식이다.

즉, 응용프로그램이 파일 입출력이나, 화면에 메시지를 출력하는 등의 기능은 커널 모드 일때 CPU가 실행하기 때문에 반드시 시스템 콜을 사용해서 커널 모드로 전환해야 한다.  
  
## 사용자 수준 스레드 , 커널 수준 스레드
**사용자 수준 스레드(User-Level Threads)와** **커널 수준 스레드(Kernel-Level Threads)는** 운영 체제에서 스레드를 관리하는 두 가지 기본적인 방식을 나타낸다. 이 두 방식은 스레드의 생성, 스케줄링, 관리 방법에 있어서 차이를 가진다. 즉 생성 주체가 누구냐에 따라 구분된다.

사용자 수준 스레드는 사용자 프로그램에서 관리하는 스레드며 커널 수준 스레드는 OS 에서 관리하는 스레드이다

## **사용자 수준 스레드** (User Level Thread)

사용자 수준 스레드란 사용자 영역에서 스레드 라이브러리(Pthreads, Windows Threads, Java Threads(JVM)) 에 의해 스레드의 생성과 종료, 스레드간 메시지 전달, 스레드의 스케쥴링 보관 등 모든 것을 관리한다. 커널에 대한 추가적인 시스템 호출이 필요 없기 때문에 스레드의 생성, 전환, 스케줄링이 빠르다는 장점이 있다.

단, **커널은 이러한 스레드의 존재를 인지하지 못하며 단일 스레드 프로세스인 것처럼 관리**한다. 한 스레드가 블록되면 프로세스 내의 모든 스레드가 블록될 수 있다. 또한, 멀티코어 활용에 제한이 있을 수 있다.

## **커널 수준 스레드** (Kernel Level Thread)

커널 수준 스레드는 운영 체제 커널에 의해 직접 관리됩니다(PCB와 TCB 관리 및 유지). 커널은 모든 스레드를 알고 있으며 각 스레드에 대한 정보를 가지고 있다.이때 커널은 커널 스레드의 모든 정보를 알고 있으며 커널 스레드는 OS 스케줄러에 의해서 스케줄링 된다. **CPU 는 커널에 의해 생성된 커널 스레드의 실행만을 담당한다.**

스레드 관리를 위한 시스템 호출이 필요하므로, 사용자 수준 스레드에 비해 오버헤드가 더 크다. 커널이 각 스레드를 개별적으로 관리할 수 있으므로, 멀티프로세서 시스템에서의 스레드 스케줄링과 병렬 처리가 용이하다.

# ****Multi Process 와 Multi Thread****

멀티 프로세스(Multi Process)와 멀티 스레드(Multi Thread)는 컴퓨터 프로그래밍에서 작업을 병렬로 처리하기 위한 두 가지 주요한 방식이다. 각각은 다른 메커니즘과 특성을 가지고 있으며, 특정 상황에 따라 적합한 방식을 선택하는 것이 중요합니다.

프로세스와 스레드가 단일이 아닌 다중으로 돌아감으로써 성능 향상 등 여러가지 효과를 얻을 수 있게 된다. 하지만 또한 이로 인해 발생되는 부가적인 문제점도 발생하게 된다. 따라서 각각의 장단점을 파악하여 적재적소에 사용하는 것이 요구된다.

## ****Multi Process****

멀티 프로세스는 운영체제에서 하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 실행할 수 있게 하는 기술을 말한다. 보통 하나의 프로그램 실행에 대해 하나의 프로세스가 메모리에 생성되지만, 부가적인 기능을 위해 여러개의 프로세스를 생성하는 것이다.

- 멀티 프로세스 와 멀티 프로세서
   - 프로세스(Process) 는 프로그램의 실행 상태를 말함
      - 멀티 프로세스: 하나의 프로그램에서 여러개의 프로세스를 실행하는 것
   - 프로세서(rocessor)는 CPU 코어를 말한다.
      - 멀티 프로세서: 여러개의 CPU 코어가 하나의 시스템에서 동시에 실행되는 것

멀티 프로세스 내부를 보면, **하나의 부모 프로세스가 여러개의 자식 프로세스를 생성**함으로서 다중 프로세스를 구성하는 구조이다.

한 프로세스는 실행되는 도중 프로세스 생성 시스템 콜을 통해 새로운 프로세스들을 생성 할 수 있는데 다른 프로세스를 생성하는 프로세스를 부모 프로세스(Parent Process)라 하고, 다른 프로세스에 의해 생성된 프로세스를 자식 프로세스(Child Process)라고 한다.

부모 프로세스와 자식 프로세스는 **고유한 PID(Process ID**)를 가지고 있다.

부모 프로세스는 자식 프로세스의 PID를 알고 있으므로, 이를 통해 자식 프로세스를 제어 할 수 있다.

자식 프로세스는 부모 프로세스의 PID 와 PPID(Parent Process ID)를 알고 있어, 이를 통해 부모 프로세스와 통신이 가능하다.

다만, 통신이 가능할 뿐이지, **부모 프로세스와 자식 프로세스는 엄연히 서로 다른 프로세스로 독립적으로 실행**되며, **독립적인 메모리 공간**을 가지고 있어서 **서로 다른 작업을 수행**한다.
예로는 웹 브라우저의 탭 이나 새창을 들 수 있다. 각 브라우저 탭은 같은 브라우저 프로그램 실행이지만, 각기 다른 사이트 실행을 행하기 때문이다.

서로 독립적이라는 것을 확인하기 위해서는 브라우저에서 갭라자 도구를 연다음 무한 루프 코드를 실행 시켜보면, 해당 탭에서는 클릭도 안되고 먹통이 되지만 다른 탭은 정상적으로 동작하는 것을 확인 할 수 있다.

- **장점**:
   - 안정성: 한 프로세스의 오류가 다른 프로세스에 영향을 미치지 않아 시스템 전체의 안정성이 유지됩니다.
   - 보안: 프로세스 간의 격리로 인해 보안이 강화됩니다.
- **단점**:
   - 오버헤드: 프로세스 간 커뮤니케이션(IPC)이 복잡하고, 자원 소모가 큽니다.
   - 리소스 사용: 각 프로세스가 별도의 메모리와 시스템 자원을 사용하기 때문에 리소스 사용이 비효율적일 수 있습니다.

## Multi Thread

스레드는 **하나의 프로세스 내에 있는 실행 흐름**이다. 그리고 멀티 스레드는 **하나의 프로세스 안에 여러개의 스레드가 있는 것**을 말한다. 따라서 하나의 **프로그램에서 두가지 이상의 동작을 동시에 처리하도록 하는 행위가 가능**해진다.

즉, 멀티 스레드는 하나의 프로세스 내에서 여러 개의 스레드가 동시에 실행되는 환경을 말합니다. 모든 스레드는 프로세스의 메모리 공간을 공유한다.

웹 서버는 대표적인 멀티 스레드 응용 프로그램이다. 사용자가 서버 데이터베이스에 자료를 요청하는 동안 브라우저의 다른 기능을 이용할 수 있는 이유도 바로 멀티 스레드 기능 덕분이니 것이다. 즉, 하나의 스레드가 지연되더라도, 다른 스레드는 작업을 지속할 수 있다

멀티 프로세스와 차이점을 부각시키기 위해, 멀티 프로세스를 설명할때 예시를 들었던 웹 브라우저를 다시 들어보면, **멀티 프로세스는 웹 브라우저에서의 여러 탭**이나 **여러창** 이라면, 멀티 스레드는 **웹 브라우저의 단일 탭 또는 창 내에서 브라우저 이벤트 루프, 네트워크 처리, I/O 및 기타 작업을 관리**하고 처리하는데 사용된다.

- **장점**:
   - 효율성: 스레드 간의 커뮤니케이션 비용이 낮고, 컨텍스트 스위칭이 빠릅니다.
   - 자원 공유: 메모리 및 자원을 공유하여 효율적인 리소스 사용이 가능합니다.
- **단점**:
   - 안정성과 보안 문제: 하나의 스레드에서 발생한 오류가 전체 프로세스에 영향을 줄 수 있으며, 스레드 간 데이터 공유로 인해 **동기화 문제**가 발생할 수 있습니다.

> **동기화란?**
> 스레드에서의 동기화는 **멀티스레딩 환경에서 여러 스레드가 공유 자원에 동시에 접근할 때 발생할 수 있는 문제들을 관리하고, 데이터의 일관성과 정확성을 유지하기 위한 방법**입니다.
>

> **동기화 적업
여러 스레드들이 자원에 대한 접근을 순차적으로 통제 하는 것**
> 동시 접근으로 인한 동시 수정과 같은 현상은 일어나지 않게 된다. 그러나 동기화 작업은 여러 스레드 접근을 제한하는 것이기 때문에 **병목 현상**이 일어나 성능이 저하될 가능성이 높다는 단점이 있다.
> 이를 해결하기 위해 임계 영역(Critical Section)에 대하여 뮤텍스(mutex), 또는 세마포어(Semaphore) 방식을 활용한다.
>
> - **임계 영역(Critical Section)**: 여러 스레드가 동시에 접근해서는 안 되는 코드 영역. 일반적으로 공유 자원을 처리할 때 사용됩니다.
> - **뮤텍스(Mutex)**: 임계 영역에 대한 접근을 제어하기 위한 잠금 메커니즘. 한 번에 하나의 스레드만 임계 영역에 접근할 수 있습니다.
> - **세마포어(Semaphore)**: 뮤텍스와 유사하지만, 동시에 여러 스레드가 임계 영역에 접근할 수 있도록 허용하는 카운터 기반의 메커니즘입니다.

> **동기화와 관련된 문제**
>
> - **데드락(Deadlock)**: 둘 이상의 스레드가 서로의 락 해제를 무한히 기다리는 상황으로, 프로그램이 정지하는 원인이 됩니다.
> - **라이브락(Livelock)**: 스레드들이 서로를 방해하지 않도록 반복적으로 상태를 변경하지만, 실제로는 어떤 작업도 진행되지 않는 상황입니다.
> - **스타베이션(Starvation)**: 특정 스레드가 공유 자원에 접근하지 못하고 무한히 대기하는 상황입니다.

## 멀티스레딩 모델

CPU는 OS 스케쥴러가 예약하는 커널 스레드만 할당 받아서 실행하기 때문에 사용자 수준 스레드는 커널 수준 스레드와의 매핑이 필요하다.  
  
멀티스레딩 모델은 운영 체제가 프로세스 내의 스레드를 어떻게 관리하고 스케줄링하는지에 대한 접근 방식을 말한다. 사용자 수준 스레드는 다음과 같은 방법으로 커널수준 스레드와 매핑한다. 주요 모델에는 대표적으로 "일대일(1:1)", "다대일(N:1)", "다대다(M:N)" 모델이 있고 각 모델은 스레드 생성, 관리, 스케줄링의 방법과 운영 체제와의 상호작용에서 차이를 보인다.  
  
![maxresdefault.jpg](src%2Fresources%2Fstatic%2Fimg%2Fmaxresdefault.jpg)

### 다대일 스레드 매핑 (many to one thread mapping)

다수의 사용자 수준 스레드가 커널 수준 스레드 한개에 매핑하는 유형으로 사용자 수준의 스레드 모델이라 볼 수 있다.  
 
이때 커널수준의 스레드는 사용자 수준의 스레드를 전혀 알지 못한다. 커널 수준의 스레드는 사용자 수준의 스레드의 TCB 정보를 가지고 있지 않기 때문이다. 이는 사용자 수준의 스레드가 몇개가 있고 현재 선점된 스레드는 무엇이며 어떤식으로 컨텍스트 스위칭할지를 알 수 없다. 두 개의 영역은 서로 매핑은 되어 있지만 서로의 정보를 알지는 못한다.  
  
**그러면 매핑은 왜** 시키는 것일까??  
그 이유는 CPU는 커널 수준의 스레드만 인식한다. 즉, CPU는 직접적으로 사용자 수준의 스레드를 인식할 수 없기 때문에 사용자 수준에서 실행되는 모든 코드들은 먼저 커널 스레드에게 전달된 후 CPU에게 할당 받는 목적으로만 매핑을 하는 것이다.

- **장점**:
   - 스레드 관리에 필요한 오버헤드가 낮습니다.
      - 커널 개입 없이 사용자 스레드끼리의 스위칭이 발생하기 때문에 오버헤드가 적다.
      - 스케쥴링이나 동기화를 하려고 커널을 호출하지 않으므로 커널 영역으로 전환하는 오버헤드가 줄어든다
   - 사용자 수준에서 스레드 스케줄링을 제어할 수 있습니다.
- **단점**:
   - 멀티코어 CPU를 효율적으로 사용하기 어렵습니다.
   - 하나의 스레드가 블록되면 모든 스레드가 블록될 수 있습니다.
- **예시**: 구형 UNIX 시스템, 자바에서 초기 버전의 Green Thread

### 일대일 스레드 매핑 (one to one thread mapping)

사용자 수준 스레드와 커널 수준 스레드가 일대일로 매핑하는 유형으로 커널 **수준의 스레드 모델**이라 볼 수 있다. 커널이 전체 프로세스와 스레드 정보를 유지해야 하기 때문에 컨텍스트 스위칭 시 사용자 모드에서 커널 모드로 전환해서 스케줄링 하는 등의 오버헤드가 발생한다. 
  
해당 매핑은 사용자 수준의 스레드는 생성만 해두고 모든 관리는 커널수준 스레드에서 관리하게된다.(TCB를 커널수준 스레드에서 관리)
- **장점**:
   - 멀티코어 CPU에서 효율적입니다. 각 스레드가 다른 CPU 코어에서 동시에 실행될 수 있습니다.
   - 하나의 스레드에 문제가 발생해도 다른 스레드에 영향을 덜 미칩니다.
- **단점**:
   - 스레드 생성과 관리에 더 많은 시스템 자원이 필요합니다.
   - 자원 한정으로 인해 스레드를 무한정 생성할 수 없다. 대안으로 스레드 풀을 활용하기도 한다.
- **예시**: Linux, Windows, MacOS.

### 다대다 스레드 매핑(many to many thread mapping)

여러 개의 사용자 수준 스레드를 같은 수 또는 그 보다 작은 수의 커널 수준 스레드로 매핑하는 유형이다. 각 커널 수준의 스레드가 사용자 수준의 스레드 한개 이상과 매핑된다.다대다 모델은 다대일, 일대일 모델의 단점을 어느 정도 해결하여, 개발자는 필요한 만큼 많은 사용자 수준 스레드를 생성할 수 있고 커널 수준 스레드가 멀티 프로세서에서 병렬로 수행될 수 있다

- **특징**: 여러 사용자 수준 스레드가 여러 커널 스레드와 대응됩니다.
- **장점**:
   - 스레드 관리의 유연성이 높고, 멀티코어 CPU 환경에서 효과적입니다.
   - 사용자 수준과 커널 수준에서 스레드를 동시에 관리할 수 있습니다.
- **단점**:
   - 구현의 복잡성이 높고, 오버헤드 관리가 어렵습니다.
- **예시**: Solaris, 구형 버전의 Windows.

사용자 수준 스레드가 I/O 시스템 콜을 발생시켰을 때, 커널이 다른 스레드의 수행을 스케줄 할 수 있다  
  
# 자바 스레드 구조
자바 스레드는 JVM 에서 사용자 수준 스레드를 생성할 때 시스템 콜을 통해서 커널에서 생성된 커널 스레드와 1:1 매핑이 되어 최종적으로 커널에서 관리 됩니다. JVM 에서 스레드를 생성할때 마다 커널에서 자바 스레드와 대응하는 커널 스레드를 생성한다. 자바에서는 Platform Thread 으로 정의되어있다. 즉 OS 플랫폼에 따라 JVM 이 사용자 스레드를 매핑하게된다

> **Platform threads**
"플랫폼 스레드(Platform Thread)"라는 용어는 일반적으로 **특정 운영 체제에서 네이티브로 제공하는 스레드**를 가리킵니다. 자바에서 스레드를 생성할 때, JVM(Java Virtual Machine)은 내부적으로 운영 체제의 스레드 시스템을 사용하여 이러한 스레드를 구현합니다. 즉, 자바 스레드는 운영 체제의 플랫폼 스레드에 매핑됩니다.

**네이티브 스레드**
"네이티브 스레드"는 **특정 운영 체제에서 지원하는 스레드**를 의미합니다. 이는 운영 체제의 API를 통해 생성되고 관리됩니다.
****주로 프로그래밍 언어나 애플리케이션 수준에서 운영 체제의 스레드를 사용할 때 쓰입니다. 자바 애플리케이션에서 생성된 스레드가 운영 체제의 API를 통해 생성되고 관리되는 스레드를 가리키는데 사용됩니다. 네이티브 스레드는 JVM과 같은 런타임 환경에 의해 추상화되어 관리되며, 이는 운영 체제의 커널 스레드에 매핑됩니다.

### **JVM에서의 스레드 처리**

JVM은 자바 애플리케이션을 실행하는 환경입니다. JVM 내부에서 스레드는 다음과 같이 처리됩니다:

- JVM은 각 스레드에 대한 메모리 할당(스택 등)을 관리합니다.
- 자바 스레드는 내부적으로 OS의 네이티브 스레드에 매핑됩니다. 이 매핑은 JVM의 스레드 모델과 OS에 따라 다를 수 있습니다.
- JVM은 스레드의 생명주기(생성, 시작, 실행, 종료)를 관리합니다.

### **OS 스레드 스케줄링과의 차이**

- **운영 체제 수준의 스레드**: 운영 체제는 자체 스레드 스케줄러를 가지고 있으며, 모든 스레드(시스템 스레드 및 사용자 애플리케이션 스레드)를 관리합니다. 이 스케줄러는 CPU 시간을 스레드에 할당하고, 스레드의 실행 순서를 결정합니다.
- **자바 스레드**: 자바에서 생성된 스레드는 결국 OS의 네이티브 스레드로 매핑됩니다. 즉, 실제 스레드의 스케줄링은 OS에 의해 이루어집니다. JVM은 스레드 생성, 관리, 종료 등의 과정을 추상화하고, 자바 프로그래머가 OS에 직접적으로 의존하지 않고 스레드를 사용할 수 있게 합니다.

## 스레드 생성

자바에서 스레드는 주로 두 가지 방법으로 생성됩니다:

1. **`Thread`** 클래스를 상속받아서 구현.
2. **`Runnable`** 인터페이스를 구현.

1. **`Thread` 클래스 상속**:

    ```java
    class MyThread extends Thread {
        public void run() {
            // 스레드가 수행할 작업
        }
    }
    
    Thread thread = new MyThread();
    thread.start(); // 스레드 시작
    
    ```

    - 작업 내용을 스레드 내부에 직접 재정의해서 실행
2. **`Runnable` 인터페이스 구현**:

    ```java
    class MyRunnable implements Runnable {
        public void run() {
            // 스레드가 수행할 작업
        }
    }
    
    Thread thread = new Thread(new MyRunnable());
    thread.start(); // 스레드 시작
    
    ```

    - 작업 내용을 Runnable 에 정의해서 스레드에 전달
3. **람다 표현식 사용 (Java 8 이상)**:

    ```java
    Runnable task = () -> {
        // 스레드가 수행할 작업
    };
    
    Thread thread = new Thread(task);
    thread.start(); // 스레드 시작
    
    ```


1. **Thread 익명 클래스**

    ```java
    Thread thread = new Thread() {
        public void run() {
            // 스레드가 실행할 코드
            System.out.println("Thread 익명 클래스 사용");
        }
    };
    
    thread.start(); // 스레드 시작
    ```

    - 일회용으로만 사용할때
2. **Runnable 익명 클래스**

    ```java
    Runnable runnable = new Runnable() {
        public void run() {
            // 스레드가 실행할 코드
            System.out.println("Runnable 익명 클래스 사용");
        }
    };
    
    Thread thread = new Thread(runnable);
    thread.start(); // 스레드 시작
    ```


### **스레드 상태 변경 메소드**

1. **`start()`**: 새로운 스레드를 시작하고, 스레드의 **`run()`** 메소드를 호출합니다.
2. **`run()`**: 스레드가 수행할 작업을 정의합니다.
3. **`sleep(long millis)`**: 현재 스레드를 지정된 시간(밀리초) 동안 일시 중지합니다.
4. **`join()`**: 스레드가 종료될 때까지 현재 스레드의 실행을 중지합니다.
5. **`interrupt()`**: 스레드에 인터럽트를 보냅니다. 인터럽트에 응답하는 방식은 스레드의 **`run()`** 메소드 구현에 달렸습니다.
6. **`yield()`**: 현재 스레드가 실행 중지를 하고 다른 스레드에 실행 기회를 제공합니다.

### **기타 메소드**

- **`setPriority(int newPriority)`**: 스레드의 우선순위를 설정합니다.
- **`getPriority()`**: 스레드의 현재 우선순위를 반환합니다.
- **`setName(String name)`**: 스레드의 이름을 설정합니다.
- **`getName()`**: 스레드의 이름을 반환합니다.
- **`isAlive()`**: 스레드가 살아 있는지(시작되었고 아직 종료되지 않았는지) 확인합니다.
- **`isInterrupted()`**: 스레드가 인터럽트 되었는지 확인합니다.
- **`static interrupted()`**: 현재 스레드의 인터럽트 상태를 확인하고, 인터럽트 상태를 초기화합다.  

# 스레드 실행

자바 스레드는 OS 스케줄러에 의해 실행 순서가 결정되며 스레드 실행 시점을 JVM 에서 제어할 수 없고 새로운 스레드는 현재 스레드 와 독립적으로 실행되고 최대 한번 시작할 수 있고 스레드가 종료된 후에는 다시 시작 할 수 없다.

자바에서 스레드 실행 과정을 설명하기 위해, 가장 기본적인 예로 **`main`** 스레드가 다른 스레드를 생성하고 시작하는 과정을 살펴보면 자바에서 스레드 실행 과정은 다음과 같은 단계를 거친다.

1. **스레드 클래스 정의**: 자바에서 스레드를 생성하기 위해서는 **`Thread`** 클래스를 확장하거나 **`Runnable`** 인터페이스를 구현하는 클래스를 정의해야 합니다.
2. **스레드 객체 생성**: 정의된 스레드 클래스 또는 **`Runnable`** 객체를 기반으로 **`Thread`** 객체를 생성합니다.
3. **스레드 시작 (`start()` 메소드 호출)**: 생성된 스레드 객체에 대해 **`start()`** 메소드를 호출합니다. 이 메소드는 스레드를 실행 가능한 상태로 만들고, 자바 가상 머신(JVM)에 이 스레드를 시작하도록 요청합니다.
4. **`private native void start0()` 메소드 호출**: 내부적으로 **`start()`** 메소드는 네이티브 메소드인 `private native void start0()`을 호출합니다. 이 메소드는 운영 체제 수준에서 새로운 스레드를 생성하고(커널 스레드가 생성되고 자바 스레드와 커널 스레드가 1대1 매핑이 이루어짐), 스레드에 할당된 **`run()`** 메소드를 실행합니다.
5. **실행 대기** : OS 스케줄러로 부터 CPU 할당을 받기까지 실행 대기 상태에 있는다.
6. **스레드 실행 (`run()` 메소드 실행)**: **`run()`** 메소드는 스레드가 수행해야 할 작업을 정의합니다. **`start0()`**에 의해 호출되면, 이 스레드는 **`run()`** 메소드에 정의된 작업을 수행하기 시작합니다.(커널 스레드가 스케줄러에 의해 실행상태가 되면 JVM 에서 매핑된 자바 스레드의 run() 메소드를 호출한다.)
7. **스레드 종료**: **`run()`** 메소드의 실행이 완료되면, 스레드는 자동적으로 종료됩니다.

> **네이티브 메소드(native method)**
> 네이티브 메소드(native method)는 자바에서 사용되는 **특별한 유형의 메소드**로, **자바 코드가 아닌 네이티브 프로그래밍 언어(보통 C나 C++)로 작성된 코드를 실행**합니다. 이러한 메소드들은 자바 네이티브 인터페이스(Java Native Interface, JNI)를 사용하여 구현됩니다.
>

예를 들어, **`main`** 스레드에서 새로운 스레드를 생성하고 시작하는 간단한 예제

```java
public class MyThread extends Thread {
    public void run() {
        System.out.println("새로운 스레드 실행 중");
    }

    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start(); // 여기에서 start0()가 내부적으로 호출되고, 스레드 실행이 시작됩니다.
    }
}

```

이 과정을 통해, 자바 프로그램에서는 멀티스레딩을 효과적으로 관리하고, 여러 작업을 동시에 수행할 수 있다.

즉, `start()` 는 스레드를 실행 시키는 메소드로 **시스템 콜을 통해서 커널에 스레드 생성을 요청 `run()`** 는 **스레드가 실행이 되면 해당 스레드에 의해 자동을 호출**되며 Thread 의 run() 이 자동으로 호출되고 여기서 Runnable 구현체가 존재할 경우 Runnable 의 run()을 실행한다. public static void main 가 메인 스레드에 의해 자동으로 호출되는 것과 비슷한 원리이다.

이때 start() 메소드가 아니라 바로 run() 메소드를 직접 호출하면 새로운 스레드가 생성되지 않고 직접 호출한 스레드의 실행 스택에서 run()이 실행된다.

1. **`start()` 메소드 호출**:
    - 새로운 스레드를 생성합니다. **`start()`** 메소드가 호출되면, 자바 가상 머신(JVM)은 새로운 스레드를 배치하고, 이 스레드에서 **`run()`** 메소드를 실행합니다.
    - **`start()`** 메소드는 내부적으로 네이티브 메소드를 호출하여 실제 운영 체제 스레드를 생성하고, 해당 스레드에서 **`run()`** 메소드를 별도의 실행 경로(execution path)에서 실행합니다.
    - 이렇게 하면 **`run()`** 메소드는 병렬로 실행되며, 다른 스레드와 동시에 실행될 수 있습니다.
2. **`run()` 메소드 직접 호출**:
    - **`run()`** 메소드를 직접 호출하는 것은 일반 메소드 호출과 같으며, 새로운 스레드를 생성하지 않습니다.
    - 이 경우, **`run()`** 메소드는 현재 스레드(예: **`main`** 스레드)에서 실행되며, 병렬 실행이 아니라 순차적으로 실행됩니다.
    - **`run()`**을 직접 호출하면 멀티스레딩의 이점을 활용할 수 없으며, 단순히 **`run()`** 메소드에 정의된 코드를 현재 스레드에서 실행하는 것과 같습니다.

결론적으로, 멀티스레딩을 활용하려면 반드시 **`start()`** 메소드를 호출해야 하며, **`run()`** 메소드를 직접 호출하는 것은 단순한 메소드 호출로서, 새로운 스레드를 생성하거나 병렬 실행을 하지 않는다.

### 스레드 스택

스레드가 생성되면 해당 스레드를 위한 스택이 같이 생성되면 이 스택은 각 스레드마다 독립적으로 할당되어 동작하기 때문에 서로간 접근이나 공유할 수 없다. 이 스택은 OS에 따라 크기가 주어지고 주어진 크기를 넘기게 되면 그 유명한 `StackOverFlowError` 가 발생하게 된다.

이 스택은 **스레드가 함수 호출을 수행할 때 필요한 데이터를 저장하는 데 사용**한다.

> **스택 프레임(Stack Frame)**
> 스택 프레임(Stack Frame)은 프로그램의 함수 호출과 실행에 필요한 정보를 저장하는 스택(Stack) 내의 데이터 구조입니다. 각 함수 호출 시에 하나의 스택 프레임이 생성되며, 이 프레임은 해당 함수가 실행되는 동안 필요한 다양한 정보를 포함합니다.
>

### 구성 정보

스레드 스택은 주로 로컬 변수(지역변수, 파라미터), 함수 호출 정보, 반환 주소 등을 저장하는 데 사용됩니다. 함수 호출이 발생할 때마다, 호출된 함수의 로컬 변수와 매개변수가 스택에 푸시(push)됩고 함수가 반환될 때, 해당 데이터는 스택에서 팝(pop)되어 제거된다.

**1. 스택 프레임(Stack Frame)**

- 스레드 스택은 여러 개의 스택 프레임으로 구성됩니다. 각 스택 프레임은 개별 함수 호출에 대한 정보를 담고 있습니다.
- 함수가 호출될 때마다 새로운 스택 프레임이 스택에 푸시되고, 함수가 반환될 때 해당 프레임은 스택에서 팝됩니다.

**2. 로컬 변수(Local Variables)**

- 각 스택 프레임은 해당 함수의 로컬 변수를 저장합니다. 이러한 변수는 함수 호출이 끝날 때까지 유효합니다.

**3. 매개변수(Parameters)**

- 함수로 전달되는 매개변수는 대부분 스택 프레임 내에 저장됩니다. 이를 통해 함수 내에서 매개변수에 접근할 수 있습니다.

**4. 반환 주소(Return Address)**

- 함수가 호출될 때, 함수가 반환될 때 다시 돌아갈 위치의 주소(반환 주소)가 스택에 저장됩니다. 함수 실행이 끝나면, 이 주소를 사용하여 호출자 함수로 돌아갑니다.

**5. 스택 포인터(Stack Pointer)**

- 스택 포인터는 스택의 현재 위치를 가리킵니다. 새로운 스택 프레임이 푸시되거나 팝될 때마다 스택 포인터가 업데이트됩니다.

**6. 프레임 포인터(Frame Pointer)**

- 프레임 포인터는 현재 활성화된 스택 프레임의 시작 부분을 가리키는데 사용됩니다. 이를 통해 현재 함수의 로컬 변수와 매개변수에 접근할 수 있습니다.

**7. 임시 저장 공간(Temporary Space)**

- 함수의 계산 중간 결과를 임시로 저장하는 공간입니다. 이 공간은 스택 프레임 내에서 필요에 따라 사용됩니다.

**8. 예외 처리 정보(Exception Handling Information)**

- 일부 프로그래밍 언어에서는 함수 내에서 발생할 수 있는 예외 처리를 위한 정보를 스택 프레임에 저장합니다.

### 스텍 메모리 상태 관리

스택은 제한된 크기를 갖으며, 일반적으로 운영 체제나 JVM 설정에 따라 결정된다. 스택 오버플로(stack overflow)는 스택이 할당된 메모리 크기를 초과할 때 발생하고 이는 무한 재귀 호출로 인해 발생할 수 있습니다. 스택 내부의 변수는 변수를 생성한 메소드가 실행되는 동안에만 존재하고 스택 메모리에 대한 접근은 Heap 메모리와 비교할때 상당히 빠르다.

### 스레드 종료

스레드는 run() 메소드가 모두 실행되면 자동으로 종료한다. 이때 예외가 발생할 경우 또한 종료되며 다른 스레드에 영향을 미치지 않는다.어플리케이션은 싱글스레드인 경우와 멀티스레드인 경우 종료 기준이 다르다.  

스레드들은 비동기적으로 실행한다. 즉 각 스레드들은 독립적으로 실행해서 본인의 스택에 있는 작업을 실행하고 종료한다.

### **싱글 스레드 어플리케이션**

- 싱글 스레드 어플리케이션에서는 주로 하나의 실행 흐름만 존재합니다.
- **종료 기준**: 주 스레드(main thread)의 실행이 종료되면, 어플리케이션의 실행도 종료됩니다. 이는 보통 주 스레드의 **`main`** 함수나 유사한 진입점(entry point)의 코드가 모두 실행 완료되었을 때 발생합니다.
- 특별한 예외 처리나 중단 요청이 없는 한, **`main`** 함수 내의 코드가 순차적으로 모두 실행된 후 어플리케이션이 종료됩니다.

### **멀티스레드 어플리케이션**

- 멀티스레드 어플리케이션에서는 여러 개의 동시 실행 흐름(스레드)이 존재합니다.
- **종료 기준**: 멀티스레드 환경에서 어플리케이션의 종료 기준은 프로그래밍 언어와 환경에 따라 다를 수 있습니다. 일반적으로는 다음 두 가지 방법 중 하나를 따릅니다:
    - **모든 스레드의 종료**: 주 스레드와 모든 백그라운드 스레드가 종료될 때까지 어플리케이션이 실행 상태를 유지합니다.
    - **주 스레드의 종료만으로 충분**: 일부 환경(예: 일부 자바 어플리케이션)에서는 주 스레드가 종료되면 어플리케이션이 종료되며, 이 때 모든 백그라운드 스레드도 강제 종료됩니다. 다만, 이 경우에도 대기 중인 '데몬 스레드(daemon threads)'가 있다면 이들은 주 스레드 종료와 함께 즉시 중단됩니다.  
  
단 스레드 유형이 데몬 스레드 일 경우 위 내용과 일부 다른점이 있다.

## 스레드의 상태

자바 스레드는 생성과 실행 그리고 종료에 따른 상태를 가지고 있으며 JVM 에서는 6가지의 스레드 상태가 존재한다. 이때 OS 스레드의 상태를 의미하지 않는다. 이 상태는 Thread의 `getState()` 메소드를 통해서 가져올 수 있으며 ENUM 상수를 정의하는 Tread.State 클래스를 제공한다. 이때 스레드의 상태는 6가지중 **단 하나의 상태만**을 가질 수 있다.

| 상태 | 설명 |
| --- | --- |
| 신규 (New) | 스레드 객체가 생성되었지만 start() 메소드가 아직 호출되지 않은 상태. |
| 실행 가능 (Runnable) | start() 메소드가 호출된 후, 실행을 위해 CPU 시간을 기다리는 상태. 실행 중과 실행 대기 상태를 포함. |
| 블록 (Blocked) | 다른 스레드가 사용 중인 객체의 잠금(락)을 얻지 못하고 대기하는 상태. |
| 대기 (Waiting) | 다른 스레드의 작업이 완료될 때까지 기다리는 상태. Object.wait(), Thread.join(), LockSupport.park()에 의해 발생. |
| 시간 대기 (Timed Waiting) | 지정된 시간 동안 대기하는 상태. Thread.sleep(), Object.wait(long timeout), Thread.join(long millis) 등에 의해 발생. |
| 종료 (Terminated) | 스레드의 실행이 완료된 상태. run() 메소드가 완료되거나 예외로 인해 종료됨. |

## 스레드 생명주기
스레드는 프로세스 내에서 실행되는 실행 단위이다. 스레드의 생명주기는 다음과 같다

1. 객체 생성 상태(New): 스레드가 생성되고 초기화됩니다. 객체는 생성 되었지만 아직 start() 메소드가 호출 되지 않은 상태로 JVM 에는 개체가 존재 하지만 아직 커널로의 실해은 안된 상태
2. 준비 (Ready or Runnable): 스레드가 실행을 위해 준비되며 CPU 할당을 기다립니다. start() 메소드를 실행 하면 내부적으로 커널로의 실행이 일어나 커널 스레드와 1:1 매핑이 된다. 바로 실행 상태가 아닌 실행 준비가 되어 있는 실행 가능한 상태로 스레드가 실행 상태로 전환하기 위해서는 현재 스레드가 어떤 상태로 존재하든지 반드시 실행 대기 상태를 거쳐야 한다.
3. 스케줄링 : 실행 가능한 스레드에게 실행할 시간을 제공(OS 스케줄러의 책임)한다. 스케줄러는 멀티 스레드 환경에서 각 스레드에게 고정된 시간을 할당해서 실행 상태와 실행 가능 상태를 오가도록 스케줄링 한다.
4. 실행 (Running:실제 생명 주기에는 Runnable 에 포함된 개념) : 스레드가 CPU를 할당받아 실행됩니다(run() 메소드를 호출). 스레드는 아주 짧은 시간동안 실행된 다음 다른 스레드가 실행될 수 있도록 CPU를 일시 중지하고 다른 스레드에게 양도한다(컨텍스트 스위칭). 
   - 실행 상태 -> 실행 대기 상태 : 실행 상태에서 스레드의 yield() 메소드를 호출하거나 운영체제 스케줄러에 의해 CPU 실행을 일시 중지하는 경우 실행 가능한 상태로 전환한다.
5. 대기 상태
   - 일시 정지 상태(Timed Waiting 지정된 시간이 있는 경우) : 스레드 sleep 및 time-out 매개 변수가 있는 메소드를 호출할때 시간이 지정된 대기 상태가 된다. 스레드의 대기 시간이 길어지고 CPU의 할당을 계속 받지 못하는 상황이 발생하면 기아 상태가 발생하게 되는데 이 상황을 피할 수 있다.
   - 블록 (Blocked): 스레드가 동기화 된 임계 영역에 접근을 시도하다가 Lock을 획득하지 못해서 대기하는 상태이다. 스레드는 Lock을 획득할때 까지 대기한다. 이때 스레드가 Lock을 획득하면 실행 대기 상태가 된다.
   - 대기 (Waiting) : 스레드가 실행 상태에서 다른 스레드가 특정 작업을 수행하기를 기다리는 상태, wait()은 다른 스레드에 의해 notify()받을때까지, join()은 스레드의 실행이 종료되거나 인터럽트가 발생할 때까지 대기한다.
     - 스레드 A,B가 실행 중일때 A 스레드에서 B.join()을 호출하면 A스레드는 B스레드가 종료될때까지(run() 메소드가 완료 될때 까지) 대기하게 된다. B 스레드의 작업이 끝난 후에 다시 A 스레드의 작업을 시작한다.
   - 대기 상태에서 깨어난다 : 지정한 시간이 지나거나 다른 스레드에 의해서 인터럽트(interrupt())가 발생하거나 대기가 해제되도록 통지(notify() or notifyAll())를 받게 되면 실행대기 상태가 된다.
6. 종료 (Terminated): 스레드가 작업을 완료하거나 오류 또는 처리되지 않은 예외와 같이 비정상적으로 종료된 상태
  
스레드의 실행 관점에서 보면 출발지가 스레드의 **start()** 메소드 실행 이라면 목적지는 **run()** 메소드 실행이 된다는 점이다.

> **스케줄러가 고정된 시간을 할당 하는 이유**  
> 이 과정은 "시간 할당(time slicing)" 또는 "시간 분할(time sharing)"이라고 합니다.
> 1. **자원 공정 분배:** 각 스레드에 고정된 시간을 할당함으로써, 모든 스레드가 CPU 시간을 공정하게 사용할 수 있습니다. 이는 한 스레드가 CPU를 독점하는 것을 방지하여 시스템의 반응성과 성능을 향상시킵니다.
> 2. **반응성 향상:** 시간 할당을 통해 여러 스레드가 거의 동시에 실행되는 것처럼 보이게 할 수 있습니다. 이는 특히 사용자 인터페이스와 같이 빠른 반응이 필요한 애플리케이션에서 중요합니다.
> 3. **교착 상태 방지:** 스레드들이 자원을 기다리면서 무한히 대기하는 교착 상태(deadlock)를 방지할 수 있습니다. 시간 할당을 통해 모든 스레드가 일정 시간 이후에는 자원을 사용할 기회를 가지게 됩니다.
> 4. **멀티태스킹:** 시간 할당은 멀티태스킹을 가능하게 하는 핵심 메커니즘입니다. 각 스레드가 동시에 실행되는 것처럼 보이게 하여, 여러 작업을 효율적으로 처리할 수 있습니다.
> 5. **자원 관리 최적화:** OS 스케줄러는 시스템의 전반적인 자원을 관리하고 최적화합니다. 시간 할당을 통해 CPU 사용, 메모리 접근 등을 효과적으로 조절할 수 있습니다.

## 스레드 기본 API
## 1. sleep()

Java에서 **`Thread.sleep()`** 메소드는 현재 실행중인 스레드를 지정된 시간 동안 일시 중지시키는 데 사용된다. 이 메소드는 스레드가 일정 시간 동안 작업을 하지 않도록 하여, 다른 스레드가 CPU 자원을 사용할 수 있도록 한다. **네이티브 메소드로 연결되며 시스템 콜을 통해 커널모드에서 수행 후 유저 모드로 전환**한다.

즉, **`Thread.sleep()`** 메소드를 호출할 때 스레드의 상태는 "**실행 중(Runnable)**"에서 "**일시 중지 상태(Timed Waiting)**"로 **변경**됩니다.

### 기본 코드

```java
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    e.printStackTrace();
    // 적절한 예외 처리
}
```

### API

### **1. Thread.sleep(long millis)**

이 형태의 **`sleep()`** 메소드는 스레드를 밀리초 단위로 일시 중지시킵니다.

- **파라미터**: **`millis`** - 스레드가 일시 중지될 밀리초 단위의 시간. 단 밀리초에 대한 인수 값은 음수가 될 수 없으며 음수 일 경우 IllegalArgumentException 이 발생
- **사용 예**: **`Thread.sleep(1000);`**은 스레드를 1초 동안 일시 중지시킵니다.

### **2. Thread.sleep(long millis, int nanos)**

이 형태의 **`sleep()`** 메소드는 스레드를 밀리초와 나노초를 결합한 형태로 일시 중지시킵니다.

- **파라미터**:
    - **`millis`** - 스레드가 일시 중지될 밀리초 단위의 시간.
    - **`nanos`** - 추가적으로 스레드가 일시 중지될 나노초 단위의 시간 (0에서 999999까지).
- **사용 예**: **`Thread.sleep(1000, 500000);`**은 스레드를 1초와 500,000나노초(0.5초) 동안 일시 중지시킵니다.

### 관련 예외

### **InterruptedException**

- **원인**: 현재 스레드가 sleep, wait, join 등의 중단 상태에 있을 때, 다른 스레드가 이 스레드를 깨우려고 **`interrupt()`** 메소드를 호출하면 발생합니다.
- **처리 방법**: 이 예외는 checked 예외로, 반드시 try-catch 블록을 사용하거나 메소드 선언에 예외를 명시해야 합니다.
- **일반적인 사용 예**: 스레드가 일정 시간 동안 대기한 후에 다시 작업을 수행해야 하는 경우, 또는 스레드를 안전하게 종료시키기 위해 사용됩니다.  

InterruptedException 예외가 발생하면 스레드는 대기상태에서 실행대기 상태로 전환되어 실행 상태를 기다린다.

### 예시

두 개의 스레드, 즉 스레드 1과 스레드 2가 있으며, 스레드 1이 **`sleep()`** 메소드를 사용하여 일시 중지 상태에 들어가고, 이후 스레드 2가 스레드 1에게 인터럽트를 보내는 상황을 가정해보자.

### **초기 상황**

1. **스레드 1 실행**: 스레드 1은 실행 상태에 있다. 이 때 스레드는 CPU 자원을 사용하고 있으며, 작업을 수행하고 있다.
2. **스레드 1 일시 중지**: 스레드 1이 **`Thread.sleep()`** 메소드를 호출한다. 이 호출로 인해 스레드 1은 일시 중지 상태인 "시간 대기 상태(Timed Waiting)"로 전환되고 이 상태에서는 스레드 1이 CPU 자원을 사용하지 않으며, 지정된 시간 동안 대기하게 된다.

### **컨텍스트 스위칭**

1. **스레드 2 실행**: 스레드 1이 대기 상태에 있기 때문에, **스레드 스케줄러**는 스레드 2에게 CPU 자원을 할당한다. 이로 인해 컨텍스트 스위칭이 발생하고, 스레드 2가 실행 상태가 된다. 스레드 2는 이제 작업을 수행할 수 있다.

### **인터럽트 발생**

1. **스레드 2에 의한 인터럽트**: 스레드 2가 어떤 이유로 스레드 1을 깨우기로 결정한다. 이를 위해 스레드 2는 스레드 1의 **`interrupt()`** 메소드를 호출한다. 이 호출은 스레드 1에 인터럽트 신호를 보낸다.

### **스레드 1의 응답**

1. **스레드 1의 상태 변화**: 스레드 1은 인터럽트 신호를 받는다. 이 신호는 스레드 1이 **`sleep()`** 상태에서 깨어나게 만듭니다. 이 때 스레드 1은 "실행 가능(Runnable)" 상태로 전환된다. 하지만 바로 실행 상태로 가는 것은 아니며, **실행을 위해 스레드 스케줄러의 결정을 기다립니다.**
2. **InterruptedException 발생**: 스레드 1은 **`InterruptedException`**을 발생시킵니다. 이 예외는 스레드 1이 **`sleep()`** 메소드에서 **깨어날 때 자동으로 발생**합니다.

### **예외 처리**

1. **스레드 1의 예외 처리**: 스레드 1은 `InterruptedException`을 처리해야 합니다. 이를 위해 스레드 1 내에서 이 예외를 처리하는 코드가 실행됩니다. 이 처리는 스레드가 이 인터럽트에 어떻게 반응할지 결정하는 로직을 포함할 수 있습니다. 예를 들어, 스레드를 안전하게 종료하거나 특정 작업을 재개하는 등의 동작을 수행할 수 있습니다.

### **실행 재개**

1. **스레드 1의 작업 재개**: 예외 처리가 완료된 후, 스레드 1은 다시 스레드 스케줄러에 의해 실행 상태로 전환될 수 있습니다. 이때 스레드 1은 중단되었던 작업을 계속하거나 새로운 작업을 시작할 수 있습니다.

이 과정에서 중요한 점은 스레드가 **`sleep()`** 상태에서 인터럽트될 경우, `InterruptedException`을 적절하게 처리해야 한다는 것이다. 이를 통해 스레드가 예상치 못한 상황에 안전하게 대처하고, 필요한 자원 정리와 상태 관리를 할 수 있다.

### sleep(0) 과 sleep(n)의 의미

sleep(millis) 메서드는 네이티브 메서드이기 때문에 sleep(millis) 을 실행하게 되면 시스템 콜을 호출하게 되어 유저모드에서 커널모드로 전환된다. 이때 다른 스레드에게 명확하게 실행을 양보하기 위함이라면 sleep(0) 보다는 sleep(1)을 사용하는 것이 좋다.

### **Thread.sleep(0)**

**`Thread.sleep(0)`** 호출은 스레드를 0 밀리초 동안 일시 중지시키라는 명령입니다. 이론적으로는 스레드가 대기 상태에 들어갔다가 바로 나오는 것을 의미한다. 실제 효과는 종종 운영체제의 스레드 스케줄러에 의존적인데 이는 스레드가 실행 큐의 끝으로 이동하고, 다른 스레드에게 실행 기회를 제공할 수 있음을 의미한다. 즉, 동일 우선순위를 가진 다른 스레드에게 실행 기회를 양보하는 효과가 있을 수 있습니다. 하지만 만약 우선순위가 동일한 실행대기 상태의 다른 스레드가 없으면 스케줄러는 현재 스레드에게 계속 CPU를 할당해서 컨텍스트 스위칭이 없고 모드 전환만 일어난다.

### **Thread.sleep(n)**

스레드가 커널 모드로 전환 후 스케줄러는 조건에 상관없이 현재 스레드를 대기 상태에 두고 다른 스레드에게 CPU를 할당함으로 모든 전환과 함께 컨텍스트 스위칭이 발생한다.

### 정리

- sleep() 이 되면 OS 스케줄러는 현재 스레드를 지정된 시간 동안 대기 상태로 전환하고 다른 스레드 혹은 프로세스에게 CPU 를 사용하도록 한다
- 대기 시간이 끝나면 스레드 상태는 바로 실행상태가 아닌 실행 대기 상태로 전환 되고 CPU 가 실행을 재개할 때 까지 기다린다.
- 실행 상태가 되면 스레드는 남은 지점부터 실행을 다시 시작한다
- 동기화 메서드 영역에서 **수면 중인 스레드는 획득한 모니터나 락을 잃지 않고 계속 유지**한다
- sleep() 중인 스레드에게 인터럽트가 발생할 경우 현재 스레드는 대기에서 해제되고 실행상태로 전환되어 예외를 처리하게 된다
- 스레드의 수면 시간은 OS 스케줄러 및 시스템 기능에 따라 제한되기 때문에 정확성이 보장되지 않으며 시스템의 부하가 많고 적음에 따라 지정한 수면 시간과 차이가 날 수 있다  

## 2. join()

Java에서 **`Thread`** 클래스의 **`join()`** 메소드는 한 스레드가 다른 스레드의 종료를 기다리는 데 사용된다. **`join()`** 메소드를 호출한 스레드는 지정된 스레드가 종료될 때까지 대기하게 됩니다. 이는 스레드 간의 동기화와 순서를 제어하는 데 유용합니다.즉 스레드의 순서를 제어하거나 다른 스레드의 작업을 기다려야 하거나 순차적인 흐름을 구성하고자 할때 사용한다. 이때 `Object` 클래스의 `wait()` 네이티브 메소드로 연결되며 시스템 콜을 통해 커널모드로 수행한다. 내부적으로는 wait() & notify() 흐름을 가지고 제어한다.  
  
2개의 스레드 T1과 T2가 있을때 T1이 T2의 모든 작업이 종료될때 까지 어떠 시점에 대기했다가 다음 작업을 수행하고 싶다. 이런 상황에서 T1기준으로 T2.join() 메소드를 호출하게 되면 해당 코드가 이후에 있는 코드들은 T2의 작업이 끝나기전 까지는 수행 되지 않는다.

```java
Thread thread = new Thread(() -> {
    // 스레드가 수행할 작업
});
thread.start();

try {
    thread.join();  // 현재 스레드가(메인 스레드) 'thread'의 종료를 기다림
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

### API

### 1. **void join()**

이 메소드는 현재 스레드가 다른 스레드(대상 스레드)의 **`run()`** 메소드가 완료될 때까지 기다리게 합니다. 다시 말해, 대상 스레드가 종료될 때까지 현재 스레드는 대기 상태에 머무릅니다.

### 2. **void join(long millis)**

이 메소드는 현재 스레드가 대상 스레드의 **`run()`** 메소드 완료 또는 지정된 시간(밀리초 단위)이 경과할 때까지 기다리게 합니다. 시간이 만료되면, 대기 중인 스레드는 자동으로 다시 실행 상태로 돌아갑니다.

### 3. **void join(long millis, int nanos)**

이 메소드는 현재 스레드가 대상 스레드의 **`run()`** 메소드 완료 또는 지정된 시간(밀리초와 나노초를 결합한 형태)이 경과할 때까지 기다리게 합니다. 이때 나노초의 범위는 0에서 999999 이다.

### 관련 예외

### **InterruptedException**

- **원인**: 현재 스레드가 **`join()`**, **`wait()`**, **`sleep()`** 등의 메소드로 인해 대기 상태에 있을 때, 다른 스레드가 이 스레드의 **`interrupt()`** 메소드를 호출하면 `InterruptedException`이 발생합니다. **`join()`** 메소드를 사용하는 경우, 해당 스레드가 다른 스레드의 종료를 기다리는 동안 인터럽트될 때 이 예외가 발생합니다.
- **처리 방법**: `InterruptedException`은 checked 예외로, 반드시 try-catch 블록을 사용하여 처리하거나, 메소드 선언에 예외를 명시해야 합니다.
- **일반적인 사용 예**: 두 스레드 간의 작업 순서를 조정하거나, 한 스레드가 다른 스레드의 작업 완료를 기다리는 경우에 **`join()`** 메소드와 함께 사용됩니다.

InterruptedException 예외가 발생하면 스레드는 대기상태에서 실행대기 상태로 전환되어 실행 상태를 기다린다.

### 실행흐름 예시

1. **메인 스레드 실행**: 메인 스레드가 실행되고, 특정 시점에서 **`스레드 1.join()`** 메소드를 호출합니다. 이 호출은 메인 스레드가 스레드 1의 종료를 기다리게 만듭니다.
2. **메인 스레드 일시 정지**: **`join()`** 메소드를 만나면, 메인 스레드는 일시적으로 실행을 멈추고 대기 상태로 전환됩니다. 내부적으로, 이는 **`wait()`** 메소드와 유사한 메커니즘을 사용하여 메인 스레드를 대기 상태로 만듭니다.
3. **스레드 1 실행**: 이 시점에서, 스레드 1은 실행 상태로 전환됩니다(컨텍스트 스위칭). 스레드 1은 할당된 작업을 수행합니다.
4. **스레드 1 종료와 메인 스레드 깨우기**: 스레드 1의 작업이 완료되면, 자동적으로 메인 스레드에게 '작업 완료' 신호를 보냅니다. 이는 내부적으로 **`notify()`** 메소드와 유사한 메커니즘으로 처리되며, 이 신호로 인해 메인 스레드의 대기 상태가 해제됩니다.
5. **메인 스레드 재개**: `notify()`와 유사한 신호를 받은 메인 스레드는 대기 상태에서 벗어나 다시 실행 상태로 전환됩니다. 메인 스레드는 **`join()`** 호출 이후의 코드를 계속해서 실행합니다.

이때 **`join()`** 메소드는 내부적으로 **`Object`** 클래스의 `wait()`와 **`notify()`** 메커니즘을 활용하여 스레드 간의 동기화를 수행한다. 이는 스레드가 다른 스레드의 종료를 기다리는 동안 CPU 자원을 낭비하지 않도록 한다. **`join()`** 메소드는 스레드 간의 동기화와 순서 제어에 매우 유용하지만, 데드락(Deadlock) 같은 상황을 방지하기 위해 신중하게 사용해야 한다. 데드락은 두 스레드 또는 그 이상이 서로의 작업 완료를 무한히 기다리는 상태를 말합니다.

### **인터럽트 발생 시키기**

1. **스레드 2에 의한 인터럽트**: 이 시점에서, 스레드 2가 실행되고, 어떤 이유로 메인 스레드를 인터럽트합니다. 이를 위해 스레드 2는 메인 스레드의 **`interrupt()`** 메소드를 호출합니다.

### **메인 스레드의 응답**

1. **메인 스레드의 인터럽트 처리**: 메인 스레드는 인터럽트 신호를 받습니다. **`join()`** 메소드가 인터럽트에 의해 중단되면, **`InterruptedException`** 예외가 발생합니다. 메인 스레드는 이 예외를 잡아서 처리합니다.

### **예외 처리와 실행 재개**

1. **예외 처리 및 실행 대기 상태로 전환**: 메인 스레드는 **`InterruptedException`**을 처리합니다. 일반적으로 이 예외 처리는 인터럽트 발생 사실을 로그로 기록하거나, 메인 스레드의 현재 상태에 따라 적절한 조치를 취하는 코드를 포함할 수 있습니다. 예외 처리가 완료되면, 메인 스레드는 대기 상태에서 벗어나 실행 대기 상태로 전환됩니다.
2. **메인 스레드의 작업 재개**: 예외 처리가 완료되고 나면, 메인 스레드는 다시 실행 가능한 상태가 되며, 스레드 스케줄러에 의해 실행될 준비가 됩니다. 스레드 스케줄러는 메인 스레드를 다시 실행 큐에 배치하여 작업을 재개할 수 있도록 합니다.

### 정리

- join() 을 실행하면 OS 스케줄러는 join() 을 호출한 스레드를 대기 상태로 전환하고 호출 대상 스레드에게 CPU 를 사용하도록 한다
- 호출 대상 스레드의 작업이 종료되면 join() 을 호출한 스레드는 실행 대기 상태로 전환 되고 CPU 가 실행을 재개할 때 까지 기다린다.
- join() 을 호출한 스레드가 실행 대기에서 실행 상태가 되면 그 스레드는 남은 지점부터 실행을 다시 시작한다
- 호출 대상 스레드가 여러 개일 경우 각 스레드의 작업이 종료될 때 까지 join() 을 호출한 스레드는 대기와 실행을 재개하는 흐름을 반복한다
- join() 을 호출한 스레드가 인터럽트 되면 해당 스레드는 대기에서 해제되고 실행상태로 전환되어 예외를 처리하게 된다  

## 3. **interrupt()** & **interrupted()** & **isInterrupted()**

Interrupt 의 사전적 의미는 ‘방해하다’ 라는 뜻으로 어떤 주체의 행동이나 실행흐름을 방해한다는 의미로 해석 할 수 있다. Java 에서 interrupt 는 특정한 스레드에게 인터럽트 신호를 알려 줌으로써 스레드의 실행을 중단 , 작업 취소, 강제 종료 등으로 사용할 수 있다. 스레드 인터럽트와 관련된 세 가지 중요한 메소드는 **`interrupt()`**, **`interrupted()`**, **`isInterrupted()`** 입니다. 이들은 스레드를 인터럽트하거나 인터럽트 상태를 확인하는 데 사용된다.

### **1. interrupt()**

- **용도**: 특정 스레드에 인터럽트(interrupt) 신호를 보냅니다. 이 메소드를 호출하면, 대상 스레드의 인터럽트 상태가 설정됩니다. 즉 interrupt() 는 스레드가 현재 실행 흐름을 멈추고 인터럽트 이벤트를 먼저 처리하도록 시그널을 보내는 장치라 할 수 있다
- **사용 방법**: 대상 스레드의 인스턴스에 대해 **`interrupt()`** 메소드를 호출합니다. 예를 들어, **`thread.interrupt();`**는 **`thread`**라는 스레드 인스턴스에 인터럽트를 발생시킵니다.
- **효과**: 대상 스레드가 **`sleep()`**, **`wait()`**, **`join()`** 등에 의해 대기 상태에 있을 때 **`InterruptedException`**이 발생하게 합니다. 대기 상태가 아닌 스레드에 대해서는 인터럽트 상태가 설정되고, 이후 해당 스레드의 코드에서 이 상태를 확인할 수 있습니다.
- **interrupted 속성**
    - 스레드는 인터럽트 상태(Interrupt State )로 알려진 **interrupted** 를 가지고 있으며 인터럽트 발생 여부를 확인할 수 있는 상태 값이다. 기본값은 fasle 이다
    - 인터럽트된 스레드가 처리해야 하는 특별한 규칙이나 정해진 기준은 없으나 일반적으로 인터럽트 상태를 사용해서 스레드를 중지하거나, 작업을 취소하거나, 스레드를 종료 하는 등의 기능을 구현할 수 있다
    - 한 스레드가 다른 스레드를 인터럽트 할 수 있고 자기 자신을 인터럽트 할 수도 있다
    - interrupt() 하는 횟수는 제한이 없으며 인터럽트 할 때 마다 스레드의 인터럽트 상태를 true 로 변경한다
  
스레드1 , 스레드2 두 스레드가 실행중에 있을때 1번스레드가 2번스레드에게 interrupt를 걸게되면(thread2.interrupt()) 그 즉시 스레드2번에게 interrupt signal을 전달하게되고 이 신호를 받은 스레드2번의 interrupted 속성은 true로 변경된다.(초기값은 false)  
  
인터럽트가 발생했다는 신호를 받으면 상태값이 변경되고 해당 상태값을 사용해서 우리는 취소, 종료 처리등을 할 수 있다.
  
### 인터럽트 상태 확인 하는 방법  

### **1. static boolean interrupted()**

- **용도**: 현재 스레드의 인터럽트 상태를 확인하고, **인터럽트 상태를 초기화**합니다. 즉 인터럽트를  해제하는 역할을 한다.
- **사용 방법**: `Thread.interrupted()`를 호출하여 현재 스레드의 인터럽트 상태를 확인합니다. 이 메소드는 static 메소드입니다.
- **반환 값과 효과**: 스레드가 인터럽트되었으면 `true`를 반환하고, 인터럽트 상태를 초기화합니다(`false`로 설정). 스레드가 인터럽트되지 않았으면 `false`를 반환합니다.

만약 인터럽트를 해제하는 경우 다른 곳에서 스레드에 대한 인터럽트 상태를 체크하는 곳이 있다면 별도의 처리가 필요할 수 있고 강제로 해제 했기 떄문에 다시 인터럽트를 걸어서 인터럽트 상태를 유지할 수 있다.

### **2. boolean isInterrupted()**

- **용도**: 특정 스레드의 인터럽트 상태를 확인하지만, **인터럽트 상태를 초기화하지 않습니다.**
- **사용 방법**: 대상 스레드 인스턴스에 대해 **`isInterrupted()`** 메소드를 호출합니다. 예를 들어, `thread.isInterrupted();`는 `thread`라는 스레드 인스턴스의 인터럽트 상태를 확인합니다.
- **반환 값과 효과**: 스레드가 인터럽트되었으면 `true`를 반환하고, 그렇지 않으면 `false`를 반환합니다. 인터럽트 상태는 변경되지 않습니다.

### **요약**

- **`interrupt()`**: 스레드에 인터럽트 신호를 보냅니다.
- **`interrupted()`**: 현재 스레드의 인터럽트 상태를 확인하고 초기화합니다.
- **`isInterrupted()`**: 특정 스레드의 인터럽트 상태를 확인하지만, 초기화하지 않습니다.

### interruptedException

- InterruptedException 은 interrupt() 메카니즘의 일부이며 **대기나 차단 등 블록킹 상태에 있거나 블록킹 상태를 만나는 시점**의 스레드에 **인터럽트 할 때 발생**하는 예외이다.
- InterruptedException 이 발생하면 인터럽트 **상태는 자동으로 초기화 된다**. 즉 Thread.interrupted() 한 것과 같은 상태로 된다( interrupted = false)
- 다른 곳에서 인터럽트 상태를 참조하고 있다면 예외 구문에서 대상 스레드에 다시 interrupt() 해야 할 수도 있다
- InterruptedException 이 발생하는 케이스는 다음과 같다
    - Thread.sleep(), Thread.join(), Object.wait()
    - Future.get(), BlockingQueue.take()


### 4. **name() &** **currentThread() &** **isAlive()**

### **1. name()**

멀티 스레드 환경에서 어떤 스레드가 실행중인지 알아야 할 경우 스레드에 사용자 이름을 지정하면 실행중인 스레드를 쉽게 찾을 수 있고 디버깅시 스레드가 무슨작업을 하고 있는지 정확하게 파악하는데 큰도움이 된다. 기본적으로 자바에서 스레드가 생성되면 스레드 이름이 자동으로 주어진다. 가장 먼저 생성되는 스레드의 이름을 main 그다음은 Thread-0,Trhead-1…. 이런 식으로 이름이 만들어지게 된다.

- **setName(String name)**: 스레드에 이름을 설정합니다. 이 이름은 디버깅 시 스레드를 식별하는 데 유용합니다.
- **getName()**: 현재 스레드의 이름을 반환합니다.
- **생성자 함수 인자로 전달** : Thread myThread = new Thread([TreadGroup],[Runnable],"myThread");

### **2. currentThread()**

- **용도**: 현재 실행 중인 스레드의 참조를 반환합니다.
- **사용 방법**: `Thread.currentThread()`를 호출합니다. 이 메소드는 현재 실행 중인 스레드의 **`Thread`** 객체를 반환합니다.
- **반환 값**: 현재 실행 중인 스레드의 **`Thread`** 객체입니다. 이를 통해 현재 스레드의 상태, 이름, 우선순위 등의 정보를 얻을 수 있습니다.

### **3. isAlive()**

- **용도**: 특정 스레드가 활성 상태인지(즉, 실행 중이거나 실행 준비가 되어 있는지) 확인합니다.
- **사용 방법**: 스레드 인스턴스에 대해 **`isAlive()`** 메소드를 호출합니다. 예를 들어, `thread.isAlive();`는 `thread`라는 스레드 인스턴스가 아직 활성 상태인지 확인합니다.
- **반환 값**: 스레드가 활성 상태면 **`true`**, 그렇지 않으면 `false`를 반환합니다.

## 스레드 우선순위

**단일 CPU에서 여러 스레드를 실행하는 것을 스케줄링**이라고 하며 스레드는 스케줄에 의해 선점되어 CPU를 할당 받는다. 자바는 자바 런타임에 고정 우선순위 선점형 스케줄링(**fixed-priority pre-emptive scheduling )** 으로 알려진 매우 단순하고 결정적인 스케줄링 알고리즘을 지원하고 이 알고림즘은 실행 대기 상태의 스레드 중에 상대적인 우선순위에 따라 스레드를 예약한다.

Java에서 스레드 우선순위는 스레드 스케줄링에서 각 스레드에 할당되는 처리 시간의 양을 결정하는 데 사용된다. 스레드 우선순위는 일반적으로 숫자로 표현되며, 높은 숫자가 높은 우선순위를 의미합니다.

### **스레드 우선순위의 범위**

- Java에서 스레드의 우선순위는 **`Thread.MIN_PRIORITY`** (1)부터 **`Thread.MAX_PRIORITY`** (10)까지의 값을 가질 수 있으며, 기본값은 **`Thread.NORM_PRIORITY`** (5)입니다.

### **우선순위 설정 및 조회**

- **설정**: 스레드의 우선순위는 **`setPriority(int newPriority)`** 메소드를 통해 설정할 수 있습니다. 예를 들어, `thread.setPriority(Thread.MAX_PRIORITY);`는 해당 스레드에 최대 우선순위를 설정합니다.
- **조회**: 스레드의 현재 우선순위는 **`getPriority()`** 메소드를 통해 조회할 수 있습니다. 예를 들어, `int priority = thread.getPriority();`는 해당 스레드의 우선순위를 반환합니다.

### **우선순위의 영향**

- 스레드 우선순위는 JVM과 운영 체제의 스레드 스케줄링 정책에 의해 영향을 받습니다. **따라서 높은 우선순위를 가진 스레드가 더 많은 실행 시간을 할당받을 가능성이 높지만, 이는 항상 보장되지는 않습니다.** 예를들어 스케줄러는 우선순위가 높은 스레드를 실행하다가 해당 스레드가 중지,양보 또는 실행 불가능이 되는 경우 우선 순위가 낮은 스레드를 실행한다.
- 특히, 다중 처리 시스템에서는 우선순위가 덜 중요할 수 있으며, 단일 처리 시스템에서는 우선순위가 스레드 간의 실행 순서에 더 큰 영향을 미칠 수 있습니다.
- 두 스레드의 우선순위가 같을 경우 라운드 로빈 순환 할당 스케줄링 방식에 의해 다음 스레드를 선택한다.

> **라운드 로빈(Round Robin) 순환 할당 스케줄링 방식**  
> 컴퓨팅에서 널리 사용되는 프로세스 혹은 스레드 스케줄링 알고리즘 중 하나입니다. 이 방식은 각 스레드에게 동일한 시간 할당량(타임 슬라이스 혹은 타임 퀀텀)을 순서대로 할당하여 실행을 허용합니다. 모든 스레드는 공평하게 CPU 시간을 할당받으며, 하나의 스레드가 자신에게 할당된 시간을 사용하면, 다음 스레드로 넘어갑니다.  
> 
>라운드 로빈 스케줄링은 각 스레드가 작업을 완료하기 위해 필요한 전체 시간을 미리 알 필요가 없으며, 모든 스레드에게 동등한 기회를 제공하기 때문에 공정한 스케줄링 방식으로 간주됩니다. 이 방식은 특히 시분할 시스템에서 효과적이며, 응답 시간을 개선하는 데 도움이 됩니다.
>   
> 자바에서 스레드의 우선순위를 설정할 수 있지만, 실제 스레드 스케줄링은 JVM이 실행되는 운영 체제의 스케줄링 정책에 크게 의존합니다. 따라서, 자바 스레드의 우선순위가 같을 경우 운영 체제의 스케줄러가 라운드 로빈 방식이나 다른 방식을 사용하여 스레드를 스케줄링할 수 있습니다. 그러나 모든 운영 체제가 정확히 라운드 로빈 방식을 사용하는 것은 아니며, 스레드 스케줄링은 운영 체제별로 다를 수 있습니다.


### **주의 사항**

- 우선순위에 의존하는 프로그램 설계는 일반적으로 권장되지 않습니다. 다양한 JVM과 운영 체제에서의 스레드 스케줄링 정책의 차이로 인해 예측하기 어려울 수 있기 때문이다.
- 우선순위를 사용하여 스레드 간의 경쟁 조건(race condition)을 해결하려고 시도하는 것은 좋지 않은 접근 방식입니다. 대신, 적절한 동기화 메커니즘을 사용하는 것이 바람직합니다.  

  
# 스레드 활용  

## 스레드 예외처리

Java에서 **`Thread.UncaughtExceptionHandler`** 인터페이스는 스레드에서 처리되지 않은 예외(uncaught exception)를 처리하기 위해 사용됩니다. 일반적으로 스레드 내에서 발생한 예외가 해당 스레드의 **`run()`** 메소드 내에서 적절히 처리되지 않으면, 이 인터페이스를 구현하는 핸들러를 통해 해당 예외를 잡아 처리할 수 있습니다. **기본적으로 스레드의 run() 은 예외를 던질 수 없기 때문에** 예외가 발생할 경우  run() 안에서만 예외를 처리해야한다. **이때 RuntimeException 타입의 예외가 발생할 지라도 스레드 밖에서 예외를 캐치할 수 없고 사라진다.**

### **UncaughtExceptionHandler 사용 방법**

캐치 되지 않는 예외에 의해 Thread가 갑자기 종료됬을때 호출되는 핸들러 인터페이스 이다. 이를 통해서 어떤 원인으로 인해 스레드가 종료되었는지 대상 스레드와 예외를 파악할 수 있다.

1. **인터페이스 구현**: **`Thread.UncaughtExceptionHandler`** 인터페이스를 구현하는 클래스를 정의합니다. 이 클래스는 **`uncaughtException(Thread t, Throwable e)`** 메소드를 구현해야 합니다. 이 메소드는 예외가 발생한 스레드와 해당 예외 객체를 인자로 받는다.
2. **핸들러 설정**: 스레드 또는 스레드 그룹에 이 핸들러를 설정합니다. 이를 위해 **`Thread`** 클래스의 **`setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)`** 메소드를 사용한다
- **static void setDefaultUncaughtExceptionHandler**
    - 모든 스레드에서 발생하는 uncaughtException 을 처리하는 정적 메서드
- **void setUncaughtExceptionHandler(UncaughtExceptionHandler ueh)**
    - 대상 스레드에서 발생하는 uncaughtException 을 처리하는 인스턴스 메서드
    - setDefaultUncaughtExceptionHandler 보다 우선순위가 높다

### **예제 코드**

```java
public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println("An exception has been captured in thread: " + t.getName());
        System.out.println("Exception: " + e.getClass().getName() + ": " + e.getMessage());
        e.printStackTrace(System.out);
    }
}

public class MyThread extends Thread {
    @Override
    public void run() {
        throw new RuntimeException("Intentional Exception");
    }

    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
        thread.start();
    }
}

```

이 예제에서 `MyUncaughtExceptionHandler`는 `Thread.UncaughtExceptionHandler`를 구현합니다. **`MyThread`** 클래스의 **`run()`** 메소드는 의도적으로 예외를 발생시키고, 이 예외는 `MyUncaughtExceptionHandler`에 의해 처리됩니다.
  
스레드를 생성해서 `UncaughtExceptionHandler`를 구현해서 `setUncaughtExceptionHandler`메소드를 통해서 핸들러를 설정하게 되면 스레드 내부에서는 `start()`메소드를 통해서 내부적으로 스레드의 `run()`메소드를 호출하는데 이때 `run()`메소드에서 예외가 발생하게 된다면(uncaughtException) 내부적으로 `dispatchUncaughtException` 메소드를 호출한다. 해당 메소드는 우리가 앞에서 전달한 `UncaughtExceptionHandler`를 가지고 와서 우리의 핸들러를 호출해준다.(getUncaughtExceptionHandler.uncaughtException(thread,exception) )
### **사용 시 주의사항**

- `UncaughtExceptionHandler`는 스레드가 예외로 인해 종료될 때 실행됩니다. 따라서 예외 처리 로직을 이 핸들러에 구현할 때는 스레드의 안전한 종료와 자원 해제에 주의해야 한다.
- 모든 스레드에 대해 동일한 **`UncaughtExceptionHandler`**를 사용할 수 있으며, 필요에 따라 각 스레드에 개별적으로 핸들러를 설정할 수도 있다.
- 기본적으로 스레드에서 발생하는 예외는 콘솔에 출력되지만, **`UncaughtExceptionHandler`**를 사용하면 예외 정보를 로깅하거나, 애플리케이션에 특정한 조치를 취하는 등 보다 세밀한 예외 처리가 가능하다.

## 스레드 중지

자바에서 무한 반복이나 지속적인 실행 중에 있는 스레드를 중지하거나 종료할 수 있는 API를 더이상 사용할 수 없다.(suspend(), stop()) 이때 스레드를 중지하는 데 사용되는 두 가지 일반적인 방법은 플래그 변수(flag variable) 사용과 **`interrupt()`** 메소드 호출이다. 이 두 방법은 스레드를 안전하게 중지시키기 위해 사용되며, 각각의 특징과 사용 사례가 다릅니다.

### **1. 플래그 변수 사용**

- **방법**: 스레드가 실행 중인 동안 계속 확인하는 boolean 플래그 변수를 사용합니다. 외부에서 이 변수를 변경함으로써 스레드에 중지 신호를 보낼 수 있습니다. 이때 이 플래그 변수는 동시성 문제로 가능한 atomic 변수나 volatile 키워드를 사용하도록 한다.
- **사용 사례**: 스레드가 특정 작업을 반복적으로 수행하고 있을 때, 플래그 변수의 상태를 확인하여 중지 여부를 결정합니다.
- **장점**: 구현이 간단하고, 스레드의 특정 지점에서만 중지를 확인할 수 있어 통제가 용이합니다.
- **단점**: 스레드가 바쁜 대기 상태(busy-waiting)에 있지 않고 블로킹 상태(blocking state)인 경우(예: **`sleep()`**, **`wait()`** 호출 시), 플래그 변수를 확인할 수 없어 중지가 지연될 수 있습니다.

```java
public class MyThread extends Thread {
    private volatile boolean running = true;

    public void run() {
        while (running) {
            // 스레드 작업 수행
        }
    }

    public void stopThread() {
        running = false;
    }
}

```

```java
import java.util.concurrent.atomic.AtomicBoolean;

public class MyThread extends Thread {
    private AtomicBoolean running = new AtomicBoolean(true);

    public void run() {
        while (running.get()) {
            // 스레드 작업 수행
            System.out.println("스레드 실행 중");
            try {
                Thread.sleep(1000); // 1초 대기
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // 인터럽트 상태 복원
            }
        }
        System.out.println("스레드 종료");
    }

    public void stopThread() {
        running.set(false);
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        myThread.start();
        Thread.sleep(3000); // 메인 스레드는 3초 동안 대기
        myThread.stopThread(); // 스레드 중지 요청
    }
}
```
  
### 일반변수 사용
```java
public class FlagThreadInterrupt {
    private static boolean running = true;
    
    public static void main(String[] args) {
        new Thread(() -> {
            int count = 0;
            while (running) {
                count ++;
            }
            System.out.println("Thread 1 is Done.. : "+ count);
        }).start();

        new Thread(() -> {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Thread 2 is Done.. : ");
            running = false;
        }).start();

    }
}

```
해당 코드에서 정상적으로 스레드1이 종료되지 않는 경우가 발생한다.이유는 캐시 메모리 값은 변경되었으나 실제 메모리 값은 변경되지 않아서 스레드 1이 계속 작업을 수행하게된다. 이떄  밑에 코드를 추가하니까 정상적으로 종료됨  
```java
 while (running) {
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                count ++;
            }
```
왜? 정상적으로 동작하는 것일까??   
각각의 CPU 마다 캐시 메모리 라는 것을 가지고 있다.(성능을 좀더 좋게하기 위해서 메모리보다 성능이 좋은 저장소) 이때 각 스레드는 메모리에서 값을 가져오는 것보다 캐시 메모리에서 가져오는 것이 연산 속도가 더 빠르기 때문이다.  

예를 들어 우리 예제에서 스레드2먼에서 running의 값을 false로 변경하면 바로 메모리에 해당 값을 변경하는 것이 아니라 변경된 값이 캐시 메모리에 저장이 된다.  이때 각각 스레드들이 가지고 있는 TCB가 다르기 때문에 CPU가 다른 스레드로 작업이 할당될때마다 이 컨텍스트 문맥정보가 달라진다.  

스레드2번이 가지고 있는 running의 값은 false 이지만 스레드1번이 가지고 있는 스레드1번에 값은 true이다. 즉 두 스레드가 동일한 장소에 있는 공유 데이터를 참조하는 것이 아니라 스레드 마다 가지고 있는 캐시값을 활용하기 때문에 이런 현상이 발생한다. 이 **volatile 이라는 키워드가 동일한 메모리에 접근해서 읽고 쓰고 하는 것을 보장해주는 키워드** 이다.  

그러면 왜 스레드1에 Thread.sleep(1) 코드를 추가하면 정상작동하는 이유는 아주 짧은 시간이여도 컨텍스트 스위칭이 발생한다.(스레드간 가지고 있는 문맥정보를 전환한다) 컨텍스트 스위칭이 발생하게 되면 해당 스레드에 있는 캐시값을 비워줘야 되기때문이다 왜냐하면 전환된 스레드의 문맥정보를 캐시로 사용해야 되기 때문이다. 스레드가 대기 상태에서 다시 running 상태로 변경되었을때는 기존에 가지고 있던 문맥정보가 없어졌기 때문에 새롭게 메모리에서부터 정보를 가지고 오게된다.

### **2. interrupt() 메소드 사용**

- **방법**: **`Thread`** 클래스의 **`interrupt()`** 메소드를 호출하여 스레드에 인터럽트를 발생시킵니다. 스레드 내에서 **`InterruptedException`**이 발생하거나, 스레드의 **`interrupted()`** 상태를 확인하여 중지 여부를 결정할 수 있습니다.
- **사용 사례**: 스레드가 블로킹 상태(예: **`sleep()`**, **`wait()`**, **`join()`** 호출 시)에 있을 때 유용합니다.
- **장점**: 블로킹 상태에 있는 스레드도 즉시 인터럽트될 수 있으며, **`InterruptedException`**을 통해 스레드를 안전하게 중지시킬 수 있습니다.
- **단점**: 인터럽트 메커니즘을 정확히 이해하고 사용해야 하며, 스레드가 블로킹 상태가 아닌 경우 별도로 인터럽트 상태를 확인하는 로직을 추가해야 합니다.

```java

public class MyThread extends Thread {
    public void run() {
        try {
            while (!Thread.interrupted()) {
                // 스레드 작업 수행
            }
        } catch (InterruptedException e) {
            // 스레드 중지 처리
        }
    }
}

```

- 스레드가 실행되면 Thread.interrupted() 가 false 이므로 반복문을 계속 실행한다
- 인터럽트가 발생하면 Thread.interrupted() 은 true 이고 반복문을 빠져 나오면서 스레드는 종료된다
- 인터럽트 상태는 해제 된다

```java
public class MyRunnable extends Runnable{
    public void run() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                // 스레드 작업 수행
            }
        } catch (InterruptedException e) {
            // 스레드 중지 처리
        }
    }
}
```

- 스레드가 실행되면 Thread.currentThread().isInterrupted() 가 false 이므로 반복문을 계속 실행한다
- 인터럽트가 발생하면 Thread.currentThread().isInterrupted() 은 true 이고 반복문을 빠져 나오면서 스레드는 종료된다
- 인터럽트 상태는 계속 유지 된다

### **3. Interrupted Exception**
대기중인 스레드에 interrupt() 하게 되면 InterruptedException 예외가 발생한다.

```java
    public static class MyRunnable implements Runnable {

    @SuppressWarnings("BusyWait")
    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(1000);
                System.out.println("Thread is Running");
            } catch (InterruptedException e) {
                System.out.println(e.getMessage());
                break;
            }
        }
        System.out.println("Thread is Done!");
    }
}

```
인터럽트가 발생하면(thread.interrupt() ) InterruptedException 예외가 발생하고 예외 구문에서 반복문을 빠져나오면서 스레드가 종료된다.(인터럽트 상태는 해제 된다.)
  
```java
    public static class MyRunnable implements Runnable {

    @SuppressWarnings("BusyWait")
    @Override
    public void run() {
        while (true) {
            try {
                if(Thread.interrupted()) throw new InterruptedException("interrupt occurred!");
                
                System.out.println("Thread is Running");
            } catch (InterruptedException e) {
                System.out.println(e.getMessage());
                Thread.currentThread().interrupt(); // 필요한 경우 인터럽트 상태를 원복
                break;
            }
        }
        System.out.println("Thread is Done!");
    }
}

```

## **사용자 스레드** vs **데몬 스레드**

Java에서 스레드는 크게 두 가지 유형으로 분류됩니다: 사용자 스레드(User Threads)와 데몬 스레드(Daemon Threads). 이 두 유형의 스레드는 용도와 JVM에서의 동작 방식이 다릅니다. 사용자 스레드는 사용자 스레드를 낳고 데몬 스레드는 데몬 스레드를 낳는다. 즉 자식 스레드는 부모 스레드의 상태를 상속 받는다. 자바가 실행되면 JVM은 사용자 스레드인 메인스레드와 나머지 데몬 스레드를 동시에 생성하고 시작한다.

### **메인 스레드 (Main Thread)**

- **정의**: 메인 스레드는 Java 애플리케이션의 진입점인 **`main()`** 메소드를 실행하는 스레드입니다.
- **특징**: 메인 스레드는 모든 Java 애플리케이션의 시작점이며, 기본적으로 사용자 스레드입니다.
- **용도**: 애플리케이션의 시작과 초기화, 다른 사용자 스레드의 생성 및 관리 등을 담당합니다.

메인 스레드는 어플리케이션을 실행하는최초의 스레드이자 실행을 완료하는 마지막 스레드의 역할을 한다. 메인 스레드에서 여러 하위 스레드를 추가로 시작할 수 있고 하위 스레드는 또 여러 하위 스레드를 시작할 수 있다 메인 스레드가 사용자 스레드이기 때문에 하위 스레드는 모두 사용자 스레드가 된다.

### **사용자 스레드 (User Threads)**

- **정의**: 사용자 스레드는 애플리케이션의 주 작업을 수행하는 스레드입니다. 이들은 애플리케이션의 핵심 기능을 담당합니다.
- **특징**: 사용자 스레드가 실행 중인 경우 JVM은 종료되지 않습니다. JVM은 모든 사용자 스레드가 작업을 완료할 때까지 계속 실행 상태를 유지합니다.
- **용도**: 일반적인 작업 수행, 계산 작업, I/O 작업 등 애플리케이션의 주된 기능을 수행하는 데 사용됩니다.

사용자 스레드는 메인 스레드에서 직접 생성한 스레드를 의미한다. 이 각각의 스레드는 독립적인 생명주기를 가지고 실행하게 된다.추가적으로 자바가 제공하는 스레드 풀인 ThreadPoolExecutor 은 사용자 스레드를 생성한다.

### **데몬 스레드 (Daemon Threads)**

- **정의**: 데몬 스레드는 백그라운드에서 보조적인 역할을 수행하는 스레드입니다. **사용자 스레드의 작업을 보조**하거나, **긴 시간 동안 실행되는 낮은 우선순위의 작업**을 수행합니다.
- **특징**: **모든 사용자 스레드가 종료되면, 데몬 스레드는 강제적으로 종료**됩니다. 즉, 데몬 스레드가 실행 중이더라도 JVM은 사용자 스레드가 모두 종료되면 종료됩니다.
- **용도**: 로그 기록, 시스템 모니터링, 가비지 컬렉션 등의 백그라운드 작업에 주로 사용됩니다.
- **설정 방법**: **`setDaemon(true)`** 메소드를 호출하여 스레드를 데몬 스레드로 설정할 수 있습니다. 이 설정은 **스레드가 시작되기 전에 수행**해야 합니다.
- **확인방법**: `isDaemon()` 메소드를 통해 이 스레드가 데몬인지 아닌지 확인합니다.

데몬 스레드는 JVM 에서 생성한 스레드이거나 직접 데몬 스레드로 생성한 경우를 말한다. 데몬 스레드의 생명주기는 사용자 스레드에 따라 다르며 낮은 우선순위를 가지고 background 에서 실행된다. 데몬 스레드는 사용자 스레드를 보조 및 지원하는 성격을 가진 스레드로서 보통 사용자 작업을 방해하지 않으면서 백그라운드에서 자동으로 작동되는 기능을 가진 스레드이다. 자바가 제공하는 스레드 풀인 ForkJoinPool 은 데몬 스레드를 생성한다.

## 스레드 그룹

Java에서 `ThreadGroup`은 여러 스레드를 하나의 객체로 묶어 관리할 수 있게 해주는 메커니즘입니다. 스레드 그룹을 사용하면 스레드들을 그룹 단위로 쉽게 제어하고 정보를 얻을 수 있으며, 스레드들을 계층적으로 관리할 수도 있다. 이때 한 스레드 그룹 안에 다른 스레드 그룹도 포함될 수 있고 그룹 내의 모든 스레드는 한번에 종료하거나 중단할 수 있다.

스레드는 **반드시 하나의 스레드 그룹에 포함되어야 하며** 명시적으로 스레드 그룹에 포함시키지 않으면 **기본적으로 자신을 생성한 스레드가 속해 있는 스레드 그룹에 포함**되어 진다.(일반적으로 main 스레드에서 생성하는 모든 세레드는 main 스레드의 그룹에서 속함)

### **ThreadGroup의 주요 기능**

1. **스레드 관리**: `ThreadGroup`은 그 안에 속한 모든 스레드를 추적하고 관리할 수 있게 해줍니다. 예를 들어, 그룹 내 모든 스레드에 대해 인터럽트를 호출하거나 스레드의 우선순위를 변경할 수 있습니다.
2. **보안 및 접근 제어**: `ThreadGroup`을 사용하면 보안상의 이유로 특정 그룹의 스레드에만 작업을 제한할 수 있습니다.
3. **에러 처리**: `ThreadGroup`은 그룹 내 스레드에서 발생하는 예외를 캡처하고 처리하는 데 사용될 수 있습니다.
4. **스레드 계층 구조**: 스레드 그룹은 다른 스레드 그룹을 포함할 수 있어, 스레드 계층 구조를 형성할 수 있습니다. 이는 스레드 관리를 계층적으로 수행할 수 있게 해줍니다.

### **JVM 스레드 그룹 생성 과정**

1. **시스템 스레드 그룹 생성**: JVM이 시작될 때, 가장 먼저 "system"이라는 최상위 스레드 그룹이 생성됩니다. 이 그룹은 JVM의 모든 스레드 그룹의 루트입니다.
2. **메인 스레드 그룹 생성**: "system" 스레드 그룹 내에 "main" 스레드 그룹이 생성됩니다. 사용자가 작성한 메인 애플리케이션의 스레드들, 즉 **`public static void main(String[] args)`** 메소드를 실행하는 스레드는 이 "main" 그룹에 속하게 됩니다.
3. **기타 시스템 스레드 그룹**: JVM은 내부적으로 여러 가지 서비스를 수행하기 위해 데몬 스레드 그룹(예: "Finalizer", "Reference Handler" 등)을 생성합니다. 이들 스레드 그룹은 주로 가비지 컬렉션, 객체 최종화, JVM 내부 참조 처리 등의 작업을 담당합니다.

### **스레드 그룹의 계층 구조**

- **계층적 구조**: 스레드 그룹은 계층적인 구조를 가지고 있습니다. 모든 스레드 그룹은 최상위 "system" 그룹의 하위 그룹이거나, 다른 스레드 그룹의 하위 그룹일 수 있습니다.
- **스레드 할당**: 각 스레드 그룹은 하나 이상의 스레드를 포함할 수 있으며, 스레드는 생성 시 할당된 스레드 그룹에 속하게 됩니다.
- **자식 스레드 그룹**: 스레드 그룹은 다른 스레드 그룹을 포함할 수도 있으며, 이를 통해 더 세분화된 스레드 관리가 가능합니다.

### **ThreadGroup Class**

### **생성자**

1. **ThreadGroup(String name)**
    - **설명**: 지정된 이름으로 새 스레드 그룹을 생성합니다. 이 그룹의 부모는 현재 스레드가 속한 스레드 그룹이 됩니다.
    - **매개변수**: **`name`** - 스레드 그룹의 이름입니다.
2. **ThreadGroup(ThreadGroup parent, String name)**
    - **설명**: 지정된 부모 스레드 그룹에 속하는 새 스레드 그룹을 생성합니다.
    - **매개변수**:
        - **`parent`** - 이 스레드 그룹의 부모 그룹입니다.
        - **`name`** - 스레드 그룹의 이름입니다.

### **주요 메소드**

1. **void activeCount()**
    - **설명**: 현재 스레드 그룹과 하위 그룹에서 활성화된 스레드의 추정 수를 반환합니다.
2. **void activeGroupCount()**
    - **설명**: 스레드 그룹에서 활성화된 하위 스레드 그룹의 추정 수를 반환합니다.
3. **void checkAccess()**
    - **설명**: 현재 스레드가 이 스레드 그룹에 대한 수정 권한을 가지고 있는지 확인합니다.
4. **void destroy()**
    - **설명**: 스레드 그룹을 파괴하고, 모든 하위 그룹을 파괴합니다. 스레드 그룹이 비어 있어야 합니다.
5. **int enumerate(Thread[] list)**
    - **설명**: 스레드 그룹과 그 하위 그룹에서 활성화된 스레드를 주어진 배열에 복사합니다.
6. **int enumerate(ThreadGroup[] list)**
    - **설명**: 이 스레드 그룹의 하위 그룹을 주어진 배열에 복사합니다.
7. **int getMaxPriority()**
    - **설명**: 이 스레드 그룹의 최대 우선순위를 반환합니다.
8. **String getName()**
    - **설명**: 이 스레드 그룹의 이름을 반환합니다.
9. **ThreadGroup getParent()**
    - **설명**: 이 스레드 그룹의 부모 그룹을 반환합니다.
10. **void interrupt()**
    - **설명**: 이 스레드 그룹에 속한 모든 스레드에 **`interrupt()`**를 호출합니다.
11. **boolean isDaemon()**
    - **설명**: 이 스레드 그룹이 데몬 그룹인지 여부를 반환합니다.
12. **void setDaemon(boolean daemon)**
    - **설명**: 스레드 그룹을 데몬 그룹으로 설정하거나 해제합니다.
13. **void setMaxPriority(int pri)**
    - **설명**: 이 스레드 그룹의 최대 우선순위를 설정합니다. 이때 그룹에 포함된 스레드들은 그룹에서 지정한 우선순위 보다 높은 우선순위를 설정할 수 없다.
14. **void uncaughtException(Thread t, Throwable e)**
    - **설명**: 이 스레드 그룹에서 처리되지 않은 예외가 발생했을 때 호출됩니다.
15. **void list**
    - **설명** : 현재 그룹에 포함된 스레드와 하위 그룹에 대한 정보를 출력합니다.

### **ThreadGroup 사용 예시**

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " is running");
    }

    public static void main(String[] args) {
        ThreadGroup threadGroup = new ThreadGroup("MyThreadGroup");

        Thread t1 = new Thread(threadGroup, new MyRunnable(), "Thread 1");
        Thread t2 = new Thread(threadGroup, new MyRunnable(), "Thread 2");

        t1.start();
        t2.start();

        System.out.println("Thread Group Name: " + threadGroup.getName());
    }
}

```

이 예제에서는 "MyThreadGroup"이라는 이름의 `ThreadGroup`을 생성하고, 이 그룹에 두 개의 스레드를 할당합니다. 이 그룹에 속한 스레드들은 **`run()`** 메소드에서 간단한 메시지를 출력합니다.


## ThreadLocal

`ThreadLocal`은 자바에서 스레드별로 변수를 분리하여 저장할 수 있게 해주는 유틸리티이다. 즉 자바에서는 **오직 자시만이 접근해서 읽고 쓸수 있는 로컬 변수 저장소**를 제공하는데 이를 `ThreadLocal` 이라고 한다. 각 스레드가 독립적인 변수의 인스턴스를 갖도록 하여, 스레드 간의 데이터 충돌을 방지하고 이는 멀티 스레드 환경에서 자주 사용되며, 특히 서버 사이드 애플리케이션 개발에서 유용하다.  
  
각 스레드는 고유한 ThreadLocal 객체를 속성으로 가지고 있으며 ThreadLocal은 스레드 간 격리되어 있다. 스레드는 ThradLocal 에 저장된 값을 특정한 위치나 시점에 상관없이 어디에서나 전역변수처럼 사용할 수 있다. 변수 값을 전달하지 않아도 된다. **모든 스레드가 공통적으로 처리해야하는 기능**이나 객체를 제어해야 하는 사황에서 스레드마다 다른 값을 적용해야 하는 경우 사용한다.(인증 주체 보관, 트랜잭션전파,로그 추적기등)
  
클라이언트에서 요청1,요청2,요청3을 서버로 요청했을대 WAS는 해당 요청마다 스레드를 생성하게된다. 이 생성된 스레드들은 ThreadLocal이라는 속성을 가지고 있고 이 속성은 개별적으로 ThreadLocalMap이라는 객체를 만들어서 스레드 마다 할당한다.

### **ThreadLocal의 사용 방법**

1. **ThreadLocal 인스턴스 생성**: `ThreadLocal`은 보통 **`private static`** 필드로 선언된다.

    ```java
    private static final ThreadLocal<MyObject> threadLocalInstance = new ThreadLocal<>();
    
    ```

2. **값 설정하기**: 각 스레드에서 **`ThreadLocal`** 인스턴스의 **`set()`** 메서드를 사용하여 값을 설정할 수 있습니다.

    ```java
    threadLocalInstance.set(new MyObject());
    
    ```

3. **값 가져오기**: 스레드 내에서 **`get()`** 메서드를 사용하여 저장된 값을 검색합니다.

    ```java
    MyObject obj = threadLocalInstance.get();
    
    ```

4. **값 제거하기**: 스레드가 더 이상 사용하지 않는 경우, **`remove()`** 메서드를 호출하여 리소스를 해제합니다.

    ```java
    threadLocalInstance.remove();
    
    ```
5. **withInitial(Supplier <? extends S> supplier)**: 스레드 로컬을 생성하면서 특정 값으로 초기화한다.   
    ```java
    ThreadLocal<String> threadLocal = ThreadLocal.withInitial(()->"defaultName");
    ```
    
### Thread & ThreadLocal

### **Thread**

   - `Thread`는 자바에서 독립적인 실행 흐름을 나타내는 기본 단위입니다.
   - 멀티스레딩 환경에서 여러 스레드가 동시에 실행되면서 각각의 작업을 병렬적으로 처리할 수 있습니다.
   - 각 스레드는 공유 자원에 접근할 수 있으며, 이로 인해 데이터의 일관성과 동기화 문제가 발생할 수 있습니다.
   - 스레드 생성시 threadLocals 의 기본값은 null이며 threadLocal에 값을 지정할 때 ThreadLocalMap 이 생성되고 threadLocals 과 연결된다.
   - 스레드가 전역적으로 값을 참조할 수 있는 원리는 스레드 ThreadLocal의 TreadLocalMap 에 접근해서 여기에 저장된 값을 바로 꺼내어 쓸수 있기 때문이다.

### **ThreadLocal**

- `ThreadLocal`은 각 스레드에게 고유한 데이터 저장소를 제공합니다.
- 스레드 내부에서만 접근 가능한 데이터를 저장하는데 사용되며, 다른 스레드와의 데이터 격리를 보장합니다.
- `ThreadLocal`을 사용하면 각 스레드는 동일한 변수에 대해 서로 다른 값을 유지할 수 있습니다. 이는 멀티스레딩 환경에서 데이터 충돌이나 동기화 문제를 방지하는 데 도움이 됩니다.

### **ThreadLocalMap**

  - `ThreadLocalMap`은 **`ThreadLocal`** 객체와 연관된 값을 저장하는 내부 클래스입니다. 이는 해시맵과 유사하지만, 키로 **`ThreadLocal`** 객체를 사용합니다.
  - `ThreadLocal`의 각 인스턴스가 스레드별로 다른 값을 가질 수 있도록, 해당 스레드에 대한 고유한 값들을 저장합니다.
  - ThreadLocalMap 은 항상 새롭게 생성되어 스레드 스택에 저장되기때문에 근본적으로 스레드간 데이터 공유가 될 수 없고 따라서 동시성 문제가 발생하지 않는다.

   ### **Thread의 threadLocals 필드**

  1. **정의**: **`Thread`** 클래스 내에는 `threadLocals`라는 필드가 있습니다. 이 필드는 해당 스레드에 속한 **`ThreadLocal`** 변수들의 값을 저장하는 `ThreadLocalMap`의 인스턴스를 참조합니다.
  2. **작동 방식**:
      - `ThreadLocal`의 **`set`** 또는 **`get`** 메서드가 호출될 때, 현재 스레드의 **`threadLocals`** 필드에 접근합니다.
      - 해당 `ThreadLocalMap`에 **`ThreadLocal`** 객체를 키로 사용하여 값을 저장하거나 조회합니다.
      - 각 스레드는 자신만의 **`threadLocals`** 필드를 가지므로, 다른 스레드의 **`ThreadLocal`** 값에 영향을 받지 않습니다.

### **상호작용 흐름**

  1. **값 설정**: 스레드에서 `ThreadLocal`의 **`set`** 메서드를 호출하면, 현재 스레드의 **`threadLocals`** 필드에 접근하여 `ThreadLocalMap`에 값을 저장합니다.(스레드 생성 시 threadLocals 기본값은 null)
  2. **값 조회**: **`get`** 메서드를 호출할 때, 같은 방식으로 현재 스레드의 **`threadLocals`** 필드에 저장된 `ThreadLocalMap`에서 해당 **`ThreadLocal`** 객체에 연관된 값을 조회합니다.
  3. **값 제거**: **`remove`** 메서드를 호출하면, `ThreadLocalMap`에서 해당 **`ThreadLocal`** 객체와 연관된 값을 제거합니다.


### **ThreadLocal의 주의점**

- **메모리 누수**: `ThreadLocal`을 사용할 때는 메모리 누수에 주의해야 합니다. 각 스레드가 끝나더라도 `ThreadLocal`에 저장된 객체가 GC(가비지 컬렉션)에 의해 회수되지 않을 수 있기 때문에, 필요 없어진 **`ThreadLocal`** 변수는 **`remove()`** 메서드를 호출하여 명시적으로 제거해야 합니다.
- **스레드 풀 사용 시 주의**: 스레드 풀을 사용하는 환경에서 `ThreadLocal`을 사용할 때는 각 작업이 끝날 때마다 **`ThreadLocal`** 값을 제거해야 합니다. 그렇지 않으면 다음에 그 스레드가 재사용될 때 이전 작업의 데이터가 남아있을 수 있습니다.
  
### ThreadLocal 작동원리
- ThreadLocal은 Thread와 ThreadLocalMap을 연결하여 스레드 전용 저장소를 구현하고 있는데 이것이 가능한 이유는 바로 Thread.currentThread()를 참조할 수 있기때문이다.
- Thread.currentThread()는 현재 실행중인 스레드의 객체를 참조하는 것으로 **CPU 는 오직 하나의 스레드만 할당받아 처리하기 때문에** ThreadLocal 에서 Thread.currentThread()를 참조하면 **지금 실행중인 스레드의 로컬 변수를 저장하거나 참조할 수 있게된다.**
- ThreadLocal 에서 현재 스레드를 참조할 수 있는 방법 없다면 값을 저장하거나 요청하는 스레드를 식별할 수 없기 때문에 **Thread.currentThread() 는 ThreadLocal의 중요한 데이터 식별 기준**이 된다.

   ### **사용 예제**

  ```java
  public class MyRunnable implements Runnable {
      private static final ThreadLocal<Integer> threadId = new ThreadLocal<Integer>() {
          @Override
          protected Integer initialValue() {
              return nextId.getAndIncrement();
          }
      };
    
      private static final AtomicInteger nextId = new AtomicInteger(0);
    
      public void run() {
          System.out.println("스레드 ID: " + threadId.get());
      }
  }
    
  ```

   이 예제에서 **`MyRunnable`** 클래스는 스레드마다 고유한 ID를 생성하고 출력합니다. `ThreadLocal`의 **`initialValue()`** 메서드를 오버라이드하여 초기 값을 설정할 수 있다.

### ThreadLocal 작동원리

   `ThreadLocal`의 작동 원리를 이해하기 위해서는 먼저, 자바 멀티스레딩 환경에서 스레드가 어떻게 작동하는지, 그리고 `ThreadLocal`이 이 환경에서 어떻게 스레드별로 데이터를 격리하는지를 살펴봐야 한다.

### **기본 개념**

  1. **스레드**: 자바에서 스레드는 프로세스 내에서 실행되는 독립적인 실행 흐름입니다. 각 스레드는 자신만의 스택을 갖지만, 힙과 메소드 영역 같은 메모리 영역은 다른 스레드와 공유합니다.
  2. **스레드별 데이터 격리**: 멀티스레딩 환경에서 데이터의 일관성과 안전성을 유지하기 위해, 각 스레드가 서로 독립적인 데이터를 유지하거나 접근할 필요가 있습니다. 이를 위해 **`ThreadLocal`**을 사용합니다.

### 예제 동작 과정
  1. **ThreadLocal 인스턴스**: **`ThreadLocal`** 객체는 스레드별로 고유한 값을 유지합니다. 각 스레드는 이 **`ThreadLocal`** 객체를 통해 자신만의 값을 저장하고 조회할 수 있습니다.
  2. **ThreadLocalMap**: 내부적으로, **`ThreadLocal`**은 **`ThreadLocalMap`**이라는 특수한 맵을 사용합니다. 이 맵은 키로 **`ThreadLocal`** 객체를 사용하고, 값으로 스레드별 데이터를 저장합니다. 중요한 점은 이 맵이 각 스레드에 대해 독립적으로 존재한다는 것입니다.
  3. **Thread 객체와의 관계**: 자바의 **`Thread`** 클래스에는 **`ThreadLocal.ThreadLocalMap`** 타입의 **`threadLocals`**라는 필드가 있습니다. **`ThreadLocal`**이 **`get()`** 또는 **`set()`** 메서드를 호출할 때, 현재 스레드의 **`threadLocals`** 맵에 접근하여 해당 스레드의 **`ThreadLocal`** 변수에 값을 저장하거나 조회합니다.
  4. **값의 저장과 조회**:
      - **`set()`** 메서드를 호출하면, 현재 스레드의 **`ThreadLocalMap`**에 값이 저장됩니다.
      - **`get()`** 메서드를 호출하면, 현재 스레드의 **`ThreadLocalMap`**에서 해당 **`ThreadLocal`** 변수의 값을 조회합니다.
      - **`remove()`** 메서드를 사용하여 특정 **`ThreadLocal`** 인스턴스에 저장된 값을 제거할 수 있습니다.
  5. **스레드별 격리**: 이 메커니즘 덕분에, 각 스레드는 **`ThreadLocal`** 변수에 대해 독립적인 값을 유지할 수 있으며, 다른 스레드의 **`ThreadLocal`** 변수 값에 영향을 받지 않습니다.

  ```java
  public class MyRunnable implements Runnable {
      private ThreadLocal<Integer> threadLocal = new ThreadLocal<>();
    
      @Override
      public void run() {
          threadLocal.set((int) (Math.random() * 100D));
          try {
              Thread.sleep(2000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println(threadLocal.get());
      }
  }
  ```

   ### **InheritableThreadLocal**

  - InheritableThreadLocal은 ThreadLocal의 확장 버전으로서 부모 스레드로부터 자식 스레드로 값을 전달하고 싶을 경우 InheritableThreadLocal을 사용할 수 있다
  - **값의 상속:**
      - 부모 스레드가 InheritableThreadLocal 변수에 값을 설정하면, 해당 부모 스레드로부터 생성된 자식 스레드들은 부모의 값을 상속받게 된다
  - **독립성**
      - **자식 스레드가 상속받은 값을 변경하더라도 부모 스레드의 값에는 영향을 주지 않는다.**

  ```java
  public class MyRunnable implements Runnable {
      private static final InheritableThreadLocal<Integer> inheritableThreadLocal = new InheritableThreadLocal<>();
    
      @Override
      public void run() {
          System.out.println("상속받은 값: " + inheritableThreadLocal.get());
      }
    
      public static void main(String[] args) {
          inheritableThreadLocal.set(100);
    
          Thread childThread = new Thread(new MyRunnable());
          childThread.start();
      }
  }
  ```
   
  
## 동기화 개념
  
### 싱글 스레드 와 멀티 스레드
프로세스는 오직 한개의 스레드로만 구성하는 싱글 스레드 프로세스와 하나 이상의 스레드로 구성하는 멀티 스레드 프로세스로 구분할 수 있다. 작업 처리에 있어서 단일 스레드와 멀티 스레드의 선택 기준은 어떤 방식이 자원을 효율적으로 사용하고 성능처리에 유리한가 하는 점이다.

### 단일 스레드
순차 실행  

| 장점 | 단점 |
| --- | --- |
| 문맥교환이 없다 | CPU 멀티코어 활용 못함 |
| 동기화 이슈가 없다 | 순차적 실행으로 응답성 및 전체 처리량이 낮다 |
| 자원 비용이 적다 | I/O 처리 시 CPU 가 낭비된다 |
| 프로그래밍 난이도가 낮다 | 스레드에 오류가 발생하면 프로그램이 종료된다 |

### 멀티 스레드
동시적, 병렬적 실행  

| 장점 | 단점 |
| --- | --- |
| 동시성으로 사용자의 응답성 향상 | 빈번한 문맥교환으로 성능이 저하 된다 |
| CPU 멀티코어의 병렬성으로 성능 향상 | 스레드 간 동기화 이슈가 발생한다 |
| CPU 낭비 없는 자원의 효율적인 사용 | 스레드 생성 비용이 작지 않다 |
| 한 스레드 오류는 다른 스레드에 영향이 없다 | 프로그래밍 난이도가 높다 |

현대 CPU는 대부분 멀티코어를 지원하기 때문에 병렬적 성능 및 동시적 자원 사용 관점에서는 싱글 스레드보다 멀티 스레드 기반 프로그래밍이 유리한 점이 많다. 간혹 **싱글 스레드에서 비동기 프로그래밍**은 많은 수의 멀티 스레드 기반 프로그래밍 보다 더 좋은 성능과 응답성을 보여줄 수 있다.

## 멀티 스레딩 과 동시성

CPU 의 동시적 작업 처리는 CPU 코어 개수보다 스레드의 개수가 많을 때 즉 , 멀티스레딩 환경에서 자원을 효율적으로 배분하고 사용하기 위해 설계된 방식이다. 같은 프로그램 안에서 실행되는 여러 스레드가 읽기 및 쓰기 **작업을 같은 메모리 영역에서 동시에 실행할 경우** `동시성 문제`가 대두된다.  
  
동시성 문제라 함은 하나의 스레드가 어떤 메모리 영역의 데이터를 쓰고 있는데 또 다른 스레드가 같은 메모리 영역의 데이터를 읽거나 쓸 경우 발생할 수 있는 문제이다.**동시성 문제는 싱글스레드에서는 절대 발생하지 않으며 멀티 스레드를 운용하는 어플리케이션에서 나타나는 현상**이다.

> **멀티 스레딩 (Multithreading)**
>
> 1. **정의**: 멀티 스레딩은 프로세스 내에서 여러 스레드가 동시에 실행되는 것을 말합니다. 스레드는 프로세스의 가장 작은 실행 단위로, 프로세스의 자원을 공유하면서 독립적인 작업을 수행할 수 있습니다.
> 2. **목적**: 멀티 스레딩은 CPU의 사용률을 극대화하고, 응답 시간을 단축시키며, 자원의 효율적인 사용을 가능하게 합니다. 특히, I/O 바운드 작업이 많은 애플리케이션에서 성능 향상을 가져올 수 있습니다.

이 멀티 스레딩 환경에서 `공유 작원을 선점`하기 위해 발생하는 스레드간의 동시성 문제는 자바 프로그램 개발에 있어서 반드시 이해해야 할 중요한주제이고 복잡하며 난해하다.

### **멀티 스레딩과 동시성 프로그래밍의 주요 포인트**

- **동기화**: 공유 자원에 대한 접근을 제어하여 데이터의 일관성을 유지합니다.
- **데드락 방지**: 여러 자원을 요청하는 스레드 간의 무한 대기 상태를 방지합니다.
- **스레드 관리**: 스레드 생명주기를 관리하고, 자원을 효율적으로 할당합니다.
- **성능 최적화**: 스레드 풀, 비동기 I/O와 같은 기술을 활용하여 시스템 자원을 최적화합니다.
- **오류 처리**: 멀티 스레딩 환경에서 발생할 수 있는 예외와 오류를 효과적으로 처리합니다.

이 밖에 확인해야 되고 알아야 할 주제가 방대하다.

## 동기화 와 CPU 관계

## 동기화(Synchronization) 란

여러 스레드가 동시에 같은 데이터나 자원에 접근할 때, 데이터의 일관성과 정확성을 유지하기 위해 사용된다. 멀티스레딩 환경에서 여러 스레드가 동시에 같은 메모리(변수, 객체 등)에 접근하게 되면, 예상치 못한 결과나 데이터 불일치가 발생할 수 있다. 이러한 문제를 **동시성 문제**라고 한다. `동기화`는 이러한 문제를 방지하기 위해 필하다.

## CPU 연산처리 이해

모든 기계어 명령(machine instruction) 은 **원자성(atimicity)** 을 갖는데 이는 **하나의 기계어 명령어가 실행을 시작할 경우 그 명령의 수행 종료시 까지는 인터럽트(interrupt)를 받지 않는다.** 분리 불가능(indivisible) 이라고도 한다.  
  
**CPU 가 두 개 이상의 명령어를 처리할 경우에은 원자성이 보장되지 않는데** 이는 각 명령을 수행하는 중에 OS 가 다른 스케줄링으로 CPU 에게 다른 명령을 수행하게 함으로써 현재 수행중인 명령을 인터럽트 즉 중단하게 된다는 의미이다. **두 개 이상의 명령어를 원자성으로 묶기 위해서는 스레드 간 동기화 메카니즘이 필요**하다. 즉 한 스레드가 모든 명령을 다 수행될 때까지 도중에 중단되지 않도록 해야 한다.

> **원자성(Atomicity)이란**
컴퓨터 프로그래밍과 CPU 연산에서 사용되는 중요한 개념으로, **하나의 작업이나 명령이 중간 단계 없이 완전히 수행되거나** **전혀 수행되지 않는 성질을 의미**합니다. 원자적인 작업은 분할할 수 없으며, 실행 중에는 어떠한 다른 프로세스나 스레드에 의해 방해받지 않습니다.
>

### **원자성의 예**

- **원자적 연산**: 예를 들어, 변수에 대한 증가 연산(**`x++`**)은 원자적이지 않습니다.  이 연산은 실제로 '값 읽기', '값 증가', '값 쓰기'의 세 단계로 구성됩니다. 멀티스레딩 환경에서 두 스레드가 동시에 **`x++`** 연산을 수행하면, 동시성 문제로 인해 예상치 못한 결과가 발생할 수 있습니다.
- **원자성 보장 메커니즘**: 이를 해결하기 위해, 자바에서는 **`synchronized`** 블록이나 메서드를 사용하여 연산 전체를 원자적으로 만들 수 있습니다. 또한, **`java.util.concurrent.atomic`** 패키지의 클래스들은 원자적 연산을 지원합니다.
  
여기서 하나의 기계 명령어에 한해서 원자성을 보장해준다고 했을때 하나의 기계 명령어란 **값 읽기**, **값 증가**, **값 쓰기**   이 3개중 1개의 명령어에 한해서 원자성을 보장해서 동시성 문제가 발생하지 않는다는 말이다.  
  
즉, 특정 변수에 대한 증가 중에서 오직 값 읽기, 오직 값 증가, 오직 값 쓰기 각각의 명령어만 원자성을 보장해주고 이 모든것을 합친 변수에 대한 증가에 대해서는 원자성을 보장하지 않는다.(2개 이상의 기계어 명령어는 원자성을 보장하지 않음)  
따라서 동시성문제가 발생하고 이를 해결하기 위해서 동기화 작업이 필요하다.
### **원자성 구현 방법**

1. **Synchronized 키워드**: **`synchronized`** 블록이나 메서드는 한 번에 하나의 스레드만 해당 코드 블록을 실행할 수 있도록 합니다. 이는 여러 스레드에 의한 동시 접근을 방지하여 원자성을 보장합니다.
2. **Lock 인터페이스**: **`java.util.concurrent.locks.Lock`** 인터페이스를 사용하여 명시적인 락을 제공하고, 락을 획득하고 해제하는 방식으로 원자성을 보장할 수 있습니다.
3. **Atomic 클래스**: **`java.util.concurrent.atomic`** 패키지는 원자적 연산을 지원하는 클래스들을 제공합니다. 예를 들어, `AtomicInteger`는 원자적으로 정수 값을 증가시키거나 감소시킬 수 있는 메서드를 제공합니다.

즉, 결론적으로 CPU 에서 원자성을 보장하지 않는 모든 연산 처리는 스레드 간 동시적 접근에 의해 데이터 불일치가 발생할 수 있다.  

### **동기화의 방법**

1. **Synchronized 메서드**:
    - 메서드 전체를 동기화합니다.
    - 해당 메서드는 한 시점에 하나의 스레드만 실행할 수 있습니다.
    - 예: **`public synchronized void method() { /* ... */ }`**
2. **Synchronized 블록**:
    - 코드의 특정 부분만을 동기화합니다.
    - 동기화할 객체를 명시할 수 있습니다.
    - 예:

        ```java
        synchronized(this) {
            // 동기화 블록
        }
        
        ```


### **동기화의 특징**

- **락(Lock)**: 동기화를 사용하면, 해당 부분의 코드(블록 또는 메서드)에 락이 걸립니다. 이 락은 동기화된 블록이나 메서드를 실행하는 스레드에 의해서만 해제될 수 있습니다.
- **스레드 안전(Thread Safety)**: 동기화는 스레드 안전을 보장합니다. 즉, 여러 스레드가 동시에 같은 객체의 동기화된 메서드나 블록에 접근하더라도 데이터의 일관성과 정확성이 유지됩니다.
- **성능 저하**: 동기화는 필요한 경우에만 사용해야 합니다. 불필요한 동기화는 성능 저하를 초래할 수 있습니다.

### **동기화의 예시**

Java에서 동기화를 사용하는 간단한 예시는 다음과 같습니다.

```java
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

```

이 예제에서 **`increment`** 메서드와 **`getCount`** 메서드는 **`synchronized`** 키워드를 사용하여 동기화되어 있습니다. 이는 한 번에 하나의 스레드만이 이 메서드들을 실행할 수 있음을 의미하며, **`count`** 변수에 대한 동시 접근을 방지합니다.



### 스레드 불일치 예시
```java
class Counter {
    private int count = 0;

    // 원자적이지 않은 증가 메서드
    public void increment() {
        count++;  // '읽기', '증가', '쓰기'의 세 단계로 구성됨
    }

    public int getCount() {
        return count;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        final Counter counter = new Counter();

        // 스레드 1
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        // 스레드 2
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Expected count: 2000");
        System.out.println("Actual count: " + counter.getCount());
    }
}
```

## Critical Section(임계영역, 공유 변수 영역)

임계 영역(Critical Section)은 멀티스레딩 프로그램에서 **두 개 이상의 스레드가 동시에 접근하면 안 되는 코드 영역**을 말한다. 이 영역은 공유 자원(예: 변수, 파일)을 사용하는 코드를 포함하고 있으며, 여러 스레드에 의해 동시에 접근되면 데이터 불일치나 예상치 못한 결과를 초래할 수 있다.

이 임계 영역은 entry section, critical section, exit section, remainder section 으로 구성 된다.

- entry section(입장영역) : critical section 에 진입하기 위해 진입허가를 요청하는 영역입니다.
- **critical section(임계영역)** : 하나의 스레드만 접근할 수 있는 영역이다
- exit section(퇴장영역) : critical section 에서 빠져나올 때 신호를 알리는 영역이다
- remainder section (나머지영역) : entry section, critical section, exit section 을 제외한 나머지 영역이다


### Critical Section Problem
한 스레드가 임계 영역을 실행하고 일을 때 다른 스레드가 같은 임계영역을 상용함으로서 발생한다.  
이 문제의 해결책을 위해서 3가지 충족조건이 있다.
* **Mutual Exclusion (상호 배제)**
    * 어떤 스레드가 임계 영역을 실행중이면 다른 스레드는 동일한 임계영역을 실행할 수 없다.
* **Progress(진행)**
    * 임계 구역에서 실행 중인 스레드가 없고 임계 구역에 진입하련느 스레드가 있을때 어떤 스레드가 들어갈 것인지 적절히 선택해 줘야 하며 이러한 결정은 무한정 미뤄져선 안된다.
* **Bounded Waiting(한정 대기)**
    * 다른 스레드가 임계 영역에 들어가도록 요청한 후 해당 요청이 수락되기 전에 기존 스레드가 임계영역에서 실행할 수 있는 횟수에 제한이 있어야한다.
    * Starvation(기아상태) 이 발생하지 않도록 한다.

### 동기화 도구
뮤텍스, 세마포어, 모니터, CAS(Compare and Swap) 와 같은 동기화 도구를 통해 임계영역에서 문제가 발생하지 않도록 할 수 있으며 자바에서는 synchronized 키워드를 포함한 여러 동기화 도구들을 제공하고 있다.

### **자바에서의 임계 영역 처리 방법**

1. **Synchronized 메서드**
    - 메서드 전체를 임계 영역으로 지정합니다.
    - **`synchronized`** 키워드를 메서드 선언에 추가하여 사용합니다.
    - 이 메서드는 한 번에 하나의 스레드만이 접근할 수 있습니다.
    - 예:

        ```java
        
        public synchronized void increment() {
            // 임계 영역
        }
        
        ```

2. **Synchronized 블록**
    - 특정 객체에 대한 동기화된 블록을 생성합니다.
    - 임계 영역 내에서 필요한 최소한의 코드만을 포함시킵니다.
    - 예:

        ```java
        
        public void increment() {
            synchronized(this) {
                // 임계 영역
            }
        }
        
        ```

3. **Lock 인터페이스**
    - **`java.util.concurrent.locks`** 패키지의 **`Lock`** 인터페이스를 사용합니다.
    - 명시적으로 락을 획득하고 해제합니다.
    - **`ReentrantLock`** 클래스가 일반적으로 사용됩니다.
    - 예:

        ```java
        
        Lock lock = new ReentrantLock();
        
        public void increment() {
            lock.lock();
            try {
                // 임계 영역
            } finally {
                lock.unlock();
            }
        }
        
        ```

4. **Atomic 변수**
    - **`java.util.concurrent.atomic`** 패키지에 있는 클래스들을 사용합니다.
    - 원자적 연산을 통해 락 없이도 스레드 안전을 보장할 수 있습니다.
    - 예: **`AtomicInteger`**, **`AtomicLong`** 등

   ### 예시

    ```java
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    class CriticalSectionExample {
        private final Lock lock = new ReentrantLock();
        private int sharedResource = 0;
    
        public void criticalSection() {
            // 진입 구역 (Entry Section)
            lock.lock(); // 임계 영역 진입 전 락을 획득
    
            try {
                // 임계 구역 (Critical Section)
                sharedResource++; // 공유 자원에 대한 연산 수행
    
                // 퇴장 구역 (Exit Section)
                // 이 경우 특별한 퇴장 작업은 없음
    
            } finally {
                // 락 해제
                lock.unlock();
            }
    
            // 나머지 구역 (Remainder Section)
            // 임계 영역과 무관한 나머지 작업 수행
            nonCriticalSection();
        }
    
        public void nonCriticalSection() {
            // 임계 영역 외의 작업 수행
        }
    }
    ```

    - **진입 구역**: **`lock.lock()`** 호출로 시작합니다. 이 부분에서 현재 스레드는 임계 구역에 진입하기 위해 락을 획득하려고 시도합니다.
    - **임계 구역**: `sharedResource++`는 실제 공유 자원을 수정하는 임계 구역입니다. 이 부분은 한 번에 하나의 스레드만 접근할 수 있어야 합니다.
    - **퇴장 구역**: **`finally`** 블록 내부에서 `lock.unlock()`을 호출하여 임계 구역을 빠져나옵니다. 이는 다른 스레드가 이제 임계 구역에 진입할 수 있음을 의미합니다.
    - **나머지 구역**: **`nonCriticalSection()`** 메서드는 임계 구역과 무관한 다른 작업을 수행하는 부분으로, 락과 관련이 없습니다.

### Race Condition(경쟁상태, 경쟁조건, 경합 상태)
여러 스레드가 동시에 **공유 자원에 접근하고 조작할때 스레드간 접근하는 순서나 시점에 따라 실행 결과가 달라질** 수 있는데 이것을 경쟁상태 라고 한다. 경쟁 상태는 임계영역에서 발생하는 문제들이 해결 되지 않는 상태에서 여러 스레드가 동시에 임계 영역에 접근해서 공유 데이터를 조작함으로써 발생하는 상태라 할 수 있다.


## 안전한 스레드 구성

여러 스레드에서 클래스나 객체에 동시에 접근해서 계속 실행하더라도 **지속적인 정확성이 보장**되는 코드를 **스레드 세이프(thread-safe)** 즉 스레드에 안전하다고 한다. 기본적으로 클래스 명세에 스레드 안정성을 헤치는 코드나 상태를 가지고 있지 않으면 스레드에 안전하다라고 정의할 수 있다. 스레드에 안전한 코드에는 경쟁상태가 없으며 경쟁 상태는 다수의 스레드가 공유 자원에 쓰기 작업을 시도할 때 발생하기 때문에 스레드가 실행될 때 어떤 자원을 공유하게 되는지 아는 것이 중요하다.

### **스레드 세이프의 중요성**

- **데이터 일관성**: 멀티스레딩 환경에서 공유 자원에 대한 동시 접근은 데이터의 불일치를 초래할 수 있습니다. 스레드 세이프한 구현은 이러한 문제를 방지한다.
- **오류 방지**: 잘못된 동기화는 데드락, 레이스 컨디션 등의 오류를 발생시킬 수 있습니다. 스레드 세이프한 코드는 이러한 오류를 최소화한다.

### 스레드에 안전한 구조

- **임계영역을 동기화 한다**
    - 동시에 여러개의 스레드가 임계영역을 접근하지 못하도록 락(Lock) 메카니즘을 사용한다
- **동기화 도구를 사용한다**
    - 세마포어, CAS, Atomic 변수, 동시성 자료구조 등의 동기화 도구들을 사용해서 스레드 안전성을 구현한다
      - 만약에 여러 스레드가 Reader라는 개체를 통해서 DB에서 특정 데이터를 조회하려고 한다. 이때 이 조회데는 데이터는 여러스레드가 동시에 중복해서 읽어오면 안되는 상황일때 `synchronized` 키워드를 통해 한번에 하나의 스레드만 접근해서 데이터를 읽어 올 수 있게 처리할 수 있다.
- **스레드의** **스택에 한정해서 상태를 관리한다**
    - 스레드마다 할당된 스택 메모리 내에서 상태를 관리함으로서 다른 스레드와 상태를 공유할 수 없도록 한다’
    - **지역변수 활용:** 스레드마다 독립적으로 스택에 저장되기 떄문에 스레드간에 공유될 수 없다.
    - **지역객체 참조 :** 변수와 다르게 객체는 스택에 저장되지 않고 힙 영역에 저장된다. 하지만 **지역적으로 생성된 객체가 해당 메소드에서 벗어나지 않고 사용 된다면 스레드는 자신만의 객체를 참조할 수 있게 되어 스레드에 안전하다.**
    - **멤버 변수 참조:** 멤버 변수 참조 역시 스레드 마다 객체를 생성하는 원리는 동일하다. 즉 스레드의 스택별로 객체가 생성되어 참조되도록 구현하면 된다.
- **ThreadLocal** **을 사용한다**
    - 스레드마다 가지고 있는 전용 저장소인 ThreadLocal 을 사용해서 상태를 관리함으로서 다른 스레드와 상태를 공유할 수 없도록 한다
- **불변 객체를 사용한다**
    - 객체의 상태를 변경할 수 없는 클래스를 사용하거나 클래스를 설계할 때 상태를 변경할 수 없도록(final 키워드) 만들어서 스레드에 안전하도록 한다
- **고립(Isolation)**
    - 스레드들이 서로 영향을 주지 않도록 데이터를 고립시킵니다.
  
