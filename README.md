## 자바 동시성 프로그래밍
자바에서 쓰레드는 내부적으로는 운영체제의 도움을 받아 작동하게 된다.  
쓰레드 생성되는 시점에 운영체제가 개입을 해 제어하는 방식으로 동작한다.  
### 동작 방식
1. **쓰레드 생성**: 자바에서 쓰레드를 생성하면, JVM은 이 요청을 운영체제에 전달한다. 운영체제는 이를 수행하고, 자바 쓰레드에 대응하는 운영체제 수준의 쓰레드를 생성.
2. **쓰레드 스케줄링과 관리**: 쓰레드의 실행, 스케줄링(언제 어떤 쓰레드가 실행될지 결정하는 과정)은 운영체제의 책임이다. JVM은 운영체제의 스케줄링 정책을 따르며, 운영체제는 사용 가능한 프로세서 자원을 쓰레드에 할당
3. **사용자 수준 쓰레드와 커널 수준 쓰레드**: 일부 운영체제에서는 사용자 수준 쓰레드(운영체제 커널이 관리하지 않는 쓰레드)와 커널 수준 쓰레드(운영체제 커널에 의해 직접 관리되는 쓰레드)를 지원한다. `자바`는 이러한 구분 없이 **투명하게 쓰레드를 관리**하도록 설계되었습니다.
4. **플랫폼 독립성**: 자바의 플랫폼 독립성으로 인해, 동일한 자바 쓰레드 코드가 다양한 운영체제에서 동일하게 작동할 수 있다. 그러나 쓰레드의 성능과 행동은 운영체제에 따라 다를 수 있다.
5. **JVM과 운영체제의 최적화**: 최신 JVM과 운영체제는 쓰레드 성능을 최적화하기 위해 긴밀하게 협력한다. 예를 들어, 가비지 컬렉션, 쓰레드 풀 관리 등은 JVM과 운영체제 간의 효율적인 상호작용을 통해 이루어진다.
  
이처럼 자바의 쓰레드와 운영체제는 긴밀하게 서로 소통하기 때문에 이 쓰레드를 잘 이해하기 위해서는 그 밑단에 흐르는 운영체제에서 동작하는 기본적인 쓰레드 원리 와 작동원리 및 도시성에 대하여 알 필요가 있다.  
즉, 자바쓰레드가 실행되는 시점에 운영체제의 상태와 쓰레드간의 전환이 발생하는 문제에 대한 처리 방법등 이러한 기본적인 흐름에 대한 이해가 필요하다.  
  
# 프로세스 와 쓰레드
| 프로세스 | 쓰레드 |
| --- | --- |
| 운영체제로부터 자원을 할당 받은 작업 단위 | 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위 |  
## 프로세스
### 프로그램
운영체제에 의해 시스템에 설치되어 있는 파일을 프로그램이라 말한다.  
예를들어 윈도우의 `.exe` 파일이나 Mac의 `.dmg` 파일과 같은 컴퓨터에서 실행할 수 있는 파일을 통칭한다.  
즉 아직 **파일을 실행하지 않는 상태**를 말한다.  
  
### 프로세스
프로그램이 실행하지 않는 파일을 말한다면 이를 **동작시켜서 프로그램이 돌아가고 있는 상태**를 프로세스라고 한다.  
즉, 프로세스는 프로그램의 실제 실행을 의미하며 이를 실행함으로써 프로그램의 **데이터들이 메모리에 올라와 cpu를 할당받고 명령을 수행하고 있는 상태** 이다.  

| 프로그램 | 프로세스 |
| --- | --- |
| 어떤 작업을 하기 위해 실행할 수 있는 파일 | 실행되어 작업중인 컴퓨터 프로그램 |
| 파일이 저장 장치에 있지만 메모리에는 올라가 있지 않은 정적인 상태 | 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태 |
| 코드 덩어리 | 코드 실행시킨 것 |  
    
프로세스가 메모리를 할당받으면 할당받은 메모리 일부를 커널 서비스를 위해 별도로 할당해준다.
## 쓰레드
오늘날 우리가 컴퓨터에서 파일을 다운로드 받으면 다른 작업을 당연하게 할 수 있지만 예전에는 파일을 다운로드 받으면 이 작업이 종료될때까지 기다려야 다음 작업을 할 수 있었다. 그렇다고 동일한 프로그램을 여러개의 프로세스로 만들게 되면 메모리와 CPU의 자원이 중복되게 되는 문제점이 발생한다. 이러한 한계를 극복하고자 나온 개념이 쓰레드이다.  
  
즉, **하나의 프로세스 내에서 동시에 진행되는 작업의 갈래, 흐름의 단위를 말한다.** 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다. 실질적으로 **프로세스는 운영체제로부터 메모리 자원을 할당 받는 것**이고 실제 **CPU를 할당받아서 우리가 제안한 코드를 실행하는 주체는 스레드**이다.
  
## 프로세스의 메모리 구조
- **코드 영역(Code/ Text)**: 프로그래머가 작성한 프로그램 함수들의 코드가 CPU가 해석 가능한 기계어 형태로 저장
- **데이터 영역(Data)**: 코드가 실행되면서 사용하는 전역 변수나 각종 데이터들이 모여있다. 데이터영역은 .data ,.rodata, .bss 영역으로 세분화 된다.
    - .data: 전역변수, 또는 static 변수 등 프로그램이 사용하는 데이터를 저장
    - .BSS : 초기값 없는 전역 변수, static 변수가 저장
    - .rodata: const 같은 상수 키워드 선언 된 변수나 문자열 상수가 저장
- **스택 영역(Stack):** 지역 변수와 같은 호출한 함수가 종료되면 되돌아올 임시적인 자료를 저장하는 독립적인 공간. Stack은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 만일 stack 영역을 초과하면 stack overflow 에러가 발생한다.
- **힙 영역(Heap):** 생성자, 인스턴스와 같은 동적으로 할당되는 데이터들을 위해 존재하는 공간이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
  
운영 체제는 프로세스마다 위처럼 각각 독립적인 메모리 영역을 할당해 주게 된다. 이때 코드 영역과 데이터 영역은 크기가 정해져 있지만, **스택 영역과 힙영역은 실행 되는 동안 크기가 늘었다가 줄었다가 하는 동적 영역**이다.  
이렇게 프로세스 마다 독립된 메모리 영역이 할당되기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행 할 수 있다. 기본적으로 프로세스간의 정보 공유가 완전히 불가능한 것은 아닌데 IPC(Inter-Process Communication) , LPC(Local inter-Process Communication), 별도로 공유 메모리를 만들어서 정보를 주고받도록 설정하면 공유가 가능하다.  
  
## 쓰레드의 자원 공유
 쓰레드는 프로세스가 운영체제로부터 할당 받은 자원을 이용하는 실행,흐름 단위로서 하나의 프로세스는 하나 이상의 스레드를 갖는다. 스레드가 여러개 있으면 우리가 브라우저에서 파일을 다운로드 받으면서 동시에 웹서핑을 할 수 있게 해준다.  
이 쓰레드는 **프로세스의 자원을 공유** 하면서 실행 흐름의 일부가 되기때문에 **동시 작업이 가능**한 것이다. 이 프로세스의 자원공유란 프로세스 내에서 각 필요한 스택(함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수 내에서 선언하는 변수 등을 저장하는 공간)만 할당 받고 `코드,데이타,힙 영역`을 공유한다.  
이때 스레드 간 메모리 스택 영역에는 서로 접근할 수 없으므로 스레드는 독립적인 실행 흐름을 가질 수 있게되어 독립적인 함수 호출이 가능해 진다.  
  
# CPU
## CPU
CPU (Central Processing Unit)는 컴퓨터의 주요 구성 요소로, **컴퓨터의 모든 명령을 처리**하는 데 필요한 계산 및 제어 작업을 수행합니다. CPU는 컴퓨터의 `두뇌`로 간주되며, 모든 프로그램 실행, 데이터 처리, 명령 실행 등을 담당합니다. CPU의 성능은 컴퓨터의 전반적인 속도와 성능에 중요한 영향을 미칩니다.
  
### CPU와 스레드
**스레드는 운영체제의 스케줄러에 의해 관리되는 CPU의 최소 실행단위를 의미한다.** 스케줄러 알고리즘에 따라 프로세스에 속한 한개의 스레드가 선점되어 CPU에 할당되고 스레드 선점이 일어날 때 CPU의 실행 흐름(문맥)이 전환되는 **컨텍스트 스위칭**이 발생한다.

### 멀티 코어와 쓰레드
컴퓨터 부품을 검색해보면 CPU 4코어 12쓰레드, 8코어 4쓰레드 이런 단어를 본적이 있을 것이다. CPU 한개는 여러 코어를 가질 수 있다.  
이 코어는 말그대로 CPU 코어 유닛인데, 명령어를 메모리에서 뽑아 해석하고 실행하는 유닛이 물리적으로 4개가 있으면 4코어, 8개가 있으면 8코어라고 불린다.  
이때 4코어 2쓰레드는 물리적인 코어 하나가 쓰레드 2개 이상을 동시에 실행 가능하다는 의미이고, 운영체제는 8개의 작업(4코어*2쓰레드)을 동시에 처리할 수 있다는 의미이기도 한다. 이를 하이퍼스레딩(Hyper-Threading) 기술이라 말한다.  

# CPU 작업의 병렬성(Parallelism) 과 동시성(Concurrency)
## 동시성
동시성은 둘 이상의 작업이 동시에 실행되는 것을 의미하는데 이는 **CPU가 한번에 많은 일을 처리하는 것**에 중점을 두고 있다. 즉, 많은 작업들을 아주 빠른 시간으로 교체하면서 전체 작업을 수행한다. 예를 들어 1개의 코어가 있고 여러개의 작업이 존재한다면 CPU는 프로세스들을 번걸아가며 조금씩 아주 빠르게 처리함으로써 마치 프로그램이 동시에 실행되는 것처럼 보인다.
이때 작업들을 번갈아가면서 실행하기 때문아 아주 잘게 나누어 조금씩 작업을 수행하고 다음 작업으로 넘어가는 식으로 동작한다. 이렇게 하는 이유는 여러 작업을 동시에 처리하는 것처럼 보이게 만들어 사용자에게 더 빠른 반응성을 제공하기 위해서이다.  
진행중인 작업들을 A -> B -> C -> D -> A 이런식으로 번걸아 바꾸는 작업을 **Context Switching** 이라고 부른다.  
이 동시성 **작업은 처리를 빠르게 하기 위한 목적이 아닌 CPU를 효율적으로 사용하는 것에 더 중점**을 두고 있다. 예를 들어 스레드가 작업을 처리하다가 IO 작업을 만나게 되면 현재 스레드를 대기시키고 다시 다른 스레드로 전환(다른 스레드를 할당)해서 작업을 진행한다. 따라서 이 동시성 작업에 대한 처리 방식을 어떤식으로 진행할 것인지(많은 작업들 어떻게 하면 효율적으로 처리 할지) 고려해야하며 동시성으로 작업해햐할 수가 CPU 코어 수 보다 많을 경우 해당되며 동시성이 없으면 작업을 순차적으로 진행한다.  
  
## 병렬성
병렬성은 직관적으로 명령어를 메모리에 뽑아 해석하고 실행하는 반도체 유닛인 **코어에 맞춰 여러개의 프로세스, 스레드를 돌려 병렬로 작업을 동시 수행**하는 것을 말한다. 이 병렬성은 **CPU가 동시에 많은 일을 수행하는 것에 중점**을 두고 CPU가 놀지않고 바쁘게 동작한다. 따라서 병렬성은 런타임에 동시에 물리적으로 작업을 실행하는 것이며 여러 컴퓨팅 리소스가 있는 하드웨어가 필요함로 한 개의 코어에서는 절대 병렬성이 구현될 수 없다.  
이 병렬성은 동시성의 하위 개념으로 여러 쓰레드로 작업을 분리하여 그 쓰레드를 CPU에 적절히 분배하여 동시적으로 실행하도록 하는 것이므로 병렬 작업해야할 수가 CPU 코어 수보다 같거나 적을 경우 효율이 가장 좋다.  
  
### 병렬성과 동시성의 조합
1. ThreadPoolExecutor
   * 병렬성으로 처리 성능을 극대화하고 동시성으로 CPU 자원을 효율적으로 관리
2. ForkJoinPool
   * **Parallelism Divide and Conquer 알고리즘**
   * Fork 생성하다는 의미 이다. 즉 하나의 큰 작업을 여러 하위 작업으로 분할한다음 여러개의 CPU 코어로 이 분할된 작업을 병렬로 처리하고 그결과들을 연결(Join) 하여 최종적으로 결과를 도출한다.
   * 하나의 작업을 서브 작업으로 분할하여 병렬처리함으로써 전체 작업 성늘을 높임

##   동시성의 개념차이
`"동시성"`이라는 용어는 컴퓨팅에서 다소 다른 맥락으로 두 가지 방식에서 사용된다. 하나는 프로세스 또는 스레드가 시스템에서 동시에 실행되는 것처럼 관리되는 일반적인 개념이고, 다른 하나는 멀티스레드 프로그래밍에서 발생할 수 있는 특정한 문제들과 관련된 개념이다.

1. **동시성(Concurrency) - 일반적 개념**:
    - 이 개념은 컴퓨터 프로그램, 프로세스, 스레드 등이 시스템 내에서 "동시에" 실행되는 것처럼 보이게 만드는 기능을 의미
    - 단일 코어 CPU에서는 이것이 시분할 방식으로 번갈아가며 실행되어, 동시에 실행되는 것처럼 보이게 하는 것이다. 멀티코어 CPU에서는 실제로 여러 작업이 동시에 실행될 수 있습니다.
2. **동시성(Concurrency) - 멀티스레드 프로그래밍의 문제점**:
    - 멀티스레드 환경에서 동시에 여러 스레드가 공유 자원에 접근할 때 발생하는 문제들을 지칭
    - 여기에는 경합 상태, 데드락, 라이브락, 스타베이션 등과 같은 문제가 포함됩니다. 이러한 문제들은 멀티스레드 환경에서 데이터의 무결성과 일관성을 유지하는 데 중요한 영향을 미칩니다.
        1. **경합 상태(Race Condition)**:
            - 두 개 이상의 스레드가 동시에 같은 데이터에 접근하고, 적어도 하나의 스레드가 그 데이터를 수정할 때 발생합니다.
            - 경합 상태는 데이터가 예상치 못한 방식으로 변경되어 부정확한 결과나 시스템의 실패를 초래할 수 있습니다.
        2. **데드락(Deadlock)**:
            - 두 개 이상의 스레드가 서로가 보유한 자원을 기다리며 무한히 대기하는 상태입니다.
            - 이 상황에서는 어떤 스레드도 진행할 수 없으며, 프로그램이 멈춰버릴 수 있습니다.
        3. **라이브락(Livelock)**:
            - 데드락과 유사하게, 스레드가 실행되고 있지만 실제로는 유용한 작업을 수행하지 못하는 상태입니다.
            - 스레드들이 서로를 피해 계속 상태를 변경하지만, 결국에는 아무런 진전도 이루지 못합니다.
        4. **스타베이션(Starvation)**:
            - 한 스레드가 필요한 자원에 접근하지 못하고 무한히 대기하는 상황입니다.
            - 특정 스레드가 CPU 시간이나 필요한 자원을 독점하여 다른 스레드가 작업을 수행할 기회를 얻지 못하는 경우 발생합니다.

따라서 동시성이라는 용어는 컴퓨팅의 광범위한 영역에서 다양한 맥락으로 사용되며, 그 의미는 사용되는 상황에 따라 달라진다. 일반적으로는 시스템이 여러 작업을 동시에 처리할 수 있는 능력을 나타내며, 멀티스레딩 환경에서는 이러한 동시 작업 처리로 인해 발생할 수 있는 특정 문제들을 가리킨다.



# 프로세스,스레드의 생명주기
프로세스와 스레드의 생명주기는 운영 체제의 스케줄링 및 자원 관리와 밀접하게 연관되어 있습니다. 프로세스는 보다 무거운 자원 사용을 하며, 스레드는 같은 프로세스 내에서 더 가볍게 자원을 공유한다.  
  
## 프로세스 스케줄링
프로세스 스케줄링(Process Scheduling)은 운영체제에서 CPU를 사용할 수 있는 프로세스를 선택하고, CPU를 할당하는 작업을 말한다.이는 시스템의 효율성, 반응성, 공정성을 극대화하는 데 중요한 역할을 하고 다양한 스케줄링 알고리즘이 있으며, 각각의 사용 환경과 요구 사항에 따라 적합한 알고리즘이 선택된다.  

프로세스 스케줄링은 프로세스의 우선순위, 작업량등을 고려하여 효율적으로 배치하고 이를 통해 운영체제는 CPU를 효율적으로 사용하며 시스템 전반적인 성능을 향상시킨다. 이는 멀티 태스킹 작업을 만들어내는 데에 있어서 핵심적인 부분이다.  
  
대표적으로는 해당 알고리즘 등이 있다. 
1. FCFS (First-Come, First-Served)  
   특징: 가장 간단한 스케줄링 알고리즘으로, 먼저 도착한 프로세스가 먼저 서비스를 받습니다.  
   장점: 구현이 쉽고, 공정합니다.  
   단점: 짧은 작업이 긴 작업 뒤에 오면 대기 시간이 길어지는 '호위 효과(Convoy Effect)' 발생 가능.
2. SJF (Shortest-Job-First)
   특징: 예상 실행 시간이 가장 짧은 프로세스를 먼저 실행합니다.  
   장점: 평균 대기 시간을 최소화할 수 있습니다.  
   단점: 실행 시간을 미리 알아야 하며, 긴 작업은 무한정 대기할 수 있습니다 (기아 현상).  
3. 우선순위 스케줄링 (Priority Scheduling)  
   특징: 각 프로세스에 우선순위를 부여하고, 높은 우선순위의 프로세스를 먼저 실행합니다.  
   장점: 중요한 작업을 빠르게 처리할 수 있습니다.  
   단점: 낮은 우선순위의 프로세스가 기아 상태에 빠질 수 있습니다.  
4. RR (Round-Robin)  
   특징: 각 프로세스에 동일한 시간 할당량(Time Quantum)을 주고, 순서대로 실행합니다.  
   장점: 모든 프로세스가 공정하게 CPU 시간을 받으며, 반응 시간이 짧습니다.  
   단점: 시간 할당량의 크기에 따라 성능이 크게 달라질 수 있습니다.  
5. 멀티레벨 큐 (Multilevel Queue)  
   특징: 프로세스를 여러 큐로 분류하고, 각 큐에 다른 스케줄링 알고리즘을 적용합니다.  
   장점: 다양한 유형의 프로세스를 효율적으로 관리할 수 있습니다.  
   단점: 큐 사이의 이동 규칙과 각 큐에 대한 스케줄링이 복잡할 수 있습니다.  
  
## 프로세스 상태
프로세스의 상태는 프로세스가 실행되는 동안 변경되는 고유의 상태를 의미 하며 프로세스가 생성되어 실행하기 까지 프로세스는 여러가지의 상태를 갖게 되고, 상태의 변화에 따라 프로세스가 동작 되는 것이다.  
1. **생성 (Creation)**: 프로세스가 생성되며, 이 때 필요한 자원과 메모리가 할당됩니다.
2. **준비 (Ready)**: 프로세스가 CPU에서 실행될 준비가 되어 대기합니다.
3. **실행 (Running)**: 프로세스가 CPU를 할당받아 명령을 실행합니다.
4. **대기 (Waiting)**: 프로세스가 특정 이벤트나 자원을 기다리는 동안 일시적으로 중지됩니다.
5. **종료 (Termination)**: 프로세스가 실행을 완료하고 모든 자원이 해제됩니다.
  
## 프로세스 상태 전이
프로세스의 상태전이(Process State Transition)는 프로세스가 생명주기 동안 거치는 다양한 상태와 그 상태들 간의 전환을 나타낸다. 일반적으로 프로세스는 다음과 같은 상태들을 거진다.  

1. 신규 (New): 프로세스가 생성되고 초기화되는 단계입니다. 이때 커널 영역에 PCB가 만들어 짐

2. 준비 (Ready): 프로세스가 CPU에서 실행될 준비가 되어 있으며, 실행을 기다리는 상태입니다.

3. 실행 (Running): 프로세스가 CPU를 할당받아 명령어들을 실행하는 상태입니다.

4. 대기 (Waiting): 프로세스가 I/O 작업이나 특정 이벤트의 완료를 기다리는 상태입니다.

5. 종료 (Terminated): 프로세스가 실행을 완료하고 시스템에서 제거되는 상태입니다.

### 상태전이
1. 신규 -> 준비: 프로세스가 생성되어 실행을 위해 준비됩니다.

2. 준비 -> 실행: 스케줄러가 프로세스를 선택하여 CPU를 할당합니다.

3. 실행 -> 대기: 프로세스가 I/O 작업을 요청하거나 특정 이벤트를 기다려야 할 때입니다.

4. 대기 -> 준비: I/O 작업이 완료되거나 기다리던 이벤트가 발생하여 다시 CPU에서 실행될 준비가 됩니다.

5. 실행 -> 준비: 선점형 스케줄링에서, 프로세스가 CPU 할당 시간을 다 쓰거나 더 높은 우선순위의 프로세스가 준비 상태가 되었을 때 발생합니다.

6. 실행 -> 종료: 프로세스가 모든 작업을 완료하고 시스템에서 제거됩니다.
  
## 스레드 생명주기
스레드는 프로세스 내에서 실행되는 실행 단위이다. 스레드의 생명주기는 다음과 같다:

1. 생성 (New): 스레드가 생성되고 초기화됩니다.
2. 준비 (Ready): 스레드가 실행을 위해 준비되며 CPU 할당을 기다립니다.
3. 실행 (Running): 스레드가 CPU를 할당받아 실행됩니다.
4. 대기 (Blocked): 스레드가 I/O 작업과 같은 이유로 일시적으로 중지됩니다.
5. 종료 (Terminated): 스레드가 작업을 완료하고 종료됩니다.  

프로세스와 스레드의 생명주기는 운영 체제의 스케줄링 및 자원 관리와 밀접하게 연관되어 있다. 프로세스는 보다 무거운 자원 사용을 하며, 스레드는 같은 프로세스 내에서 더 가볍게 자원을 공유한다.  
  
# 프로세스 컨텍스트 스위칭
하나의 CPU는 동일한 시간에 하나의 작업만 수행할 수 있기 때문에 여러 프로세스를 동시에 실행할 수 없다. 하나의 CPU에서 여러 프로세스를 동시성으로 처리하기 위해서는 **한 프로세스에서 다른 프로세스로 전환**해야 하는데 이것을 **컨텍스트 스위치** 라고한다.  

즉, **컨텍스트 스위칭(Context Switching)은 운영 체제에서 CPU가 하나의 프로세스 또는 스레드에서 다른 프로세스 또는 스레드로 전환하는 과정**을 말한다.  
  
CPU는 한번에 하나의 프로세스만 실행할 수 있으므로, 여러개의 프로세스를 번갈아가며 실행하여 CPU 활용률을 높이기 위해 컨텍스트 스위칭이 필요하다.  
  
컨텍스트 스위칭은 **동작중인 프로세스가 대기를 하면서 해당 프로세스의 상태를 보관**하고, 대기하고 있던 **다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업**을 말한다. 이러한 컨텍스트 스위칭이 일어날때 다음번 프로세스는 스케줄러가 결정하게 된다.  
1. **현재 프로세스의 상태 저장**: 현재 실행 중인 프로세스 또는 스레드의 상태(컨텍스트)를 저장합니다. 컨텍스트에는 프로그램 카운터, 레지스터 값, 메모리 상태 등이 포함됩니다.

2. **다음 프로세스의 상태 복원**: 다음에 실행할 프로세스 또는 스레드의 컨텍스트를 복원합니다. 이를 통해 이전에 중단된 지점부터 실행을 계속할 수 있습니다.
  
### 컨텍스트(Context)
컨텍스트 스위치(context switch)에서의 `"컨텍스트"`는 운영 체제가 프로세스나 스레드를 **교체할 때 저장하고 복원해야 하는 그 프로세스나 스레드의 상태 정보**를 의미한다. Context는 CPU가 해당 프로세스를 실행하기 위한 프로세스의 정보를 의미하며 정보들은 운영체제가 관리하는 PCB 라고 하는 자료 구조 공간에 저장한다.  

## PCB( Process Control Block)
PCB(Process Control Block)는 운영 체제에서 프로세스를 관리하기 위해 사용하는 커널 내의 중요한 데이터 구조(프로세스의 상태정보등)이다.프로세스를 컨텍스트 스위칭 할때 기존 프로세스의 상태를 어딘가에 저장해 둬야 다음에 똑같은 작업을 이어 서 할 수 있을 것이고, 새로 해야 할 작업의 상태 또한 알아야 어디서부터 다시 작업을 시작할지 결졍할 수 있을 것이다.  

즉, PCB는 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보 저장하는 **임시저장소**인 것이고 컨텍스트 스위칭은 CPU가 프로세스 간 PCB(Process Control Block) 정보를 교체하고 기존에 저장했던 PCB(Process Control Block)를 비우는 일련의 과정이라고 불 수 있다.  
  
**프로세스가 생성되면 메모리에 해당 프로세스의 PCB가 함께 생성되고, 종료 시 삭제**된다. 따라서 운영체제는 PCB에 담긴 프로세스 고유 정보를 통해 프로세스를 관리하고, 프로세스의 실행 상태를 파악하고, 우선순위를 조정하며, 스케줄링을 수행하고, 다른 프로세스와의 동기화를 제어한다.  
### PCB의 주요 구성 요소
* **프로세스 식별자 (Process Identifier, PID)**: 각 프로세스를 구별하는 고유한 식별자입니다.

* **프로세스 상태 (Process State)**: 프로세스가 현재 어떤 상태에 있는지를 나타냅니다 (예: 준비, 실행, 대기).

* **프로그램 카운터 (Program Counter)**: 프로세스가 다음에 어떤 명령어를 실행해야 하는지를 가리키는 카운터입니다.

* **레지스터 세트 (Register Set)**: 프로세스 실행 중 필요한 레지스터들의 현재 값을 저장합니다.

* **메모리 관리 정보 (Memory Management Information)**: 프로세스의 주소 공간, 페이지 테이블, 세그먼트 테이블 등 메모리 관련 정보를 포함합니다.

* **계정 정보 (Accounting Information)**: 프로세스 실행 시간, 사용된 CPU 시간, 프로세스가 시작된 시간 등을 기록합니다.

* **I/O 상태 정보 (I/O Status Information)**: 프로세스에 할당된 I/O 장치 목록과 열린 파일 목록 등이 포함됩니다.  
  
> Register란?  
레지스터는 컴퓨터의 중앙 처리 장치(CPU) 내부에 있는 매우 빠른 메모리 단위입니다. 이들은 CPU가 수행하는 연산에 필요한 데이터나 연산 결과를 일시적으로 저장하는 역할을 합니다. 레지스터는 컴퓨터의 데이터 처리 속도에 큰 영향을 미치는 중요한 구성 요소입니다.  
>  
> PCB와 레지스터  
PCB(Process Control Block) 내의 레지스터 세트는 특정 프로세스가 중단될 때 그 프로세스의 레지스터 상태를 저장합니다. 컨텍스트 스위칭 시, 이 정보는 해당 프로세스가 재개될 때 CPU에 다시 로드되어 프로세스가 중단된 지점부터 연산을 계속할 수 있도록 합니다. 이는 멀티태스킹 환경에서 각 프로세스의 실행 상태를 유지하는 데 필수적입니다.
  
## Context Switching 과정
![switching.png](src%2Fresources%2Fstatic%2Fimg%2Fswitching.png)  
해당 이미지는 두 개의 프로세스 P1과 P2가 CPU를 공유하며 실행되는 컨텍스트 스위칭 과정을 도식화한 것이다.  
1. **프로세스 P1 실행 중**: 초기 상태에서 프로세스 P1이 CPU를 사용하여 실행 중입니다.
2. **인터럽트 또는 시스템 콜 발생**: 프로세스 P1의 실행 중에 인터럽트 또는 시스템 콜이 발생합니다. 이는 CPU가 다른 작업을 수행해야 함을 의미하며, 이 때문에 프로세스 P1의 실행이 중단됩니다.
3. **프로세스 P1 상태 저장**: CPU는 프로세스 P1의 현재 상태(레지스터 값, 프로그램 카운터 등)를 프로세스 P1의 PCB(PCB1)에 저장합니다. 이로써 프로세스 P1은 중단된 지점에서 나중에 재개할 수 있습니다.
4. **프로세스 P2 상태 복원**: 이어서 CPU는 프로세스 P2의 이전 상태를 PCB(PCB2)에서 가져와 CPU에 로드합니다. 프로세스 P2는 이전에 중단됐던 지점부터 실행을 재개합니다.
5. **프로세스 P2 실행**: CPU는 이제 프로세스 P2를 실행 상태로 전환하고, 프로세스 P1은 대기 상태(Idle)로 전환됩니다.
6. **두 번째 인터럽트 또는 시스템 콜 발생**: 프로세스 P2가 실행 중일 때 또 다른 인터럽트 또는 시스템 콜이 발생합니다.
7. **프로세스 P2 상태 저장**: 프로세스 P2의 현재 상태는 PCB2에 저장됩니다.
8. **프로세스 P1 상태 복원**: 다시 프로세스 P1의 상태가 PCB1에서 가져와 CPU에 로드되어 프로세스 P1이 실행을 재개할 수 있도록 합니다.
  
## Context Switching Overhead
컨텍스트 스위칭 오버헤드(Context Switching Overhead)는 운영 체제가 하나의 프로세스에서 다른 프로세스로 전환할 때 발생하는 추가적인 시간 및 자원 소모를 말한다. 이때 전환되는 과정에서 프로세스의 상태, 레지스터 값등이 저장되고 불러오는 등의 작업이 수행되기 때문에 시스템에 많은 부담을 준다.  
  
컨텍스트 스위칭 과정에서 위의 그림에서 P1이 실행 중에 P2의 작업에 대한 실행요청이 왔을때 바로 실행되는 것이 아니라 **대기 상태**에 있다가 실행 되는 것을 확인할 수 있는데 이 **간극이 바로 컨텍스트 스위창 오버헤드 인 것**이다.  
  
즉,오버헤드는 프로세스가 실행 상태에서 대기 상태로 바뀌고, 다시 실행 상태로 돌아올 때 발생하는 일련의 작업들과 관련이 있습니다.  
  
### 오버헤드에 포함되는 주요 작업
1. 레지스터 상태 저장 및 복원
2. 메모리 관리자 업데이트
3. 캐시 초기화 또는 업데이트
4. 보안 및 접근성 업데이트
  
# 스레드 스케줄링
스레드 스케줄링은 프로세스 내의 개별 스레드에 CPU 시간을 할당하는 과정이다.즉, 스레드 스케줄링은 운영체제에서 다중 스레드를 관리하며, CPU를 사용할 수 있는 스레드를 선택하고, CPU를 할당하는 작업을 말한다.  

이는 프로세스 스케줄링과 유사하지만, 스레드는 프로세스보다 더 가벼운 실행 단위이며, 일반적으로 같은 프로세스 내의 스레드들은 일부 자원(예: 메모리)을 공유한다.이 스레드 스케줄링의 주요 목적은 CPU 사용률을 극대화하고, 프로그램의 응답 시간을 최소화하며, 시스템 전반의 처리량을 증가시키는 것이다.  

다만 스레드 스케줄링은 프로세스 스케줄링과 다르게, 하나의 프로세스 내에서 다수의 스레드가 동작하는 형태이기 때문에, 스레드 간의 상호작용과 동기화 문제를 고려해야 한다는 차이점이 존재한다.  
  
## 스레드 컨텍스트 스위치
스레드 컨텍스트 스위칭은 프로세스 컨텍스트 스위칭과 유사한 메커니즘을 가지고 있지만, 주로 같은 프로세스 내의 스레드들 사이에서 일어나며, 비교적 더 가볍다. 이는 같**은 프로세스 내의 스레드들이 코드, 데이터, 힙 영역과 같은 메모리 자원을 공유**하기 때문이다.  

### **스레드 컨텍스트 스위칭 과정**

1. **스레드 상태 저장**: 현재 실행 중인 스레드의 상태(레지스터 세트, 프로그램 카운터 등)를 저장합니다.
2. **CPU 레지스터 변경**: 다음 실행할 스레드의 상태 정보로 CPU의 레지스터를 업데이트합니다.
3. **스택 포인터 변경**: 다음 실행할 스레드의 스택 포인터로 변경하여, 해당 스레드의 스택 프레임에 접근할 수 있도록 합니다.
4. **프로그램 카운터 업데이트**: 프로그램 카운터를 다음 스레드가 계속해서 실행할 코드의 주소로 업데이트합니다.
5. **스레드 상태 복원**: 중단되었던 다른 스레드의 상태를 복원합니다.  

## TCB(Thread Control Block)
PCB 처럼, TCB (Thread Control Block)는 각 스레드마다 운영 체제에서 유지하는 스레드에 대한 정보를 담고 있는 자료 구조이다.TCB는 PCB 블록안에 들어 있다. 스레드가 프로세스 내에 위치한 것 처럼 말이다.  

프로세스의 정보를 저장하는 PCB(Process Control Block)와 유사하게, TCB는 스레드의 상태, 스레드 식별자, 레지스터 세트, 프로그램 카운터, 스택 포인터, 우선순위, 상태 정보 등 스레드 실행에 필요한 모든 정보를 포함하고 있다. TCB도 스레드가 생성될 때 운영 체제에 의해 생성되며, 스레드가 실행을 마치고 소멸될 때 함께 소멸된다.  

스레드 간의 자원 공유와 동기화도 TCB를 사용하여 관리된다. 예를 들어, 뮤텍스(mutual exclusion)나 세마포어(semaphore)와 같은 동기화 기법을 사용할 때, TCB에서 해당 스레드의 뮤텍스나 세마포어 정보를 관리하고, 스레드가 해당 자원에 대한 접근 권한을 획득하거나 반납할 때 TCB의 정보를 업데이트하게 된다.  
1. **뮤텍스 (Mutex)**:
   - 뮤텍스는 "Mutual Exclusion"의 줄임말로, 한 번에 하나의 스레드만 특정 자원에 접근할 수 있도록 합니다.
   - 뮤텍스는 임계 영역(critical section)에 대한 접근을 제어하여, 동시성 문제를 방지합니다.
   - 뮤텍스는 잠금(lock)과 해제(unlock) 메커니즘을 사용하여 자원을 보호합니다.
2. **세마포어 (Semaphore)**:
   - 세마포어는 뮤텍스와 유사하지만, 한 번에 여러 스레드가 자원에 접근할 수 있는 '카운트' 개념을 제공합니다.
   - 세마포어는 특정 자원이 여러 개 있을 때 유용하며, 자원의 사용 가능한 개수를 관리합니다.
   - 세마포어는 신호를 보내 자원을 획득하거나 반납하는 방식으로 작동합니다.
  
# 프로세스 컨텍스트 스위칭 vs 스레드 컨텍스트 스위칭
프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭은 둘 다 운영 체제가 실행 중인 작업 간에 CPU를 전환하는 데 사용하는 메커니즘입니다. 그러나 이 두 스위칭 방식 사이에는 중요한 차이점이 있다.  

1. TCB가 PCB 보다 가볍다
   - **프로세스 컨텍스트 스위칭**은 프로세스 간에 전환할 때 발생하며, 더 많은 시간과 자원을 소모합니다.
   - **스레드 컨텍스트 스위칭**은 같은 프로세스 내의 스레드들 간의 전환에 사용되며, 상대적으로 오버헤드가 적습니다.
2. 캐시 메모리 초기화
   1. 프로세스 컨텍스트 스위칭
      - 프로세스 간에 컨텍스트 스위칭을 할 때, 새로운 프로세스는 다른 메모리 공간을 사용합니다.
      - CPU 캐시에 로드된 데이터는 이전 프로세스의 메모리 주소 공간에 대응되므로, 새 프로세스에는 무효가 됩니다.
      - 결과적으로 캐시 메모리는 초기화되거나 새로운 프로세스의 데이터로 재충전되어야 합니다.
      - 이로 인해 캐시 미스가 증가하고 성능이 저하될 수 있습니다.
   2. 스레드 컨텍스 스위칭
      - 동일 프로세스 내의 스레드들은 메모리 공간을 공유하기 때문에, 캐시에 있는 데이터가 여전히 유효할 수 있습니다.
      - 스레드 간 스위칭 시에 캐시를 초기화할 필요가 없거나, 초기화가 필요한 범위가 매우 제한적입니다.
      - 따라서 스레드 스위칭은 캐시 메모리의 재사용도가 높고, 캐시 효율성이 유지되어 성능 저하가 적습니다.
3. 자원 동기화
   1. 프로세스 컨텍스트 스위칭
      - 프로세스들은 독립적인 메모리 공간을 가지고 있으며, 일반적으로 서로의 자원에 접근하지 않습니다.
      - 자원 동기화의 필요성이 상대적으로 낮고, 프로세스 간 통신을 위해서는 IPC(Inter-Process Communication) 메커니즘이 사용됩니다.
      - 프로세스 간의 자원 공유가 일어날 때는 주로 파일 시스템, 데이터베이스, 네트워크 소켓 등을 통해 관리됩니다.
   2. 스레드 컨텍스 스위칭
      - 스레드들은 같은 프로세스의 메모리 공간 내에서 코드, 데이터, 힙 등을 공유합니다.
      - 공유 자원에 대한 접근을 동기화하기 위해 뮤텍스, 세마포어, 모니터 등의 동기화 메커니즘이 필요합니다.
      - 스레드 간 동기화는 공유 자원에 대한 일관성을 유지하고 경쟁 상태(race condition)를 방지하기 위해 중요합니다.
      - 동기화는 오버헤드를 발생시킬 수 있으며, 잘못 관리될 경우 데드락(deadlock)이나 스타베이션(starvation) 같은 문제를 일으킬 수 있습니다.

## CPU Bound / IO Bound
프로세스는 CPU 작업과 I/O 작업의 연속된 흐름으로 진행된다. 프로세스는 CPU 명령어를 수행하다가 I/O를 만나면 대기하고 I/O 작업이 완료되면 다시 CPU 작업을 수행한다. 이러한 작업을 반복한다.  

이때 **CPU 바운드(CPU Bound) 와** **I/O 바운드(I/O Bound)는** 프로그램의 성능을 제한하는 요소에 대한 두 가지 다른 상황을 설명한다. 이 용어들은 프로그램이나 시스템이 어떤 자원에 의해 주로 성능이 제한되는지를 나타낸다.  

###  기본 용어

1. **Burst (버스트)**
   - 어떤 현상이 짧은 시간 안에 집중적으로 일어나는 것을 의미한다.
   - 한 작업을 짧은 시간동안 집중적으로 연속해서 처리하거나 실행하는 것
2. **Input/output (IO)**
   - 파일을 읽고 쓰거나, 네트워크 어딘가에 있는 다른 존재와 데이터를 주고받거나, 모니터/ 마우스 같은 입출력 장치와 데이터를 주고 받는 것을 IO라고 한다.
3. **CPU 버스트**
   - 프로세스가 CPU에서 한 번에 연속적으로 실행되는 시간을 의미한다. (CPU를 연속적으로 사용하면서 명령어를 실행하는 구간)
   - 메모리에 올라가 있는 프로세스가 자신의 차례가 되어서 CPU에서 실행됐을 때 자신의 명령어들이 CPU에서 연속적으로 실행되는 시간을 의미한다.
   - 프로세스가 CPU 명령어를 실행하는데 소비하는 시간 (프로세스의 RUNNING 상태를 처리)
4. **IO 버스트**
   - 프로세스가 IO 작업을 요청하고, 그 결과를 기다리는 시간을 의미한다.
   - 프로세스의 WAITING 상태를 처리

### ****CPU와 I/O 버스트의 교차****

대부분의 프로세스는 CPU 버스트와 I/O 버스트가 교대로 발생하는 패턴을 보인다. 예를 들어, 프로세스는 계산(CPU 버스트)을 수행한 후 결과를 파일에 저장(I/O 버스트)할 수 있습니다. 이러한 교차 패턴은 프로세스 스케줄링과 시스템 설계에 중요한 영향을 미칩니다. 예를 들어, CPU 바운드 프로세스는 짧고 빈번한 CPU 버스트를 보이는 반면, I/O 바운드 프로세스는 더 긴 I/O 버스트를 경험할 수 있습니다.

### 프로세스는 CPU 버스트 와 I/O 버스트의 연속된 흐름이다.

프로세스는 CPU 명령어를 수행하다가 I/O 를 만나면 대기하고 I/O 작업이 완료되면 다시 CPU 작업을 수행한다. 이 작업을 계속해서 반복하다 프로세스가 종료될땐 CPU 버스트로 마무리 된다.  

## CPU **Bounded Process**

CPU 바운드 프로세스는 주로 CPU의 처리 능력에 의해 성능이 제한되는 프로세스 이다. 이 유형의 프로세스는 계산 작업이 많으며(I/O Burst 가 거의 없는 경우), CPU의 사이클을 집중적으로 사용합니다.

예를 들어, 머신러닝, 블록체인, 동영상 편집 프로그램등 CPU 연산 위주의 작업을 하는경우를 의미한다 .CPU의 속도를 높이거나, 알고리즘을 최적화하거나, 멀티 쓰레딩 및 병렬 처리 기술을 적용하여 성능을 향상시킬 수 있다. 일반적으로 CPU 코어수와 스레드 수의 비율을 비슷하게 설정한다.

## **I/O Bounded Process**

I/O 바운드 프로세스는 입력/출력 작업에 의해 성능이 제한되는 프로세스 이다. 이 유형의 프로세스는 데이터를 읽고 쓰는 작업에 많은 시간을 소비합니다. 즉 I/O 버스트가 빈번하게 발생하는 프로세스로서 CPU 버스트가 매우 짧다.

예를 들어, 파일, 키보드, DB 네트워크 등 외부 연결이나 입출력 장치와의 통신 작업이 많은 경우에 해당된다. 더 빠른 스토리지 시스템(예: SSD), I/O 캐싱, 비동기 I/O 처리, 네트워크 대역폭 확장 등을 통해 성능을 개선할 수 있다. 이때 CPU 코어가 많을 경우 멀티 스레드의 동시성을 최대한 활용하여 CPU 가 Idle(대기상태)상태가 되지 않도록 하고 최적화 된 스레드 수를 운용해서 CPU의 효율적인 사용을 극대화 한다.  
  
## 사용자모드(User Mode) 와 커널 모드(Kernel Mode)
컴퓨터 시스템에서 "사용자 모드(User Mode)"와 "커널 모드(Kernel Mode)"는 운영 체제의 두 가지 주요 실행 모드를 나타낸다. 이들은 시스템 자원에 대한 접근 수준과 관련된 권한을 구분한다.  

## **커널(kernel)**

운영체제는 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어이고 여러 핵심 기능을 담당하는 부분을 **커널(kernel)**이라고 한다.

![9914C3435D4024A324.png](src%2Fresources%2Fstatic%2Fimg%2F9914C3435D4024A324.png)

커널은 운영 체제의 핵심 구성 요소로, 시스템의 하드웨어와 소프트웨어 사이에서 **중개자 역할**을 합니다. 기본적으로 커널은 컴퓨터의 하드웨어 자원과 관련된 모든 저수준 작업을 관리한다. 이것은 컴퓨터가 제대로 기능할 수 있도록 여러 중요한 서비스를 제공한다.  

즉, 사용자가 운영체제 위에서 실행되는 프로그램을 편하고 효율적으로 사용할 수 있게 하드웨어와 소프트웨어 간 중개 자 역할을 하고 CPU, I/O 장치, 메모리, 저장소와 같은 하드웨어 자원을 프로그램에 잘 할당하는 데 있다

> **저수준 작업 이란?**
>
>
> "저수준 작업(Low-level operations)"이라는 용어는 컴퓨터 프로그래밍 및 시스템 설계에서 하드웨어에 가까운 작업을 가리킵니다. 이러한 작업은 하드웨어 자원과 밀접하게 상호작용하며, 보통 운영 체제의 커널이 담당합니다. 저수준 작업은 추상화 수준이 낮아서, 일반적으로 다음과 같은 활동을 포함합니다:
>
> 1. **메모리 관리**: 물리적 메모리 할당, 해제, 페이지 교체, 가상 메모리와 페이지 테이블 관리 등.
> 2. **프로세스 스케줄링**: CPU 시간 할당, 프로세스 상태 관리, 컨텍스트 스위칭 등 프로세스 실행을 조율하는 작업.
> 3. **디바이스 드라이버 인터페이스**: 하드웨어 장치와의 통신을 위한 인터페이스를 제공하며, 입출력 요청의 중재, 버퍼 관리 등을 수행합니다.
> 4. **시스템 호출 처리**: 사용자 모드 프로세스가 요청하는 다양한 시스템 서비스에 대한 접근과 실행을 관리합니다.
> 5. **인터럽트 처리**: 하드웨어나 소프트웨어 인터럽트를 받고 적절한 처리 루틴을 실행합니다.
> 6. **네트워크 스택 관리**: 데이터 패킷의 송수신, 네트워크 인터페이스 관리, 프로토콜 처리 등 네트워크 통신에 필요한 작업을 수행합니다.
> 7. **보안 기능**: 사용자 인증, 접근 권한 체크, 암호화 및 해독 등의 보안 관련 기능을 실행합니다.

운영체제는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호한다.만약에 응용 프로그램이 하드웨어 자원에 직접 접근해서 조작 할 수 있다면 자원 관리가 되지 않고 프로세스 간 데이터가 훼손되어 컴퓨터 시스템 전체에 오류를 가져오게 된다. 따라서 응용프로그램이 하드웨어 자원에 접근하려고 할때는 반드시 운영체제를 통해서만 접근하도록 한다.  

## ****CPU Protection Ring****

운영체제는 프로세스들을 처리하기 위해 CPU의 기능과 시스템 자원에 접근할 수 있어야 한다. 하지만 컴퓨터의 주요한 자원에 무분별하게 접근할 수 있는 것은 아니다. 운영체제는 접근할 수 있는 권한이 부여된 요청만 CPU에 접근을 허락한다. 이 권한은 4가지로 분류되며, 접근 권한들을 분류하여 나눈 것을 CPU Protection Ring이라고 한다.

![cpuRing.png](src%2Fresources%2Fstatic%2Fimg%2FcpuRing.png)

CPU 보호 링(CPU Protection Rings)은 컴퓨터 시스템에서 보안 및 접근 제어를 제공하기 위해 사용되는 메커니즘이다. 이 개념은 주로 운영 체제와 하드웨어 아키텍처에서 사용되며, 다양한 권한 수준을 가진 여러 "링" 또는 "레벨"로 시스템을 분할하고 각 링은 서로 다른 권한과 책임을 가지며, 중심으로 갈수록 더 높은 권한을 가진다.  

CPU Protection Ring은 일반적으로 0부터 3까지의 숫자로 표현되며, 낮은 숫자일수록 더 높은 권한을 나타낸다. 주로 0부터 3까지의 권한 레벨이 사용된다.

- **레벨 0 (Level 0)**: 이것은 시스템의 **커널이 실행되는 가장 낮은 레벨**로, 시스템의 모든 자원에 대한 완전한 제어 권한을 가지고 있습니다. 여기에서 운영 체제의 핵심 부분들이 실행되며, 메모리 관리, 프로세스 스케줄링, 하드웨어와의 직접적인 상호작용 등을 담당합니다.
- **레벨 1 (Level 1)과 레벨 2 (Level 2)**: 이 레벨들은 일반적으로 **운영 체제의 특정 서브시스템**이나 **드라이버들에 의해 사용**됩니다. 이들은 커널 모드보다는 제한된 권한을 가지지만, 사용자 모드보다는 더 많은 시스템 자원에 접근할 수 있습니다. 대부분의 현대 운영 체제는 이 레벨들을 명시적으로 사용하지 않습니다.
- **레벨 3 (Level 3)**: **가장 바깥쪽 원이자 가장 낮은 권한을 가진 사용자 모드**입니다. 일반 애플리케이션들은 이 레벨에서 실행되며, 운영 체제로부터 제공받는 API를 통해 시스템 자원을 사용합니다. 이 레벨의 프로그램들은 직접적으로 하드웨어에 접근할 수 없으며, 모든 작업을 수행하기 위해 운영 체제에 요청을 보내야 합니다.

**0은 가장 높은 권한을 가진 커널 모드(Kernel Mode)이고**,**3은 가장 낮은 권한을 가진 사용자 모드(User Mode)이다.**

권한 레벨이 높은 커널 모드(Level 0)는 **운영체제와 시스템 자원에 대한 접근이 가능**하다. 반면에 **사용자 모드(Level 3)는** 프로세스가 제한된 자원에만 접근할 수 있으며, 시스템 자원에 직접 접근하는 것은 제한**된다. 운영체제는 CPU Protection Ring을 사용하여 사용자 프로세스 간의 충돌, 잘못된 접근, 시스템 자원의 남용 등을 방지하고, 운영체제의 안정성을 유지할 수 있다. 그리고 시스템 보안을 강화하여 악성 코드나 해킹 시도로부터 시스템을 보호한다.  

## CPU 권한 모드

CPU의 권한 모드는 운영 체제가 시스템의 자원과 작업을 관리하는 방법을 정의합니다. 가장 일반적인 두 가지 모드는 사용자 모드(User Mode)와 커널 모드(Kernel Mode)입니다.  
  
![cpuMode.png](src%2Fresources%2Fstatic%2Fimg%2FcpuMode.png)

### 사용자 모드(Mode Bit =1)

사용자 모드는 응용 프로그램이 실행되는 일반적인 모드입니다. 이 모드에서는 제한된 시스템 자원과 메모리에만 접근할 수 있다.

사용자 응용프로그램의 코드가 실행 되는 모드로서 메모리의 유저영역만 접근 가능하다. 사용자 모드에서 실행되는 프로그램은 커널 모드에서 허용하지 않는 일부 작업을 수행할 수 없습니다.  예를 들어 디스크, 메모리, Printer 및 여러 I/O 장치들과 같은 특정 리소스들에 직접 접근할 수 없다. 이는 시스템의 보안과 안정성을 유지하는 데 도움이 됩니다.

대부분의 응용프로그램은 입출력 장치나 파일로의 접근이 필요하기 때문에 이때는 유저모드에서 커널모드로 전환 되어야 한다.

### 커널 모드 (Mode Bit =0)

커널 모드는 운영 체제의 핵심 부분이 실행되는 모드로, 시스템의 모든 자원에 대한 완전한 접근 권한이 있다. 이 모드에서 실행되는 코드는 하드웨어와 직접 상호작용할 수 있으며, 메모리 관리, 프로세스 관리, 하드웨어 장치 제어 등의 중요한 작업을 수행한다.

즉, 메모리의 유저영역, 커널영역 모두 접근 가능하다.

## 시스템 콜

시스템 콜(System Call)은 응용 프로그램이 운영 체제의 커널 서비스를 요청할 때 사용하는 인터페이스입니다. 간단히 말해, 시스템 콜은 사용자 모드에서 실행 중인 프로그램이 커널 모드의 기능을 이용하고자 할 때 커널에 접근하는 방법이다.

### **시스템 콜의 역할**

1. **하드웨어 접근**: 직접적인 하드웨어 접근은 커널 모드에서만 가능하기 때문에, 응용 프로그램은 시스템 콜을 통해 하드웨어 자원을 안전하게 사용할 수 있습니다.
2. **자원 관리**: 파일 시스템 작업, 네트워크 통신, 프로세스 관리와 같은 시스템 자원을 효율적으로 관리합니다.
3. **보안과 안정성**: 시스템 콜은 사용자 모드와 커널 모드 간의 중요한 경계를 형성하여, 시스템의 안전과 안정성을 유지하는 데 기여합니다.

### **시스템 콜의 종류**

- **프로세스 관리**: 프로세스 생성 및 종료, 스케줄링 등을 관리합니다.
- **파일 조작**: 파일 열기, 읽기, 쓰기, 닫기 등의 파일 시스템 관련 작업을 수행합니다.
- **장치 관리**: 하드웨어 장치와의 통신과 관리를 담당합니다.
- **정보 유지**: 시스템 시간, 시스템 데이터 등에 대한 정보를 조회하거나 설정합니다.
- **통신**: 프로세스 간 통신(IPC)이나 네트워크 통신을 위한 시스템 콜입니다.

### **시스템 콜의 작동 방식**

1. **요청**: 응용 프로그램이 특정 작업을 수행하기 위해 시스템 콜을 요청합니다.
2. **모드 전환**: 시스템 콜이 실행되면 CPU는 사용자 모드에서 커널 모드로 전환됩니다.
3. **실행**: 커널은 요청된 작업을 수행합니다.
4. **복귀**: 작업이 완료되면 CPU는 다시 사용자 모드로 전환되고, 응용 프로그램으로 제어가 반환됩니다.

사용자 응용 프로그램은 작업 과정에서 커널의 기능을 사용하기 위해 매우 빈번하게 시스템 콜을 요청하고 이로 인해 사용자 모드와 커널 모드를 상호 전환하며 실행하게 된다. I/O 처리를 위해 사용자 모드와 커널 모드를 번갈아 오가는 것은 컨텍스트 스위칭과 관련이 있으며 이는 멀티 스레드 환경에서 참고해야 할 중요한 배경적 지식이다.

즉, 응용프로그램이 파일 입출력이나, 화면에 메시지를 출력하는 등의 기능은 커널 모드 일때 CPU가 실행하기 때문에 반드시 시스템 콜을 사용해서 커널 모드로 전환해야 한다.  
  
## 사용자 수준 스레드 , 커널 수준 스레드
사용자 수준 스레드(User-Level Threads)와 커널 수준 스레드(Kernel-Level Threads)는 운영 체제에서 스레드를 관리하는 두 가지 기본적인 방식을 나타낸다. 이 두 방식은 스레드의 생성, 스케줄링, 관리 방법에 있어서 차이를 가진다. 즉 생성 주체가 누구냐에 따라 구분된다.

사용자 수준 스레드는 사용자 프로그램에서 관리하는 스레드며 커널 수준 스레드는 OS 에서 관리하는 스레드이다

## **사용자 수준 스레드** (User Level Thread)

사용자 수준 스레드란 사용자 영역에서 스레드 라이브러리(Pthreads, Windows Threads, Java Threads(JVM)) 에 의해 스레드의 생성과 종료, 스레드간 메시지 전달, 스레드의 스케쥴링 보관 등 모든 것을 관리한다. 커널에 대한 추가적인 시스템 호출이 필요 없기 때문에 스레드의 생성, 전환, 스케줄링이 빠르다는 장점이 있다.

단, 커널은 이러한 스레드의 존재를 인지하지 못하며 단일 스레드 프로세스인 것처럼 관리한다. 한 스레드가 블록되면 프로세스 내의 모든 스레드가 블록될 수 있다. 또한, 멀티코어 활용에 제한이 있을 수 있다.

## **커널 수준 스레드** (Kernel Level Thread)

커널 수준 스레드는 운영 체제 커널에 의해 직접 관리됩니다(PCB와 TCB 관리 및 유지). 커널은 모든 스레드를 알고 있으며 각 스레드에 대한 정보를 가지고 있다.이때 커널은 커널 스레드의 모든 정보를 알고 있으며 커널 스레드는 OS 스케줄러에 의해서 스케줄링 된다. CPU 는 커널에 의해 생성된 커널 스레드의 실행만을 담당한다.

스레드 관리를 위한 시스템 호출이 필요하므로, 사용자 수준 스레드에 비해 오버헤드가 더 크다. 커널이 각 스레드를 개별적으로 관리할 수 있으므로, 멀티프로세서 시스템에서의 스레드 스케줄링과 병렬 처리가 용이하다.

# ****Multi Process 와 Multi Thread****

멀티 프로세스(Multi Process)와 멀티 스레드(Multi Thread)는 컴퓨터 프로그래밍에서 작업을 병렬로 처리하기 위한 두 가지 주요한 방식이다. 각각은 다른 메커니즘과 특성을 가지고 있으며, 특정 상황에 따라 적합한 방식을 선택하는 것이 중요합니다.

프로세스와 스레드가 단일이 아닌 다중으로 돌아감으로써 성능 향상 등 여러가지 효과를 얻을 수 있게 된다. 하지만 또한 이로 인해 발생되는 부가적인 문제점도 발생하게 된다. 따라서 각각의 장단점을 파악하여 적재적소에 사용하는 것이 요구된다.

## ****Multi Process****

멀티 프로세스는 운영체제에서 하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 실행할 수 있게 하는 기술을 말한다. 보통 하나의 프로그램 실행에 대해 하나의 프로세스가 메모리에 생성되지만, 부가적인 기능을 위해 여러개의 프로세스를 생성하는 것이다.

- 멀티 프로세스 와 멀티 프로세서
   - 프로세스(Process) 는 프로그램의 실행 상태를 말함
      - 멀티 프로세스: 하나의 프로그램에서 여러개의 프로세스를 실행하는 것
   - 프로세서(rocessor)는 CPU 코어를 말한다.
      - 멀티 프로세서: 여러개의 CPU 코어가 하나의 시스템에서 동시에 실행되는 것

멀티 프로세스 내부를 보면, **하나의 부모 프로세스가 여러개의 자식 프로세스를 생성**함으로서 다중 프로세스를 구성하는 구조이다.

한 프로세스는 실행되는 도중 프로세스 생성 시스템 콜을 통해 새로운 프로세스들을 생성 할 수 있는데 다른 프로세스를 생성하는 프로세스를 부모 프로세스(Parent Process)라 하고, 다른 프로세스에 의해 생성된 프로세스를 자식 프로세스(Child Process)라고 한다.

부모 프로세스와 자식 프로세스는 **고유한 PID(Process ID**)를 가지고 있다.

부모 프로세스는 자식 프로세스의 PID를 알고 있으므로, 이를 통해 자식 프로세스를 제어 할 수 있다.

자식 프로세스는 부모 프로세스의 PID 와 PPID(Parent Process ID)를 알고 있어, 이를 통해 부모 프로세스와 통신이 가능하다.

다만, 통신이 가능할 뿐이지, **부모 프로세스와 자식 프로세스는 엄연히 서로 다른 프로세스로 독립적으로 실행**되며, **독립적인 메모리 공간**을 가지고 있어서 **서로 다른 작업을 수행**한다.
예로는 웹 브라우저의 탭 이나 새창을 들 수 있다. 각 브라우저 탭은 같은 브라우저 프로그램 실행이지만, 각기 다른 사이트 실행을 행하기 때문이다.

서로 독립적이라는 것을 확인하기 위해서는 브라우저에서 갭라자 도구를 연다음 무한 루프 코드를 실행 시켜보면, 해당 탭에서는 클릭도 안되고 먹통이 되지만 다른 탭은 정상적으로 동작하는 것을 확인 할 수 있다.

- **장점**:
   - 안정성: 한 프로세스의 오류가 다른 프로세스에 영향을 미치지 않아 시스템 전체의 안정성이 유지됩니다.
   - 보안: 프로세스 간의 격리로 인해 보안이 강화됩니다.
- **단점**:
   - 오버헤드: 프로세스 간 커뮤니케이션(IPC)이 복잡하고, 자원 소모가 큽니다.
   - 리소스 사용: 각 프로세스가 별도의 메모리와 시스템 자원을 사용하기 때문에 리소스 사용이 비효율적일 수 있습니다.

## Multi Thread

스레드는 **하나의 프로세스 내에 있는 실행 흐름**이다. 그리고 멀티 스레드는 **하나의 프로세스 안에 여러개의 스레드가 있는 것**을 말한다. 따라서 하나의 **프로그램에서 두가지 이상의 동작을 동시에 처리하도록 하는 행위가 가능**해진다.

즉, 멀티 스레드는 하나의 프로세스 내에서 여러 개의 스레드가 동시에 실행되는 환경을 말합니다. 모든 스레드는 프로세스의 메모리 공간을 공유한다.

웹 서버는 대표적인 멀티 스레드 응용 프로그램이다. 사용자가 서버 데이터베이스에 자료를 요청하는 동안 브라우저의 다른 기능을 이용할 수 있는 이유도 바로 멀티 스레드 기능 덕분이니 것이다. 즉, 하나의 스레드가 지연되더라도, 다른 스레드는 작업을 지속할 수 있다

멀티 프로세스와 차이점을 부각시키기 위해, 멀티 프로세스를 설명할때 예시를 들었던 웹 브라우저를 다시 들어보면, **멀티 프로세스는 웹 브라우저에서의 여러 탭**이나 **여러창** 이라면, 멀티 스레드는 **웹 브라우저의 단일 탭 또는 창 내에서 브라우저 이벤트 루프, 네트워크 처리, I/O 및 기타 작업을 관리**하고 처리하는데 사용된다.

- **장점**:
   - 효율성: 스레드 간의 커뮤니케이션 비용이 낮고, 컨텍스트 스위칭이 빠릅니다.
   - 자원 공유: 메모리 및 자원을 공유하여 효율적인 리소스 사용이 가능합니다.
- **단점**:
   - 안정성과 보안 문제: 하나의 스레드에서 발생한 오류가 전체 프로세스에 영향을 줄 수 있으며, 스레드 간 데이터 공유로 인해 **동기화 문제**가 발생할 수 있습니다.

> **동기화란?**
스레드에서의 동기화는 **멀티스레딩 환경에서 여러 스레드가 공유 자원에 동시에 접근할 때 발생할 수 있는 문제들을 관리하고, 데이터의 일관성과 정확성을 유지하기 위한 방법**입니다.
>

> **동기화 적업
여러 스레드들이 자원에 대한 접근을 순차적으로 통제 하는 것**
동시 접근으로 인한 동시 수정과 같은 현상은 일어나지 않게 된다. 그러나 동기화 작업은 여러 스레드 접근을 제한하는 것이기 때문에 **병목 현상**이 일어나 성능이 저하될 가능성이 높다는 단점이 있다.
이를 해결하기 위해 임계 영역(Critical Section)에 대하여 뮤텍스(mutex), 또는 세마포어(Semaphore) 방식을 활용한다.
>
> - **임계 영역(Critical Section)**: 여러 스레드가 동시에 접근해서는 안 되는 코드 영역. 일반적으로 공유 자원을 처리할 때 사용됩니다.
> - **뮤텍스(Mutex)**: 임계 영역에 대한 접근을 제어하기 위한 잠금 메커니즘. 한 번에 하나의 스레드만 임계 영역에 접근할 수 있습니다.
> - **세마포어(Semaphore)**: 뮤텍스와 유사하지만, 동시에 여러 스레드가 임계 영역에 접근할 수 있도록 허용하는 카운터 기반의 메커니즘입니다.

> **동기화와 관련된 문제**
>
> - **데드락(Deadlock)**: 둘 이상의 스레드가 서로의 락 해제를 무한히 기다리는 상황으로, 프로그램이 정지하는 원인이 됩니다.
> - **라이브락(Livelock)**: 스레드들이 서로를 방해하지 않도록 반복적으로 상태를 변경하지만, 실제로는 어떤 작업도 진행되지 않는 상황입니다.
> - **스타베이션(Starvation)**: 특정 스레드가 공유 자원에 접근하지 못하고 무한히 대기하는 상황입니다.

## 멀티스레딩 모델

멀티스레딩 모델은 운영 체제가 프로세스 내의 스레드를 어떻게 관리하고 스케줄링하는지에 대한 접근 방식을 말한다. 주요 멀티스레딩 모델에는 대표적으로 "일대일(1:1)", "다대일(N:1)", "다대다(M:N)" 모델이 있고 각 모델은 스레드 생성, 관리, 스케줄링의 방법과 운영 체제와의 상호작용에서 차이를 보인다.  
  
![maxresdefault.jpg](src%2Fresources%2Fstatic%2Fimg%2Fmaxresdefault.jpg)

### 다대일 스레드 매핑 (many to one thread mapping)

다수의 사용자 수준 스레드가 커널 수준 스레드 한개에 매핑하는 유형으로 사용자 수준의 스레드 모델이라 볼 수 있다

- **장점**:
   - 스레드 관리에 필요한 오버헤드가 낮습니다.
      - 커널 개입 없이 사용자 스레드끼리의 스위칭이 발생하기 때문에 오버헤드가 적다.
      - • 스케쥴링이나 동기화를 하려고 커널을 호출하지 않으므로 커널 영역으로 전환하는 오버헤드가 줄어든다
   - 사용자 수준에서 스레드 스케줄링을 제어할 수 있습니다.
- **단점**:
   - 멀티코어 CPU를 효율적으로 사용하기 어렵습니다.
   - 하나의 스레드가 블록되면 모든 스레드가 블록될 수 있습니다.
- **예시**: 구형 UNIX 시스템, 자바에서 초기 버전의 Green Thread

### 일대일 스레드 매핑 (**one to one thread mapping)

사용자 수준 스레드와 커널 수준 스레드가 일대일로 매핑하는 유형으로 커널 수준의 스레드 모델이라 볼 수 있다. 커널이 전체 프로세스와 스레드 정보를 유지해야 하기 때문에 컨텍스트 스위칭 시 사용자 모드에서 커널 모드로 전환해서 스케줄링 하는 등의 오버헤드가 발생한다. 다대다 모델은 다대일, 일대일 모델의 단점을 어느 정도 해결하여, 개발자는 필요한 만큼 많은 사용자 수준 스레드를 생성할 수 있고 커널 수준 스레드가 멀티 프로세서에서 병렬로 수행될 수 있다

- **장점**:
   - 멀티코어 CPU에서 효율적입니다. 각 스레드가 다른 CPU 코어에서 동시에 실행될 수 있습니다.
   - 하나의 스레드에 문제가 발생해도 다른 스레드에 영향을 덜 미칩니다.
- **단점**:
   - 스레드 생성과 관리에 더 많은 시스템 자원이 필요합니다.
- **예시**: Linux, Windows, MacOS.

자원 한정으로 인해 스레드를 무한정으로 생성할 수 없다. 대안으로 스레드 풀을 활용하기도 한다.

### 다대다 스레드 매핑(**many to many thread mapping)

여러 개의 사용자 수준 스레드를 같은 수 또는 그 보다 작은 수의 커널 수준 스레드로 매핑하는 유형이다. 각 커널 수준의 스레드가 사용자 수준의 스레드 한개 이상과 매핑된다.

- **특징**: 여러 사용자 수준 스레드가 여러 커널 스레드와 대응됩니다.
- **장점**:
   - 스레드 관리의 유연성이 높고, 멀티코어 CPU 환경에서 효과적입니다.
   - 사용자 수준과 커널 수준에서 스레드를 동시에 관리할 수 있습니다.
- **단점**:
   - 구현의 복잡성이 높고, 오버헤드 관리가 어렵습니다.
- **예시**: Solaris, 구형 버전의 Windows.

사용자 수준 스레드가 I/O 시스템 콜을 발생시켰을 때, 커널이 다른 스레드의 수행을 스케줄 할 수 있다  
  
# 자바 스레드 구조
자바 스레드는 JVM 에서 사용자 수준 스레드를 생성할 때 시스템 콜을 통해서 커널에서 생성된 커널 스레드와 1:1 매핑이 되어 최종적으로 커널에서 관리 됩니다. JVM 에서 스레드를 생성할때 마다 커널에서 자바 스레드와 대응하는 커널 스레드를 생성한다. 자바에서는 Platform Thread 으로 정의되어있다. 즉 OS 플랫폼에 따라 JVM 이 사용자 스레드를 매핑하게된다

> **Platform threads**
"플랫폼 스레드(Platform Thread)"라는 용어는 일반적으로 **특정 운영 체제에서 네이티브로 제공하는 스레드**를 가리킵니다. 자바에서 스레드를 생성할 때, JVM(Java Virtual Machine)은 내부적으로 운영 체제의 스레드 시스템을 사용하여 이러한 스레드를 구현합니다. 즉, 자바 스레드는 운영 체제의 플랫폼 스레드에 매핑됩니다.

**네이티브 스레드**
"네이티브 스레드"는 **특정 운영 체제에서 지원하는 스레드**를 의미합니다. 이는 운영 체제의 API를 통해 생성되고 관리됩니다.
****주로 프로그래밍 언어나 애플리케이션 수준에서 운영 체제의 스레드를 사용할 때 쓰입니다. 자바 애플리케이션에서 생성된 스레드가 운영 체제의 API를 통해 생성되고 관리되는 스레드를 가리키는데 사용됩니다. 네이티브 스레드는 JVM과 같은 런타임 환경에 의해 추상화되어 관리되며, 이는 운영 체제의 커널 스레드에 매핑됩니다.
>

### **JVM에서의 스레드 처리**

JVM은 자바 애플리케이션을 실행하는 환경입니다. JVM 내부에서 스레드는 다음과 같이 처리됩니다:

- JVM은 각 스레드에 대한 메모리 할당(스택 등)을 관리합니다.
- 자바 스레드는 내부적으로 OS의 네이티브 스레드에 매핑됩니다. 이 매핑은 JVM의 스레드 모델과 OS에 따라 다를 수 있습니다.
- JVM은 스레드의 생명주기(생성, 시작, 실행, 종료)를 관리합니다.

### **OS 스레드 스케줄링과의 차이**

- **운영 체제 수준의 스레드**: 운영 체제는 자체 스레드 스케줄러를 가지고 있으며, 모든 스레드(시스템 스레드 및 사용자 애플리케이션 스레드)를 관리합니다. 이 스케줄러는 CPU 시간을 스레드에 할당하고, 스레드의 실행 순서를 결정합니다.
- **자바 스레드**: 자바에서 생성된 스레드는 결국 OS의 네이티브 스레드로 매핑됩니다. 즉, 실제 스레드의 스케줄링은 OS에 의해 이루어집니다. JVM은 스레드 생성, 관리, 종료 등의 과정을 추상화하고, 자바 프로그래머가 OS에 직접적으로 의존하지 않고 스레드를 사용할 수 있게 합니다.

## 스레드 생성

자바에서 스레드는 주로 두 가지 방법으로 생성됩니다:

1. **`Thread`** 클래스를 상속받아서 구현.
2. **`Runnable`** 인터페이스를 구현.

1. **`Thread` 클래스 상속**:

    ```java
    javaCopy code
    class MyThread extends Thread {
        public void run() {
            // 스레드가 수행할 작업
        }
    }
    
    Thread thread = new MyThread();
    thread.start(); // 스레드 시작
    
    ```

    - 작업 내용을 스레드 내부에 직접 재정의해서 실행
2. **`Runnable` 인터페이스 구현**:

    ```java
    javaCopy code
    class MyRunnable implements Runnable {
        public void run() {
            // 스레드가 수행할 작업
        }
    }
    
    Thread thread = new Thread(new MyRunnable());
    thread.start(); // 스레드 시작
    
    ```

    - 작업 내용을 Runnable 에 정의해서 스레드에 전달
3. **람다 표현식 사용 (Java 8 이상)**:

    ```java
    javaCopy code
    Runnable task = () -> {
        // 스레드가 수행할 작업
    };
    
    Thread thread = new Thread(task);
    thread.start(); // 스레드 시작
    
    ```


1. **Thread 익명 클래스**

    ```java
    Thread thread = new Thread() {
        public void run() {
            // 스레드가 실행할 코드
            System.out.println("Thread 익명 클래스 사용");
        }
    };
    
    thread.start(); // 스레드 시작
    ```

    - 일회용으로만 사용할때
2. **Runnable 익명 클래스**

    ```java
    Runnable runnable = new Runnable() {
        public void run() {
            // 스레드가 실행할 코드
            System.out.println("Runnable 익명 클래스 사용");
        }
    };
    
    Thread thread = new Thread(runnable);
    thread.start(); // 스레드 시작
    ```


### **스레드 상태 변경 메소드**

1. **`start()`**: 새로운 스레드를 시작하고, 스레드의 **`run()`** 메소드를 호출합니다.
2. **`run()`**: 스레드가 수행할 작업을 정의합니다.
3. **`sleep(long millis)`**: 현재 스레드를 지정된 시간(밀리초) 동안 일시 중지합니다.
4. **`join()`**: 스레드가 종료될 때까지 현재 스레드의 실행을 중지합니다.
5. **`interrupt()`**: 스레드에 인터럽트를 보냅니다. 인터럽트에 응답하는 방식은 스레드의 **`run()`** 메소드 구현에 달렸습니다.
6. **`yield()`**: 현재 스레드가 실행 중지를 하고 다른 스레드에 실행 기회를 제공합니다.

### **기타 메소드**

- **`setPriority(int newPriority)`**: 스레드의 우선순위를 설정합니다.
- **`getPriority()`**: 스레드의 현재 우선순위를 반환합니다.
- **`setName(String name)`**: 스레드의 이름을 설정합니다.
- **`getName()`**: 스레드의 이름을 반환합니다.
- **`isAlive()`**: 스레드가 살아 있는지(시작되었고 아직 종료되지 않았는지) 확인합니다.
- **`isInterrupted()`**: 스레드가 인터럽트 되었는지 확인합니다.
- **`static interrupted()`**: 현재 스레드의 인터럽트 상태를 확인하고, 인터럽트 상태를 초기화합다.  

# 스레드 실행

자바 스레드는 OS 스케줄러에 의해 실행 순서가 결정되며 스레드 실행 시점을 JVM 에서 제어할 수 없고 새로운 스레드는 현재 스레드 와 독립적으로 실행되고 최대 한번 시작할 수 있고 스레드가 종료된 후에는 다시 시작 할 수 없다.

자바에서 스레드 실행 과정을 설명하기 위해, 가장 기본적인 예로 **`main`** 스레드가 다른 스레드를 생성하고 시작하는 과정을 살펴보면 자바에서 스레드 실행 과정은 다음과 같은 단계를 거친다.

1. **스레드 클래스 정의**: 자바에서 스레드를 생성하기 위해서는 **`Thread`** 클래스를 확장하거나 **`Runnable`** 인터페이스를 구현하는 클래스를 정의해야 합니다.
2. **스레드 객체 생성**: 정의된 스레드 클래스 또는 **`Runnable`** 객체를 기반으로 **`Thread`** 객체를 생성합니다.
3. **스레드 시작 (`start()` 메소드 호출)**: 생성된 스레드 객체에 대해 **`start()`** 메소드를 호출합니다. 이 메소드는 스레드를 실행 가능한 상태로 만들고, 자바 가상 머신(JVM)에 이 스레드를 시작하도록 요청합니다.
4. **`start0()` 메소드 호출**: 내부적으로 **`start()`** 메소드는 네이티브 메소드인 **`start0()`**을 호출합니다. 이 메소드는 운영 체제 수준에서 새로운 스레드를 생성하고(커널 스레드가 생성되고 자바 스레드와 커널 스레드가 1대1 매핑이 이루어짐), 스레드에 할당된 **`run()`** 메소드를 실행합니다.
5. **실행 대기** : OS 스케줄러로 부터 CPU 할당을 받기까지 실행 대기 상태에 있는다.
6. **스레드 실행 (`run()` 메소드 실행)**: **`run()`** 메소드는 스레드가 수행해야 할 작업을 정의합니다. **`start0()`**에 의해 호출되면, 이 스레드는 **`run()`** 메소드에 정의된 작업을 수행하기 시작합니다.
7. **스레드 종료**: **`run()`** 메소드의 실행이 완료되면, 스레드는 자동적으로 종료됩니다.

> **네이티브 메소드(native method)**
네이티브 메소드(native method)는 자바에서 사용되는 **특별한 유형의 메소드**로, **자바 코드가 아닌 네이티브 프로그래밍 언어(보통 C나 C++)로 작성된 코드를 실행**합니다. 이러한 메소드들은 자바 네이티브 인터페이스(Java Native Interface, JNI)를 사용하여 구현됩니다.
>

예를 들어, **`main`** 스레드에서 새로운 스레드를 생성하고 시작하는 간단한 예제

```java
javaCopy code
public class MyThread extends Thread {
    public void run() {
        System.out.println("새로운 스레드 실행 중");
    }

    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start(); // 여기에서 start0()가 내부적으로 호출되고, 스레드 실행이 시작됩니다.
    }
}

```

이 과정을 통해, 자바 프로그램에서는 멀티스레딩을 효과적으로 관리하고, 여러 작업을 동시에 수행할 수 있다.

즉, `start()` 는 스레드를 실행 시키는 메소드로 **시스템 콜을 통해서 커널에 스레드 생성을 요청 `run()`** 는 **스레드가 실행이 되면 해당 스레드에 의해 자동을 호출**되며 Thread 의 run() 이 자동으로 호출되고 여기서 Runnable 구현체가 존재할 경우 Runnable 의 run()을 실행한다. public static void main 가 메인 스레드에 의해 자동으로 호출되는 것과 비슷한 원리이다.

이때 start() 메소드가 아니라 바로 run() 메소드를 직접 호출하면 새로운 스레드가 생성되지 않고 직접 호출한 스레드의 실행 스택에서 run이 실행된다.

1. **`start()` 메소드 호출**:
    - 새로운 스레드를 생성합니다. **`start()`** 메소드가 호출되면, 자바 가상 머신(JVM)은 새로운 스레드를 배치하고, 이 스레드에서 **`run()`** 메소드를 실행합니다.
    - **`start()`** 메소드는 내부적으로 네이티브 메소드를 호출하여 실제 운영 체제 스레드를 생성하고, 해당 스레드에서 **`run()`** 메소드를 별도의 실행 경로(execution path)에서 실행합니다.
    - 이렇게 하면 **`run()`** 메소드는 병렬로 실행되며, 다른 스레드와 동시에 실행될 수 있습니다.
2. **`run()` 메소드 직접 호출**:
    - **`run()`** 메소드를 직접 호출하는 것은 일반 메소드 호출과 같으며, 새로운 스레드를 생성하지 않습니다.
    - 이 경우, **`run()`** 메소드는 현재 스레드(예: **`main`** 스레드)에서 실행되며, 병렬 실행이 아니라 순차적으로 실행됩니다.
    - **`run()`**을 직접 호출하면 멀티스레딩의 이점을 활용할 수 없으며, 단순히 **`run()`** 메소드에 정의된 코드를 현재 스레드에서 실행하는 것과 같습니다.

결론적으로, 멀티스레딩을 활용하려면 반드시 **`start()`** 메소드를 호출해야 하며, **`run()`** 메소드를 직접 호출하는 것은 단순한 메소드 호출로서, 새로운 스레드를 생성하거나 병렬 실행을 하지 않는다.

### 스레드 스택

스레드가 생성되면 해당 스레드를 위한 스택이 같이 생성되면 이 스택은 각 스레드마다 독립적으로 할당되어 동작하기 때문에 서로간 접근이나 공유할 수 없다. 이 스택은 OS에 따라 크기가 주어지고 주어진 크기를 넘기게 되면 그 유명한 `StackOverFlowError` 가 발생하게 된다.

이 스택은 **스레드가 함수 호출을 수행할 때 필요한 데이터를 저장하는 데 사용**한다.

> **스택 프레임(Stack Frame)**
스택 프레임(Stack Frame)은 프로그램의 함수 호출과 실행에 필요한 정보를 저장하는 스택(Stack) 내의 데이터 구조입니다. 각 함수 호출 시에 하나의 스택 프레임이 생성되며, 이 프레임은 해당 함수가 실행되는 동안 필요한 다양한 정보를 포함합니다.
>

### 구성 정보

스레드 스택은 주로 로컬 변수, 함수 호출 정보, 반환 주소 등을 저장하는 데 사용됩니다. 함수 호출이 발생할 때마다, 호출된 함수의 로컬 변수와 매개변수가 스택에 푸시(push)됩고 함수가 반환될 때, 해당 데이터는 스택에서 팝(pop)되어 제거된다.

**1. 스택 프레임(Stack Frame)**

- 스레드 스택은 여러 개의 스택 프레임으로 구성됩니다. 각 스택 프레임은 개별 함수 호출에 대한 정보를 담고 있습니다.
- 함수가 호출될 때마다 새로운 스택 프레임이 스택에 푸시되고, 함수가 반환될 때 해당 프레임은 스택에서 팝됩니다.

**2. 로컬 변수(Local Variables)**

- 각 스택 프레임은 해당 함수의 로컬 변수를 저장합니다. 이러한 변수는 함수 호출이 끝날 때까지 유효합니다.

**3. 매개변수(Parameters)**

- 함수로 전달되는 매개변수는 대부분 스택 프레임 내에 저장됩니다. 이를 통해 함수 내에서 매개변수에 접근할 수 있습니다.

**4. 반환 주소(Return Address)**

- 함수가 호출될 때, 함수가 반환될 때 다시 돌아갈 위치의 주소(반환 주소)가 스택에 저장됩니다. 함수 실행이 끝나면, 이 주소를 사용하여 호출자 함수로 돌아갑니다.

**5. 스택 포인터(Stack Pointer)**

- 스택 포인터는 스택의 현재 위치를 가리킵니다. 새로운 스택 프레임이 푸시되거나 팝될 때마다 스택 포인터가 업데이트됩니다.

**6. 프레임 포인터(Frame Pointer)**

- 프레임 포인터는 현재 활성화된 스택 프레임의 시작 부분을 가리키는데 사용됩니다. 이를 통해 현재 함수의 로컬 변수와 매개변수에 접근할 수 있습니다.

**7. 임시 저장 공간(Temporary Space)**

- 함수의 계산 중간 결과를 임시로 저장하는 공간입니다. 이 공간은 스택 프레임 내에서 필요에 따라 사용됩니다.

**8. 예외 처리 정보(Exception Handling Information)**

- 일부 프로그래밍 언어에서는 함수 내에서 발생할 수 있는 예외 처리를 위한 정보를 스택 프레임에 저장합니다.

### 스텍 메모리 상태 관리

스택은 제한된 크기를 갖으며, 일반적으로 운영 체제나 JVM 설정에 따라 결정된다. 스택 오버플로(stack overflow)는 스택이 할당된 메모리 크기를 초과할 때 발생하고 이는 무한 재귀 호출로 인해 발생할 수 있습니다. 스택 내부의 변수는 변수를 생성한 메소드가 실행되는 동안에만 존재하고 스택 메모리에 대한 접근은 Heap 메모리와 비교할때 상당히 빠르다.

### 스레드 종료

스레드는 run() 메소드가 모두 실행되면 자동으로 종료한다. 이때 예외가 발생할 경우 또한 종료되며 다른 스레드에 영향을 미치지 않는다.어플리케이션은 싱글스레드인 경우와 멀티스레드인 경우 종료 기준이 다르다

### **싱글 스레드 어플리케이션**

- 싱글 스레드 어플리케이션에서는 주로 하나의 실행 흐름만 존재합니다.
- **종료 기준**: 주 스레드(main thread)의 실행이 종료되면, 어플리케이션의 실행도 종료됩니다. 이는 보통 주 스레드의 **`main`** 함수나 유사한 진입점(entry point)의 코드가 모두 실행 완료되었을 때 발생합니다.
- 특별한 예외 처리나 중단 요청이 없는 한, **`main`** 함수 내의 코드가 순차적으로 모두 실행된 후 어플리케이션이 종료됩니다.

### **멀티스레드 어플리케이션**

- 멀티스레드 어플리케이션에서는 여러 개의 동시 실행 흐름(스레드)이 존재합니다.
- **종료 기준**: 멀티스레드 환경에서 어플리케이션의 종료 기준은 프로그래밍 언어와 환경에 따라 다를 수 있습니다. 일반적으로는 다음 두 가지 방법 중 하나를 따릅니다:
    - **모든 스레드의 종료**: 주 스레드와 모든 백그라운드 스레드가 종료될 때까지 어플리케이션이 실행 상태를 유지합니다.
    - **주 스레드의 종료만으로 충분**: 일부 환경(예: 일부 자바 어플리케이션)에서는 주 스레드가 종료되면 어플리케이션이 종료되며, 이 때 모든 백그라운드 스레드도 강제 종료됩니다. 다만, 이 경우에도 대기 중인 '데몬 스레드(daemon threads)'가 있다면 이들은 주 스레드 종료와 함께 즉시 중단됩니다.  


## 스레드의 상태

자바 스레드는 생성과 실행 그리고 종료에 따른 상태를 가지고 있으며 JVM 에서는 6가지의 스레드 상태가 존재한다. 이때 OS 스레드의 상태를 의미하지 않는다. 이 상태는 Thread의 getState() 메소드를 통해서 가져올 수 있으며 ENUM 상수를 정의하는 Tread.State 클래스를 제공한다.

| 상태 | 설명 |
| --- | --- |
| 신규 (New) | 스레드 객체가 생성되었지만 start() 메소드가 아직 호출되지 않은 상태. |
| 실행 가능 (Runnable) | start() 메소드가 호출된 후, 실행을 위해 CPU 시간을 기다리는 상태. 실행 중과 실행 대기 상태를 포함. |
| 블록 (Blocked) | 다른 스레드가 사용 중인 객체의 잠금(락)을 얻지 못하고 대기하는 상태. |
| 대기 (Waiting) | 다른 스레드의 작업이 완료될 때까지 기다리는 상태. Object.wait(), Thread.join(), LockSupport.park()에 의해 발생. |
| 시간 대기 (Timed Waiting) | 지정된 시간 동안 대기하는 상태. Thread.sleep(), Object.wait(long timeout), Thread.join(long millis) 등에 의해 발생. |
| 종료 (Terminated) | 스레드의 실행이 완료된 상태. run() 메소드가 완료되거나 예외로 인해 종료됨. |
  

## 스레드 기본 API
## 1. sleep()

Java에서 **`Thread.sleep()`** 메소드는 현재 실행중인 스레드를 지정된 시간 동안 일시 중지시키는 데 사용된다. 이 메소드는 스레드가 일정 시간 동안 작업을 하지 않도록 하여, 다른 스레드가 CPU 자원을 사용할 수 있도록 한다. 네이티브 메소드로 연결되며 시스템 콜을 통해 커널모드에서 수행 후 유저 모드로 전환한다.

즉, **`Thread.sleep()`** 메소드를 호출할 때 스레드의 상태는 "**실행 중(Runnable)**"에서 "**일시 중지 상태(Timed Waiting)**"로 **변경**됩니다.

### 기본 코드

```java
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    e.printStackTrace();
    // 적절한 예외 처리
}
```

### API

### **1. Thread.sleep(long millis)**

이 형태의 **`sleep()`** 메소드는 스레드를 밀리초 단위로 일시 중지시킵니다.

- **파라미터**: **`millis`** - 스레드가 일시 중지될 밀리초 단위의 시간.
- **사용 예**: **`Thread.sleep(1000);`**은 스레드를 1초 동안 일시 중지시킵니다.

### **2. Thread.sleep(long millis, int nanos)**

이 형태의 **`sleep()`** 메소드는 스레드를 밀리초와 나노초를 결합한 형태로 일시 중지시킵니다.

- **파라미터**:
    - **`millis`** - 스레드가 일시 중지될 밀리초 단위의 시간.
    - **`nanos`** - 추가적으로 스레드가 일시 중지될 나노초 단위의 시간 (0에서 999999까지).
- **사용 예**: **`Thread.sleep(1000, 500000);`**은 스레드를 1초와 500,000나노초(0.5초) 동안 일시 중지시킵니다.

### 관련 예외

### **InterruptedException**

- **원인**: 현재 스레드가 sleep, wait, join 등의 중단 상태에 있을 때, 다른 스레드가 이 스레드를 깨우려고 **`interrupt()`** 메소드를 호출하면 발생합니다.
- **처리 방법**: 이 예외는 checked 예외로, 반드시 try-catch 블록을 사용하거나 메소드 선언에 예외를 명시해야 합니다.
- **일반적인 사용 예**: 스레드가 일정 시간 동안 대기한 후에 다시 작업을 수행해야 하는 경우, 또는 스레드를 안전하게 종료시키기 위해 사용됩니다.

### 예시

두 개의 스레드, 즉 스레드 1과 스레드 2가 있으며, 스레드 1이 **`sleep()`** 메소드를 사용하여 일시 중지 상태에 들어가고, 이후 스레드 2가 스레드 1에게 인터럽트를 보내는 상황을 가정해보자.

### **초기 상황**

1. **스레드 1 실행**: 스레드 1은 실행 상태에 있다. 이 때 스레드는 CPU 자원을 사용하고 있으며, 작업을 수행하고 있다.
2. **스레드 1 일시 중지**: 스레드 1이 **`Thread.sleep()`** 메소드를 호출한다. 이 호출로 인해 스레드 1은 일시 중지 상태인 "시간 대기 상태(Timed Waiting)"로 전환되고 이 상태에서는 스레드 1이 CPU 자원을 사용하지 않으며, 지정된 시간 동안 대기하게 된다.

### **컨텍스트 스위칭**

1. **스레드 2 실행**: 스레드 1이 대기 상태에 있기 때문에, **스레드 스케줄러**는 스레드 2에게 CPU 자원을 할당한다. 이로 인해 컨텍스트 스위칭이 발생하고, 스레드 2가 실행 상태가 된다. 스레드 2는 이제 작업을 수행할 수 있다.

### **인터럽트 발생**

1. **스레드 2에 의한 인터럽트**: 스레드 2가 어떤 이유로 스레드 1을 깨우기로 결정한다. 이를 위해 스레드 2는 스레드 1의 **`interrupt()`** 메소드를 호출한다. 이 호출은 스레드 1에 인터럽트 신호를 보낸다.

### **스레드 1의 응답**

1. **스레드 1의 상태 변화**: 스레드 1은 인터럽트 신호를 받는다. 이 신호는 스레드 1이 **`sleep()`** 상태에서 깨어나게 만듭니다. 이 때 스레드 1은 "실행 가능(Runnable)" 상태로 전환된다. 하지만 바로 실행 상태로 가는 것은 아니며, **실행을 위해 스레드 스케줄러의 결정을 기다립니다.**
2. **InterruptedException 발생**: 스레드 1은 **`InterruptedException`**을 발생시킵니다. 이 예외는 스레드 1이 **`sleep()`** 메소드에서 **깨어날 때 자동으로 발생**합니다.

### **예외 처리**

1. **스레드 1의 예외 처리**: 스레드 1은 **`InterruptedException`**을 처리해야 합니다. 이를 위해 스레드 1 내에서 이 예외를 처리하는 코드가 실행됩니다. 이 처리는 스레드가 이 인터럽트에 어떻게 반응할지 결정하는 로직을 포함할 수 있습니다. 예를 들어, 스레드를 안전하게 종료하거나 특정 작업을 재개하는 등의 동작을 수행할 수 있습니다.

### **실행 재개**

1. **스레드 1의 작업 재개**: 예외 처리가 완료된 후, 스레드 1은 다시 스레드 스케줄러에 의해 실행 상태로 전환될 수 있습니다. 이때 스레드 1은 중단되었던 작업을 계속하거나 새로운 작업을 시작할 수 있습니다.

이 과정에서 중요한 점은 스레드가 **`sleep()`** 상태에서 인터럽트될 경우, **`InterruptedException`**을 적절하게 처리해야 한다는 것이다. 이를 통해 스레드가 예상치 못한 상황에 안전하게 대처하고, 필요한 자원 정리와 상태 관리를 할 수 있다.

### sleep(0) 과 sleep(n)의 의미

sleep(millis) 메서드는 네이티브 메서드이기 때문에 sleep(millis) 을 실행하게 되면 시스템 콜을 호출하게 되어 유저모드에서 커널모드로 전환된다. 이때 다른 스레드에게 명확하게 실행을 양보하기 위함이라면 sleep(0) 보다는 sleep(1)을 사용하는 것이 좋다.

### **Thread.sleep(0)**

**`Thread.sleep(0)`** 호출은 스레드를 0 밀리초 동안 일시 중지시키라는 명령입니다. 이론적으로는 스레드가 대기 상태에 들어갔다가 바로 나오는 것을 의미한다. 실제 효과는 종종 운영체제의 스레드 스케줄러에 의존적인데 이는 스레드가 실행 큐의 끝으로 이동하고(**커널 모드로 전환**), 다른 스레드에게 실행 기회를 제공할 수 있음을 의미한다. 즉, 동일 우선순위를 가진 다른 스레드에게 실행 기회를 양보하는 효과가 있을 수 있습니다. 하지만 만약 우선순위가 동일한 실행대기 상태의 다른 스레드가 없으면 스케줄러는 현재 스레드에게 계속 CPU를 할당해서 컨텍스트 스위칭이 없고 모드 전환만 일어난다.

### **Thread.sleep(n)**

스레드가 커널 모드로 전환 후 스케줄러는 조건에 상관없이 현재 스레드를 대기 상태에 두고 다른 스레드에게 CPU를 할당함으로 모든 전환과 함께 컨텍스트 스위칭이 발생한다.

### 정리

- sleep() 이 되면 OS 스케줄러는 현재 스레드를 지정된 시간 동안 대기 상태로 전환하고 다른 스레드 혹은 프로세스에게 CPU 를 사용하도록 한다
- 대기 시간이 끝나면 스레드 상태는 바로 실행상태가 아닌 실행 대기 상태로 전환 되고 CPU 가 실행을 재개할 때 까지 기다린다.
- 실행 상태가 되면 스레드는 남은 지점부터 실행을 다시 시작한다
- 동기화 메서드 영역에서 수면 중인 스레드는 획득한 모니터나 락을 잃지 않고 계속 유지한다
- sleep() 중인 스레드에게 인터럽트가 발생할 경우 현재 스레드는 대기에서 해제되고 실행상태로 전환되어 예외를 처리하게 된다
- 스레드의 수면 시간은 OS 스케줄러 및 시스템 기능에 따라 제한되기 때문에 정확성이 보장되지 않으며 시스템의 부하가 많고 적음에 따라 지정한 수면 시간과 차이가 날 수 있다  

## 2. join()

Java에서 **`Thread`** 클래스의 **`join()`** 메소드는 한 스레드가 다른 스레드의 종료를 기다리는 데 사용된다. **`join()`** 메소드를 호출한 스레드는 지정된 스레드가 종료될 때까지 대기하게 됩니다. 이는 스레드 간의 동기화와 순서를 제어하는 데 유용합니다.즉 스레드의 순서를 제어하거나 다른 스레드의 작업을 기다려야 하거나 순차적인 흐름을 구성하고자 할때 사용한다. 이때 `Object` 클래스의 `wait()` 네이티브 메소드로 연결되며 시스템 콜을 통해 커널모드로 수행한다. 내부적으로는 wait() & notify() 흐름을 가지고 제어한다.

```java
Thread thread = new Thread(() -> {
    // 스레드가 수행할 작업
});
thread.start();

try {
    thread.join();  // 현재 스레드가 'thread'의 종료를 기다림
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

### API

### 1. **void join()**

이 메소드는 현재 스레드가 다른 스레드(대상 스레드)의 **`run()`** 메소드가 완료될 때까지 기다리게 합니다. 다시 말해, 대상 스레드가 종료될 때까지 현재 스레드는 대기 상태에 머무릅니다.

### 2. **void join(long millis)**

이 메소드는 현재 스레드가 대상 스레드의 **`run()`** 메소드 완료 또는 지정된 시간(밀리초 단위)이 경과할 때까지 기다리게 합니다. 시간이 만료되면, 대기 중인 스레드는 자동으로 다시 실행 상태로 돌아갑니다.

### 3. **void join(long millis, int nanos)**

이 메소드는 현재 스레드가 대상 스레드의 **`run()`** 메소드 완료 또는 지정된 시간(밀리초와 나노초를 결합한 형태)이 경과할 때까지 기다리게 합니다. 이때 나노초의 범위는 0에서 999999 이다.

### 관련 예외

### **InterruptedException**

- **원인**: 현재 스레드가 **`join()`**, **`wait()`**, **`sleep()`** 등의 메소드로 인해 대기 상태에 있을 때, 다른 스레드가 이 스레드의 **`interrupt()`** 메소드를 호출하면 **`InterruptedException`**이 발생합니다. **`join()`** 메소드를 사용하는 경우, 해당 스레드가 다른 스레드의 종료를 기다리는 동안 인터럽트될 때 이 예외가 발생합니다.
- **처리 방법**: **`InterruptedException`**은 checked 예외로, 반드시 try-catch 블록을 사용하여 처리하거나, 메소드 선언에 예외를 명시해야 합니다.
- **일반적인 사용 예**: 두 스레드 간의 작업 순서를 조정하거나, 한 스레드가 다른 스레드의 작업 완료를 기다리는 경우에 **`join()`** 메소드와 함께 사용됩니다.

### 실행흐름 예시

1. **메인 스레드 실행**: 메인 스레드가 실행되고, 특정 시점에서 **`join()`** 메소드를 호출합니다. 이 호출은 메인 스레드가 스레드 1의 종료를 기다리게 만듭니다.
2. **메인 스레드 일시 정지**: **`join()`** 메소드를 만나면, 메인 스레드는 일시적으로 실행을 멈추고 대기 상태로 전환됩니다. 내부적으로, 이는 **`wait()`** 메소드와 유사한 메커니즘을 사용하여 메인 스레드를 대기 상태로 만듭니다.
3. **스레드 1 실행**: 이 시점에서, 스레드 1은 실행 상태로 전환됩니다(컨텍스트 스위칭). 스레드 1은 할당된 작업을 수행합니다.
4. **스레드 1 종료와 메인 스레드 깨우기**: 스레드 1의 작업이 완료되면, 자동적으로 메인 스레드에게 '작업 완료' 신호를 보냅니다. 이는 내부적으로 **`notify()`** 메소드와 유사한 메커니즘으로 처리되며, 이 신호로 인해 메인 스레드의 대기 상태가 해제됩니다.
5. **메인 스레드 재개**: **`notify()`**와 유사한 신호를 받은 메인 스레드는 대기 상태에서 벗어나 다시 실행 상태로 전환됩니다. 메인 스레드는 **`join()`** 호출 이후의 코드를 계속해서 실행합니다.

이때 **`join()`** 메소드는 내부적으로 **`Object`** 클래스의 **`wait()`**와 **`notify()`** 메커니즘을 활용하여 스레드 간의 동기화를 수행한다. 이는 스레드가 다른 스레드의 종료를 기다리는 동안 CPU 자원을 낭비하지 않도록 한다. **`join()`** 메소드는 스레드 간의 동기화와 순서 제어에 매우 유용하지만, 데드락(Deadlock) 같은 상황을 방지하기 위해 신중하게 사용해야 한다. 데드락은 두 스레드 또는 그 이상이 서로의 작업 완료를 무한히 기다리는 상태를 말합니다.

### **인터럽트 발생 시키기**

1. **스레드 2에 의한 인터럽트**: 이 시점에서, 스레드 2가 실행되고, 어떤 이유로 메인 스레드를 인터럽트합니다. 이를 위해 스레드 2는 메인 스레드의 **`interrupt()`** 메소드를 호출합니다.

### **메인 스레드의 응답**

1. **메인 스레드의 인터럽트 처리**: 메인 스레드는 인터럽트 신호를 받습니다. **`join()`** 메소드가 인터럽트에 의해 중단되면, **`InterruptedException`** 예외가 발생합니다. 메인 스레드는 이 예외를 잡아서 처리합니다.

### **예외 처리와 실행 재개**

1. **예외 처리 및 실행 대기 상태로 전환**: 메인 스레드는 **`InterruptedException`**을 처리합니다. 일반적으로 이 예외 처리는 인터럽트 발생 사실을 로그로 기록하거나, 메인 스레드의 현재 상태에 따라 적절한 조치를 취하는 코드를 포함할 수 있습니다. 예외 처리가 완료되면, 메인 스레드는 대기 상태에서 벗어나 실행 대기 상태로 전환됩니다.
2. **메인 스레드의 작업 재개**: 예외 처리가 완료되고 나면, 메인 스레드는 다시 실행 가능한 상태가 되며, 스레드 스케줄러에 의해 실행될 준비가 됩니다. 스레드 스케줄러는 메인 스레드를 다시 실행 큐에 배치하여 작업을 재개할 수 있도록 합니다.

### 정리

- join() 을 실행하면 OS 스케줄러는 join() 을 호출한 스레드를 대기 상태로 전환하고 호출 대상 스레드에게 CPU 를 사용하도록 한다
- 호출 대상 스레드의 작업이 종료되면 join() 을 호출한 스레드는 실행 대기 상태로 전환 되고 CPU 가 실행을 재개할 때 까지 기다린다.
- join() 을 호출한 스레드가 실행 대기에서 실행 상태가 되면 그 스레드는 남은 지점부터 실행을 다시 시작한다
- 호출 대상 스레드가 여러 개일 경우 각 스레드의 작업이 종료될 때 까지 join() 을 호출한 스레드는 대기와 실행을 재개하는 흐름을 반복한다
- join() 을 호출한 스레드가 인터럽트 되면 해당 스레드는 대기에서 해제되고 실행상태로 전환되어 예외를 처리하게 된다